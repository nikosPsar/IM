# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_connection_point_nsd__nsd_catalog_nsd_connection_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/connection-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for external connection points.
Each NS has one or more external connection
points. As the name implies that external
connection points are used for connecting
the NS to other NS or to external networks.
Each NS exposes these connection points to
the orchestrator. The orchestrator can
construct network service chains by
connecting the connection points between
different NS.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__floating_ip_required','__type','__vld_id_ref','__member_vnf_index_ref','__vnfd_id_ref','__vnfd_connection_point_ref',)

  _yang_name = 'connection-point'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnfd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__floating_ip_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__vld_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld-id-ref", parent=self, choice=(u'connection', u'vld-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:connection-point-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'connection-point']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/connection_point/name (string)

    YANG Description: Name of the connection point.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/connection_point/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the connection point.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_floating_ip_required(self):
    """
    Getter method for floating_ip_required, mapped from YANG variable /nsd_catalog/nsd/connection_point/floating_ip_required (boolean)

    YANG Description: Boolean parameter to indicate whether the CP must be exposed.
A public IP address will be allocated to this CP if exposed is true.
The default is false meaning a floating IP address is not required.
It must be explicitly asked for a floating IP address to be allocated.
    """
    return self.__floating_ip_required
      
  def _set_floating_ip_required(self, v, load=False):
    """
    Setter method for floating_ip_required, mapped from YANG variable /nsd_catalog/nsd/connection_point/floating_ip_required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_required() directly.

    YANG Description: Boolean parameter to indicate whether the CP must be exposed.
A public IP address will be allocated to this CP if exposed is true.
The default is false meaning a floating IP address is not required.
It must be explicitly asked for a floating IP address to be allocated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """floating_ip_required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""",
        })

    self.__floating_ip_required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_floating_ip_required(self):
    self.__floating_ip_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /nsd_catalog/nsd/connection_point/type (manotypes:connection-point-type)

    YANG Description: Type of the connection point.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /nsd_catalog/nsd/connection_point/type (manotypes:connection-point-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the connection point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:connection-point-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with manotypes:connection-point-type""",
          'defined-type': "manotypes:connection-point-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:connection-point-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:connection-point-type', is_config=True)


  def _get_vld_id_ref(self):
    """
    Getter method for vld_id_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vld_id_ref (leafref)

    YANG Description: ID reference to a VLD in the NS
    """
    return self.__vld_id_ref
      
  def _set_vld_id_ref(self, v, load=False):
    """
    Setter method for vld_id_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vld_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vld_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vld_id_ref() directly.

    YANG Description: ID reference to a VLD in the NS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vld-id-ref", parent=self, choice=(u'connection', u'vld-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vld_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld-id-ref", parent=self, choice=(u'connection', u'vld-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vld_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vld_id_ref(self):
    self.__vld_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vld-id-ref", parent=self, choice=(u'connection', u'vld-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_member_vnf_index_ref(self):
    """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/member_vnf_index_ref (leafref)

    YANG Description: Reference to member-vnf within constituent-vnfd
    """
    return self.__member_vnf_index_ref
      
  def _set_member_vnf_index_ref(self, v, load=False):
    """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Reference to member-vnf within constituent-vnfd
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnf_index_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__member_vnf_index_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnf_index_ref(self):
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnfd_id_ref(self):
    """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vnfd_id_ref (leafref)

    YANG Description: A reference to a vnfd. This is a leafref to path:
   ../../nsd:constituent-vnfd
   + [nsd:id = current()/../nsd:id-ref]
   + /nsd:vnfd-id-ref
    """
    return self.__vnfd_id_ref
      
  def _set_vnfd_id_ref(self, v, load=False):
    """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a vnfd. This is a leafref to path:
   ../../nsd:constituent-vnfd
   + [nsd:id = current()/../nsd:id-ref]
   + /nsd:vnfd-id-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_id_ref(self):
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnfd_connection_point_ref(self):
    """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vnfd_connection_point_ref (leafref)

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
    """
    return self.__vnfd_connection_point_ref
      
  def _set_vnfd_connection_point_ref(self, v, load=False):
    """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vnfd_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_connection_point_ref(self):
    self.__vnfd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  floating_ip_required = __builtin__.property(_get_floating_ip_required, _set_floating_ip_required)
  type = __builtin__.property(_get_type, _set_type)
  vld_id_ref = __builtin__.property(_get_vld_id_ref, _set_vld_id_ref)
  member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref, _set_member_vnf_index_ref)
  vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref, _set_vnfd_id_ref)
  vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref, _set_vnfd_connection_point_ref)

  __choices__ = {u'connection': {u'vld-ref': [u'vld_id_ref'], u'vnfd-connection-point-ref': [u'member_vnf_index_ref', u'vnfd_id_ref', u'vnfd_connection_point_ref']}}
  _pyangbind_elements = OrderedDict([('name', name), ('floating_ip_required', floating_ip_required), ('type', type), ('vld_id_ref', vld_id_ref), ('member_vnf_index_ref', member_vnf_index_ref), ('vnfd_id_ref', vnfd_id_ref), ('vnfd_connection_point_ref', vnfd_connection_point_ref), ])


class yc_scaling_criteria_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy_scaling_criteria(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/scaling-group-descriptor/scaling-policy/scaling-criteria. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: list of conditions to be met for generating scaling
  requests
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__scale_in_threshold','__scale_in_relational_operation','__scale_out_threshold','__scale_out_relational_operation','__ns_monitoring_param_ref',)

  _yang_name = 'scaling-criteria'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__ns_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__scale_out_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    self.__scale_in_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    self.__scale_out_relational_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:relational-operation-type', is_config=True)
    self.__scale_in_relational_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:relational-operation-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'scaling-group-descriptor', u'scaling-policy', u'scaling-criteria']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_scale_in_threshold(self):
    """
    Getter method for scale_in_threshold, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_threshold (uint64)

    YANG Description: Value below which scale-in requests are generated
    """
    return self.__scale_in_threshold
      
  def _set_scale_in_threshold(self, v, load=False):
    """
    Setter method for scale_in_threshold, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_threshold() directly.

    YANG Description: Value below which scale-in requests are generated
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_in_threshold must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""",
        })

    self.__scale_in_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_in_threshold(self):
    self.__scale_in_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)


  def _get_scale_in_relational_operation(self):
    """
    Getter method for scale_in_relational_operation, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_relational_operation (manotypes:relational-operation-type)

    YANG Description: The relational operator used to compare the monitoring param
against the scale-in-threshold.
    """
    return self.__scale_in_relational_operation
      
  def _set_scale_in_relational_operation(self, v, load=False):
    """
    Setter method for scale_in_relational_operation, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_relational_operation (manotypes:relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_relational_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_relational_operation() directly.

    YANG Description: The relational operator used to compare the monitoring param
against the scale-in-threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:relational-operation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_in_relational_operation must be of a type compatible with manotypes:relational-operation-type""",
          'defined-type': "manotypes:relational-operation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:relational-operation-type', is_config=True)""",
        })

    self.__scale_in_relational_operation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_in_relational_operation(self):
    self.__scale_in_relational_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:relational-operation-type', is_config=True)


  def _get_scale_out_threshold(self):
    """
    Getter method for scale_out_threshold, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_threshold (uint64)

    YANG Description: Value above which scale-out requests are generated
    """
    return self.__scale_out_threshold
      
  def _set_scale_out_threshold(self, v, load=False):
    """
    Setter method for scale_out_threshold, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_threshold() directly.

    YANG Description: Value above which scale-out requests are generated
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_out_threshold must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""",
        })

    self.__scale_out_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_out_threshold(self):
    self.__scale_out_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)


  def _get_scale_out_relational_operation(self):
    """
    Getter method for scale_out_relational_operation, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_relational_operation (manotypes:relational-operation-type)

    YANG Description: The relational operator used to compare the monitoring param
against the scale-out-threshold.
    """
    return self.__scale_out_relational_operation
      
  def _set_scale_out_relational_operation(self, v, load=False):
    """
    Setter method for scale_out_relational_operation, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_relational_operation (manotypes:relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_relational_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_relational_operation() directly.

    YANG Description: The relational operator used to compare the monitoring param
against the scale-out-threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:relational-operation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_out_relational_operation must be of a type compatible with manotypes:relational-operation-type""",
          'defined-type': "manotypes:relational-operation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:relational-operation-type', is_config=True)""",
        })

    self.__scale_out_relational_operation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_out_relational_operation(self):
    self.__scale_out_relational_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:relational-operation-type', is_config=True)


  def _get_ns_monitoring_param_ref(self):
    """
    Getter method for ns_monitoring_param_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/ns_monitoring_param_ref (leafref)

    YANG Description: Reference to the NS level monitoring parameter
that is aggregated
    """
    return self.__ns_monitoring_param_ref
      
  def _set_ns_monitoring_param_ref(self, v, load=False):
    """
    Setter method for ns_monitoring_param_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/ns_monitoring_param_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_monitoring_param_ref() directly.

    YANG Description: Reference to the NS level monitoring parameter
that is aggregated
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ns-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ns_monitoring_param_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__ns_monitoring_param_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ns_monitoring_param_ref(self):
    self.__ns_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  scale_in_threshold = __builtin__.property(_get_scale_in_threshold, _set_scale_in_threshold)
  scale_in_relational_operation = __builtin__.property(_get_scale_in_relational_operation, _set_scale_in_relational_operation)
  scale_out_threshold = __builtin__.property(_get_scale_out_threshold, _set_scale_out_threshold)
  scale_out_relational_operation = __builtin__.property(_get_scale_out_relational_operation, _set_scale_out_relational_operation)
  ns_monitoring_param_ref = __builtin__.property(_get_ns_monitoring_param_ref, _set_ns_monitoring_param_ref)


  _pyangbind_elements = OrderedDict([('name', name), ('scale_in_threshold', scale_in_threshold), ('scale_in_relational_operation', scale_in_relational_operation), ('scale_out_threshold', scale_out_threshold), ('scale_out_relational_operation', scale_out_relational_operation), ('ns_monitoring_param_ref', ns_monitoring_param_ref), ])


class yc_scaling_policy_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/scaling-group-descriptor/scaling-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__scaling_type','__enabled','__scale_in_operation_type','__scale_out_operation_type','__threshold_time','__cooldown_time','__scaling_criteria',)

  _yang_name = 'scaling-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__scale_out_operation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-criteria-operation', is_config=True)
    self.__scale_in_operation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-criteria-operation', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    self.__cooldown_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    self.__scaling_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'automatic': {u'value': 2}, u'manual': {u'value': 1}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-policy-type', is_config=True)
    self.__threshold_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    self.__scaling_criteria = YANGDynClass(base=YANGListType("name",yc_scaling_criteria_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'scaling-group-descriptor', u'scaling-policy']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/name (string)

    YANG Description: Name of the scaling policy
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the scaling policy
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_scaling_type(self):
    """
    Getter method for scaling_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_type (manotypes:scaling-policy-type)

    YANG Description: Type of scaling
    """
    return self.__scaling_type
      
  def _set_scaling_type(self, v, load=False):
    """
    Setter method for scaling_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_type (manotypes:scaling-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_type() directly.

    YANG Description: Type of scaling
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'automatic': {u'value': 2}, u'manual': {u'value': 1}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scaling_type must be of a type compatible with manotypes:scaling-policy-type""",
          'defined-type': "manotypes:scaling-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'automatic': {u'value': 2}, u'manual': {u'value': 1}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-policy-type', is_config=True)""",
        })

    self.__scaling_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scaling_type(self):
    self.__scaling_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'automatic': {u'value': 2}, u'manual': {u'value': 1}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-policy-type', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/enabled (boolean)

    YANG Description: Specifies if the scaling policy can be applied
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Specifies if the scaling policy can be applied
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)


  def _get_scale_in_operation_type(self):
    """
    Getter method for scale_in_operation_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scale_in_operation_type (manotypes:scaling-criteria-operation)

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale in threshold condition has been met.
Defaults to AND
    """
    return self.__scale_in_operation_type
      
  def _set_scale_in_operation_type(self, v, load=False):
    """
    Setter method for scale_in_operation_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scale_in_operation_type (manotypes:scaling-criteria-operation)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_operation_type() directly.

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale in threshold condition has been met.
Defaults to AND
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-criteria-operation', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_in_operation_type must be of a type compatible with manotypes:scaling-criteria-operation""",
          'defined-type': "manotypes:scaling-criteria-operation",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-criteria-operation', is_config=True)""",
        })

    self.__scale_in_operation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_in_operation_type(self):
    self.__scale_in_operation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-criteria-operation', is_config=True)


  def _get_scale_out_operation_type(self):
    """
    Getter method for scale_out_operation_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scale_out_operation_type (manotypes:scaling-criteria-operation)

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale out threshold condition has been met.
Defauls to OR
    """
    return self.__scale_out_operation_type
      
  def _set_scale_out_operation_type(self, v, load=False):
    """
    Setter method for scale_out_operation_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scale_out_operation_type (manotypes:scaling-criteria-operation)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_operation_type() directly.

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale out threshold condition has been met.
Defauls to OR
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-criteria-operation', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_out_operation_type must be of a type compatible with manotypes:scaling-criteria-operation""",
          'defined-type': "manotypes:scaling-criteria-operation",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-criteria-operation', is_config=True)""",
        })

    self.__scale_out_operation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_out_operation_type(self):
    self.__scale_out_operation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-criteria-operation', is_config=True)


  def _get_threshold_time(self):
    """
    Getter method for threshold_time, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/threshold_time (uint32)

    YANG Description: The duration for which the criteria must hold true
    """
    return self.__threshold_time
      
  def _set_threshold_time(self, v, load=False):
    """
    Setter method for threshold_time, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/threshold_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_time() directly.

    YANG Description: The duration for which the criteria must hold true
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""",
        })

    self.__threshold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_time(self):
    self.__threshold_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)


  def _get_cooldown_time(self):
    """
    Getter method for cooldown_time, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/cooldown_time (uint32)

    YANG Description: The duration after a scaling-in/scaling-out action has been
triggered, for which there will be no further optional
    """
    return self.__cooldown_time
      
  def _set_cooldown_time(self, v, load=False):
    """
    Setter method for cooldown_time, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/cooldown_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cooldown_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cooldown_time() directly.

    YANG Description: The duration after a scaling-in/scaling-out action has been
triggered, for which there will be no further optional
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cooldown_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""",
        })

    self.__cooldown_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cooldown_time(self):
    self.__cooldown_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)


  def _get_scaling_criteria(self):
    """
    Getter method for scaling_criteria, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria (list)

    YANG Description: list of conditions to be met for generating scaling
  requests
    """
    return self.__scaling_criteria
      
  def _set_scaling_criteria(self, v, load=False):
    """
    Setter method for scaling_criteria, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_criteria is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_criteria() directly.

    YANG Description: list of conditions to be met for generating scaling
  requests
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_scaling_criteria_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scaling_criteria must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_criteria_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__scaling_criteria = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scaling_criteria(self):
    self.__scaling_criteria = YANGDynClass(base=YANGListType("name",yc_scaling_criteria_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  scaling_type = __builtin__.property(_get_scaling_type, _set_scaling_type)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  scale_in_operation_type = __builtin__.property(_get_scale_in_operation_type, _set_scale_in_operation_type)
  scale_out_operation_type = __builtin__.property(_get_scale_out_operation_type, _set_scale_out_operation_type)
  threshold_time = __builtin__.property(_get_threshold_time, _set_threshold_time)
  cooldown_time = __builtin__.property(_get_cooldown_time, _set_cooldown_time)
  scaling_criteria = __builtin__.property(_get_scaling_criteria, _set_scaling_criteria)


  _pyangbind_elements = OrderedDict([('name', name), ('scaling_type', scaling_type), ('enabled', enabled), ('scale_in_operation_type', scale_in_operation_type), ('scale_out_operation_type', scale_out_operation_type), ('threshold_time', threshold_time), ('cooldown_time', cooldown_time), ('scaling_criteria', scaling_criteria), ])


class yc_vnfd_member_nsd__nsd_catalog_nsd_scaling_group_descriptor_vnfd_member(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/scaling-group-descriptor/vnfd-member. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNFs in this scaling group
  """
  __slots__ = ('_path_helper', '_extmethods', '__member_vnf_index_ref','__count',)

  _yang_name = 'vnfd-member'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'scaling-group-descriptor', u'vnfd-member']

  def _get_member_vnf_index_ref(self):
    """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member/member_vnf_index_ref (leafref)

    YANG Description: member VNF index of this member VNF
    """
    return self.__member_vnf_index_ref
      
  def _set_member_vnf_index_ref(self, v, load=False):
    """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: member VNF index of this member VNF
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnf_index_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__member_vnf_index_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnf_index_ref(self):
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member/count (uint32)

    YANG Description: count of this member VNF  within this scaling group.
The count allows to define  the number of instances
when a scaling action targets this scaling group
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member/count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: count of this member VNF  within this scaling group.
The count allows to define  the number of instances
when a scaling action targets this scaling group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)

  member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref, _set_member_vnf_index_ref)
  count = __builtin__.property(_get_count, _set_count)


  _pyangbind_elements = OrderedDict([('member_vnf_index_ref', member_vnf_index_ref), ('count', count), ])


class yc_scaling_config_action_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_config_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/scaling-group-descriptor/scaling-config-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of scaling config actions
  """
  __slots__ = ('_path_helper', '_extmethods', '__trigger','__ns_config_primitive_name_ref',)

  _yang_name = 'scaling-config-action'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__trigger = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'pre-scale-out': {u'value': 3}, u'pre-scale-in': {u'value': 1}, u'post-scale-in': {u'value': 2}, u'post-scale-out': {u'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-trigger', is_config=True)
    self.__ns_config_primitive_name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-config-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'scaling-group-descriptor', u'scaling-config-action']

  def _get_trigger(self):
    """
    Getter method for trigger, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action/trigger (manotypes:scaling-trigger)

    YANG Description: scaling trigger
    """
    return self.__trigger
      
  def _set_trigger(self, v, load=False):
    """
    Setter method for trigger, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action/trigger (manotypes:scaling-trigger)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trigger is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trigger() directly.

    YANG Description: scaling trigger
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'pre-scale-out': {u'value': 3}, u'pre-scale-in': {u'value': 1}, u'post-scale-in': {u'value': 2}, u'post-scale-out': {u'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-trigger', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trigger must be of a type compatible with manotypes:scaling-trigger""",
          'defined-type': "manotypes:scaling-trigger",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'pre-scale-out': {u'value': 3}, u'pre-scale-in': {u'value': 1}, u'post-scale-in': {u'value': 2}, u'post-scale-out': {u'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-trigger', is_config=True)""",
        })

    self.__trigger = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trigger(self):
    self.__trigger = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'pre-scale-out': {u'value': 3}, u'pre-scale-in': {u'value': 1}, u'post-scale-in': {u'value': 2}, u'post-scale-out': {u'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:scaling-trigger', is_config=True)


  def _get_ns_config_primitive_name_ref(self):
    """
    Getter method for ns_config_primitive_name_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action/ns_config_primitive_name_ref (leafref)

    YANG Description: Reference to the NS primitive
    """
    return self.__ns_config_primitive_name_ref
      
  def _set_ns_config_primitive_name_ref(self, v, load=False):
    """
    Setter method for ns_config_primitive_name_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action/ns_config_primitive_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_config_primitive_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_config_primitive_name_ref() directly.

    YANG Description: Reference to the NS primitive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ns-config-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ns_config_primitive_name_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-config-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__ns_config_primitive_name_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ns_config_primitive_name_ref(self):
    self.__ns_config_primitive_name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-config-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

  trigger = __builtin__.property(_get_trigger, _set_trigger)
  ns_config_primitive_name_ref = __builtin__.property(_get_ns_config_primitive_name_ref, _set_ns_config_primitive_name_ref)


  _pyangbind_elements = OrderedDict([('trigger', trigger), ('ns_config_primitive_name_ref', ns_config_primitive_name_ref), ])


class yc_scaling_group_descriptor_nsd__nsd_catalog_nsd_scaling_group_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/scaling-group-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: scaling group descriptor within this network service.
The scaling group defines a group of VNFs,
and the ratio of VNFs in the network service
that is used as target for scaling action
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__scaling_policy','__vnfd_member','__min_instance_count','__max_instance_count','__scaling_config_action',)

  _yang_name = 'scaling-group-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__max_instance_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="max-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    self.__min_instance_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="min-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    self.__scaling_policy = YANGDynClass(base=YANGListType("name",yc_scaling_policy_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__scaling_config_action = YANGDynClass(base=YANGListType("trigger",yc_scaling_config_action_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__vnfd_member = YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_vnfd_member_nsd__nsd_catalog_nsd_scaling_group_descriptor_vnfd_member, yang_name="vnfd-member", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnfd-member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'scaling-group-descriptor']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/name (string)

    YANG Description: Name of this scaling group.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of this scaling group.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_scaling_policy(self):
    """
    Getter method for scaling_policy, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy (list)
    """
    return self.__scaling_policy
      
  def _set_scaling_policy(self, v, load=False):
    """
    Setter method for scaling_policy, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_policy() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_scaling_policy_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scaling_policy must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_policy_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__scaling_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scaling_policy(self):
    self.__scaling_policy = YANGDynClass(base=YANGListType("name",yc_scaling_policy_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_vnfd_member(self):
    """
    Getter method for vnfd_member, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member (list)

    YANG Description: List of VNFs in this scaling group
    """
    return self.__vnfd_member
      
  def _set_vnfd_member(self, v, load=False):
    """
    Setter method for vnfd_member, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_member is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_member() directly.

    YANG Description: List of VNFs in this scaling group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("member_vnf_index_ref",yc_vnfd_member_nsd__nsd_catalog_nsd_scaling_group_descriptor_vnfd_member, yang_name="vnfd-member", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnfd-member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_member must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_vnfd_member_nsd__nsd_catalog_nsd_scaling_group_descriptor_vnfd_member, yang_name="vnfd-member", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnfd-member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__vnfd_member = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_member(self):
    self.__vnfd_member = YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_vnfd_member_nsd__nsd_catalog_nsd_scaling_group_descriptor_vnfd_member, yang_name="vnfd-member", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnfd-member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_min_instance_count(self):
    """
    Getter method for min_instance_count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/min_instance_count (uint32)

    YANG Description: Minimum instances of the scaling group which are allowed.
These instances are created by default when the network service
is instantiated.
    """
    return self.__min_instance_count
      
  def _set_min_instance_count(self, v, load=False):
    """
    Setter method for min_instance_count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/min_instance_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_instance_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_instance_count() directly.

    YANG Description: Minimum instances of the scaling group which are allowed.
These instances are created by default when the network service
is instantiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="min-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_instance_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="min-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""",
        })

    self.__min_instance_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_instance_count(self):
    self.__min_instance_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="min-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)


  def _get_max_instance_count(self):
    """
    Getter method for max_instance_count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/max_instance_count (uint32)

    YANG Description: Maximum instances of this scaling group that are allowed
in a single network service. The network service scaling
will fail, when the number of service group instances
exceed the max-instance-count specified.
    """
    return self.__max_instance_count
      
  def _set_max_instance_count(self, v, load=False):
    """
    Setter method for max_instance_count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/max_instance_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_instance_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_instance_count() directly.

    YANG Description: Maximum instances of this scaling group that are allowed
in a single network service. The network service scaling
will fail, when the number of service group instances
exceed the max-instance-count specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="max-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_instance_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="max-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""",
        })

    self.__max_instance_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_instance_count(self):
    self.__max_instance_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="max-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)


  def _get_scaling_config_action(self):
    """
    Getter method for scaling_config_action, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action (list)

    YANG Description: List of scaling config actions
    """
    return self.__scaling_config_action
      
  def _set_scaling_config_action(self, v, load=False):
    """
    Setter method for scaling_config_action, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_config_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_config_action() directly.

    YANG Description: List of scaling config actions
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("trigger",yc_scaling_config_action_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scaling_config_action must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("trigger",yc_scaling_config_action_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__scaling_config_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scaling_config_action(self):
    self.__scaling_config_action = YANGDynClass(base=YANGListType("trigger",yc_scaling_config_action_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  scaling_policy = __builtin__.property(_get_scaling_policy, _set_scaling_policy)
  vnfd_member = __builtin__.property(_get_vnfd_member, _set_vnfd_member)
  min_instance_count = __builtin__.property(_get_min_instance_count, _set_min_instance_count)
  max_instance_count = __builtin__.property(_get_max_instance_count, _set_max_instance_count)
  scaling_config_action = __builtin__.property(_get_scaling_config_action, _set_scaling_config_action)


  _pyangbind_elements = OrderedDict([('name', name), ('scaling_policy', scaling_policy), ('vnfd_member', vnfd_member), ('min_instance_count', min_instance_count), ('max_instance_count', max_instance_count), ('scaling_config_action', scaling_config_action), ])


class yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vnffgd_rsp_vnfd_connection_point_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnffgd/rsp/vnfd-connection-point-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of references to connection points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__member_vnf_index_ref','__order','__vnfd_id_ref','__vnfd_ingress_connection_point_ref','__vnfd_egress_connection_point_ref',)

  _yang_name = 'vnfd-connection-point-ref'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnfd_ingress_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-ingress-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__order = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)
    self.__vnfd_egress_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-egress-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'vnffgd', u'rsp', u'vnfd-connection-point-ref']

  def _get_member_vnf_index_ref(self):
    """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/member_vnf_index_ref (leafref)

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
    return self.__member_vnf_index_ref
      
  def _set_member_vnf_index_ref(self, v, load=False):
    """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnf_index_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__member_vnf_index_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnf_index_ref(self):
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_order(self):
    """
    Getter method for order, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/order (uint8)

    YANG Description: A number that denotes the order of a VNF in a chain
    """
    return self.__order
      
  def _set_order(self, v, load=False):
    """
    Setter method for order, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/order (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_order is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_order() directly.

    YANG Description: A number that denotes the order of a VNF in a chain
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """order must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)""",
        })

    self.__order = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_order(self):
    self.__order = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)


  def _get_vnfd_id_ref(self):
    """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_id_ref (leafref)

    YANG Description: A reference to a vnfd. This is a
   leafref to path:
       ../../../../nsd:constituent-vnfd
       + [nsd:id = current()/../nsd:id-ref]
       + /nsd:vnfd-id-ref
    """
    return self.__vnfd_id_ref
      
  def _set_vnfd_id_ref(self, v, load=False):
    """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a vnfd. This is a
   leafref to path:
       ../../../../nsd:constituent-vnfd
       + [nsd:id = current()/../nsd:id-ref]
       + /nsd:vnfd-id-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_id_ref(self):
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnfd_ingress_connection_point_ref(self):
    """
    Getter method for vnfd_ingress_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_ingress_connection_point_ref (string)

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
    return self.__vnfd_ingress_connection_point_ref
      
  def _set_vnfd_ingress_connection_point_ref(self, v, load=False):
    """
    Setter method for vnfd_ingress_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_ingress_connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_ingress_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_ingress_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-ingress-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_ingress_connection_point_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-ingress-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__vnfd_ingress_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_ingress_connection_point_ref(self):
    self.__vnfd_ingress_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-ingress-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_vnfd_egress_connection_point_ref(self):
    """
    Getter method for vnfd_egress_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_egress_connection_point_ref (string)

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
    return self.__vnfd_egress_connection_point_ref
      
  def _set_vnfd_egress_connection_point_ref(self, v, load=False):
    """
    Setter method for vnfd_egress_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_egress_connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_egress_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_egress_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-egress-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_egress_connection_point_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-egress-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__vnfd_egress_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_egress_connection_point_ref(self):
    self.__vnfd_egress_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-egress-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref, _set_member_vnf_index_ref)
  order = __builtin__.property(_get_order, _set_order)
  vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref, _set_vnfd_id_ref)
  vnfd_ingress_connection_point_ref = __builtin__.property(_get_vnfd_ingress_connection_point_ref, _set_vnfd_ingress_connection_point_ref)
  vnfd_egress_connection_point_ref = __builtin__.property(_get_vnfd_egress_connection_point_ref, _set_vnfd_egress_connection_point_ref)


  _pyangbind_elements = OrderedDict([('member_vnf_index_ref', member_vnf_index_ref), ('order', order), ('vnfd_id_ref', vnfd_id_ref), ('vnfd_ingress_connection_point_ref', vnfd_ingress_connection_point_ref), ('vnfd_egress_connection_point_ref', vnfd_egress_connection_point_ref), ])


class yc_rsp_nsd__nsd_catalog_nsd_vnffgd_rsp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnffgd/rsp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Rendered Service Paths (RSP).
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__vnfd_connection_point_ref',)

  _yang_name = 'rsp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnfd_connection_point_ref = YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vnffgd_rsp_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'vnffgd', u'rsp']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/id (string)

    YANG Description: Identifier for the RSP.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the RSP.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/name (string)

    YANG Description: RSP name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: RSP name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_vnfd_connection_point_ref(self):
    """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref (list)

    YANG Description: A list of references to connection points.
    """
    return self.__vnfd_connection_point_ref
      
  def _set_vnfd_connection_point_ref(self, v, load=False):
    """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.

    YANG Description: A list of references to connection points.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("member_vnf_index_ref",yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vnffgd_rsp_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_connection_point_ref must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vnffgd_rsp_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__vnfd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_connection_point_ref(self):
    self.__vnfd_connection_point_ref = YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vnffgd_rsp_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref, _set_vnfd_connection_point_ref)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('vnfd_connection_point_ref', vnfd_connection_point_ref), ])


class yc_match_attributes_nsd__nsd_catalog_nsd_vnffgd_classifier_match_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnffgd/classifier/match-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of match attributes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__ip_proto','__source_ip_address','__destination_ip_address','__source_port','__destination_port',)

  _yang_name = 'match-attributes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    self.__destination_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    self.__source_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:port-number', is_config=True)
    self.__ip_proto = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-proto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)
    self.__destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:port-number', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'vnffgd', u'classifier', u'match-attributes']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/id (string)

    YANG Description: Identifier for the classifier match attribute rule.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the classifier match attribute rule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_ip_proto(self):
    """
    Getter method for ip_proto, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/ip_proto (uint8)

    YANG Description: IP Protocol.
    """
    return self.__ip_proto
      
  def _set_ip_proto(self, v, load=False):
    """
    Setter method for ip_proto, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/ip_proto (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_proto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_proto() directly.

    YANG Description: IP Protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-proto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_proto must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-proto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)""",
        })

    self.__ip_proto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_proto(self):
    self.__ip_proto = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-proto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)


  def _get_source_ip_address(self):
    """
    Getter method for source_ip_address, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/source_ip_address (inet:ip-address)

    YANG Description: Source IP address.
    """
    return self.__source_ip_address
      
  def _set_source_ip_address(self, v, load=False):
    """
    Setter method for source_ip_address, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/source_ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ip_address() directly.

    YANG Description: Source IP address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__source_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ip_address(self):
    self.__source_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)


  def _get_destination_ip_address(self):
    """
    Getter method for destination_ip_address, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/destination_ip_address (inet:ip-address)

    YANG Description: Destination IP address.
    """
    return self.__destination_ip_address
      
  def _set_destination_ip_address(self, v, load=False):
    """
    Setter method for destination_ip_address, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/destination_ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ip_address() directly.

    YANG Description: Destination IP address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__destination_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_ip_address(self):
    self.__destination_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)


  def _get_source_port(self):
    """
    Getter method for source_port, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/source_port (inet:port-number)

    YANG Description: Source port number.
    """
    return self.__source_port
      
  def _set_source_port(self, v, load=False):
    """
    Setter method for source_port, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/source_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_port() directly.

    YANG Description: Source port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:port-number', is_config=True)""",
        })

    self.__source_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_port(self):
    self.__source_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:port-number', is_config=True)


  def _get_destination_port(self):
    """
    Getter method for destination_port, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/destination_port (inet:port-number)

    YANG Description: Destination port number.
    """
    return self.__destination_port
      
  def _set_destination_port(self, v, load=False):
    """
    Setter method for destination_port, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/destination_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_port() directly.

    YANG Description: Destination port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:port-number', is_config=True)""",
        })

    self.__destination_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_port(self):
    self.__destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:port-number', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  ip_proto = __builtin__.property(_get_ip_proto, _set_ip_proto)
  source_ip_address = __builtin__.property(_get_source_ip_address, _set_source_ip_address)
  destination_ip_address = __builtin__.property(_get_destination_ip_address, _set_destination_ip_address)
  source_port = __builtin__.property(_get_source_port, _set_source_port)
  destination_port = __builtin__.property(_get_destination_port, _set_destination_port)


  _pyangbind_elements = OrderedDict([('id', id), ('ip_proto', ip_proto), ('source_ip_address', source_ip_address), ('destination_ip_address', destination_ip_address), ('source_port', source_port), ('destination_port', destination_port), ])


class yc_classifier_nsd__nsd_catalog_nsd_vnffgd_classifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnffgd/classifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of classifier rules.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__rsp_id_ref','__match_attributes','__member_vnf_index_ref','__vnfd_id_ref','__vnfd_connection_point_ref',)

  _yang_name = 'classifier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnfd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__rsp_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rsp-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__match_attributes = YANGDynClass(base=YANGListType("id",yc_match_attributes_nsd__nsd_catalog_nsd_vnffgd_classifier_match_attributes, yang_name="match-attributes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="match-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'vnffgd', u'classifier']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/id (string)

    YANG Description: Identifier for the classifier rule.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the classifier rule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/name (string)

    YANG Description: Name of the classifier.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the classifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_rsp_id_ref(self):
    """
    Getter method for rsp_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/rsp_id_ref (leafref)

    YANG Description: A reference to the RSP.
    """
    return self.__rsp_id_ref
      
  def _set_rsp_id_ref(self, v, load=False):
    """
    Setter method for rsp_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/rsp_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rsp_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rsp_id_ref() directly.

    YANG Description: A reference to the RSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="rsp-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rsp_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rsp-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__rsp_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rsp_id_ref(self):
    self.__rsp_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rsp-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_match_attributes(self):
    """
    Getter method for match_attributes, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes (list)

    YANG Description: List of match attributes.
    """
    return self.__match_attributes
      
  def _set_match_attributes(self, v, load=False):
    """
    Setter method for match_attributes, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_match_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_match_attributes() directly.

    YANG Description: List of match attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_match_attributes_nsd__nsd_catalog_nsd_vnffgd_classifier_match_attributes, yang_name="match-attributes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="match-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """match_attributes must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_match_attributes_nsd__nsd_catalog_nsd_vnffgd_classifier_match_attributes, yang_name="match-attributes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="match-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__match_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_match_attributes(self):
    self.__match_attributes = YANGDynClass(base=YANGListType("id",yc_match_attributes_nsd__nsd_catalog_nsd_vnffgd_classifier_match_attributes, yang_name="match-attributes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="match-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_member_vnf_index_ref(self):
    """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/member_vnf_index_ref (leafref)

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
    return self.__member_vnf_index_ref
      
  def _set_member_vnf_index_ref(self, v, load=False):
    """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnf_index_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__member_vnf_index_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnf_index_ref(self):
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnfd_id_ref(self):
    """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/vnfd_id_ref (leafref)

    YANG Description: A reference to a vnfd. This is a
   leafref to path:
       ../../../nsd:constituent-vnfd
       + [nsd:id = current()/../nsd:id-ref]
       + /nsd:vnfd-id-ref
    """
    return self.__vnfd_id_ref
      
  def _set_vnfd_id_ref(self, v, load=False):
    """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a vnfd. This is a
   leafref to path:
       ../../../nsd:constituent-vnfd
       + [nsd:id = current()/../nsd:id-ref]
       + /nsd:vnfd-id-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_id_ref(self):
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnfd_connection_point_ref(self):
    """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/vnfd_connection_point_ref (string)

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
    return self.__vnfd_connection_point_ref
      
  def _set_vnfd_connection_point_ref(self, v, load=False):
    """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/vnfd_connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_connection_point_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__vnfd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_connection_point_ref(self):
    self.__vnfd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  rsp_id_ref = __builtin__.property(_get_rsp_id_ref, _set_rsp_id_ref)
  match_attributes = __builtin__.property(_get_match_attributes, _set_match_attributes)
  member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref, _set_member_vnf_index_ref)
  vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref, _set_vnfd_id_ref)
  vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref, _set_vnfd_connection_point_ref)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('rsp_id_ref', rsp_id_ref), ('match_attributes', match_attributes), ('member_vnf_index_ref', member_vnf_index_ref), ('vnfd_id_ref', vnfd_id_ref), ('vnfd_connection_point_ref', vnfd_connection_point_ref), ])


class yc_vnffgd_nsd__nsd_catalog_nsd_vnffgd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnffgd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNF Forwarding Graph Descriptors (VNFFGD).
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__short_name','__vendor','__description','__version','__rsp','__classifier',)

  _yang_name = 'vnffgd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__classifier = YANGDynClass(base=YANGListType("id",yc_classifier_nsd__nsd_catalog_nsd_vnffgd_classifier, yang_name="classifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="classifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__rsp = YANGDynClass(base=YANGListType("id",yc_rsp_nsd__nsd_catalog_nsd_vnffgd_rsp, yang_name="rsp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'vnffgd']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/id (string)

    YANG Description: Identifier for the FGD.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the FGD.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/name (string)

    YANG Description: FGD name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: FGD name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_vendor(self):
    """
    Getter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vnffgd/vendor (string)

    YANG Description: Provider of the FGD.
    """
    return self.__vendor
      
  def _set_vendor(self, v, load=False):
    """
    Setter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vnffgd/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Provider of the FGD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor(self):
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /nsd_catalog/nsd/vnffgd/description (string)

    YANG Description: Description of the FGD.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /nsd_catalog/nsd/vnffgd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the FGD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /nsd_catalog/nsd/vnffgd/version (string)

    YANG Description: Version of the FGD
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /nsd_catalog/nsd/vnffgd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the FGD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_rsp(self):
    """
    Getter method for rsp, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp (list)

    YANG Description: List of Rendered Service Paths (RSP).
    """
    return self.__rsp
      
  def _set_rsp(self, v, load=False):
    """
    Setter method for rsp, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rsp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rsp() directly.

    YANG Description: List of Rendered Service Paths (RSP).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_rsp_nsd__nsd_catalog_nsd_vnffgd_rsp, yang_name="rsp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rsp must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_rsp_nsd__nsd_catalog_nsd_vnffgd_rsp, yang_name="rsp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__rsp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rsp(self):
    self.__rsp = YANGDynClass(base=YANGListType("id",yc_rsp_nsd__nsd_catalog_nsd_vnffgd_rsp, yang_name="rsp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_classifier(self):
    """
    Getter method for classifier, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier (list)

    YANG Description: List of classifier rules.
    """
    return self.__classifier
      
  def _set_classifier(self, v, load=False):
    """
    Setter method for classifier, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_classifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_classifier() directly.

    YANG Description: List of classifier rules.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_classifier_nsd__nsd_catalog_nsd_vnffgd_classifier, yang_name="classifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="classifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """classifier must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_classifier_nsd__nsd_catalog_nsd_vnffgd_classifier, yang_name="classifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="classifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__classifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_classifier(self):
    self.__classifier = YANGDynClass(base=YANGListType("id",yc_classifier_nsd__nsd_catalog_nsd_vnffgd_classifier, yang_name="classifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="classifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  vendor = __builtin__.property(_get_vendor, _set_vendor)
  description = __builtin__.property(_get_description, _set_description)
  version = __builtin__.property(_get_version, _set_version)
  rsp = __builtin__.property(_get_rsp, _set_rsp)
  classifier = __builtin__.property(_get_classifier, _set_classifier)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('short_name', short_name), ('vendor', vendor), ('description', description), ('version', version), ('rsp', rsp), ('classifier', classifier), ])


class yc_dns_server_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dns_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ip-profiles/ip-profile-params/dns-server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'dns-server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ip-profiles', u'ip-profile-params', u'dns-server']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dns_server/address (inet:ip-address)

    YANG Description: List of DNS Servers associated with IP Profile
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dns_server/address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: List of DNS Servers associated with IP Profile
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_dhcp_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dhcp_params(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ip-profiles/ip-profile-params/dhcp-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__start_address','__count',)

  _yang_name = 'dhcp-params'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ip-profiles', u'ip-profile-params', u'dhcp-params']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/enabled (boolean)

    YANG Description: This flag indicates if DHCP is enabled or not
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This flag indicates if DHCP is enabled or not
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)


  def _get_start_address(self):
    """
    Getter method for start_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/start_address (inet:ip-address)

    YANG Description: Start IP address of the IP-Address range associated with DHCP domain
    """
    return self.__start_address
      
  def _set_start_address(self, v, load=False):
    """
    Setter method for start_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/start_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_address() directly.

    YANG Description: Start IP address of the IP-Address range associated with DHCP domain
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__start_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_address(self):
    self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/count (uint32)

    YANG Description: Size of the DHCP pool associated with DHCP domain
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Size of the DHCP pool associated with DHCP domain
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  start_address = __builtin__.property(_get_start_address, _set_start_address)
  count = __builtin__.property(_get_count, _set_count)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('start_address', start_address), ('count', count), ])


class yc_ip_profile_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ip-profiles/ip-profile-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_version','__subnet_address','__gateway_address','__security_group','__dns_server','__dhcp_params','__subnet_prefix_pool',)

  _yang_name = 'ip-profile-params'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dhcp_params = YANGDynClass(base=yc_dhcp_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    self.__dns_server = YANGDynClass(base=YANGListType("address",yc_dns_server_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-prefix', is_config=True)
    self.__subnet_prefix_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet-prefix-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__security_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-version', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ip-profiles', u'ip-profile-params']

  def _get_ip_version(self):
    """
    Getter method for ip_version, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/ip_version (inet:ip-version)
    """
    return self.__ip_version
      
  def _set_ip_version(self, v, load=False):
    """
    Setter method for ip_version, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/ip_version (inet:ip-version)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-version', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_version must be of a type compatible with inet:ip-version""",
          'defined-type': "inet:ip-version",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-version', is_config=True)""",
        })

    self.__ip_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_version(self):
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-version', is_config=True)


  def _get_subnet_address(self):
    """
    Getter method for subnet_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/subnet_address (inet:ip-prefix)

    YANG Description: Subnet IP prefix associated with IP Profile
    """
    return self.__subnet_address
      
  def _set_subnet_address(self, v, load=False):
    """
    Setter method for subnet_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/subnet_address (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_address() directly.

    YANG Description: Subnet IP prefix associated with IP Profile
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnet_address must be of a type compatible with inet:ip-prefix""",
          'defined-type': "inet:ip-prefix",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-prefix', is_config=True)""",
        })

    self.__subnet_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnet_address(self):
    self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-prefix', is_config=True)


  def _get_gateway_address(self):
    """
    Getter method for gateway_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/gateway_address (inet:ip-address)

    YANG Description: IP Address of the default gateway associated with IP Profile
    """
    return self.__gateway_address
      
  def _set_gateway_address(self, v, load=False):
    """
    Setter method for gateway_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/gateway_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway_address() directly.

    YANG Description: IP Address of the default gateway associated with IP Profile
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__gateway_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway_address(self):
    self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)


  def _get_security_group(self):
    """
    Getter method for security_group, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/security_group (string)

    YANG Description: Name of the security group
    """
    return self.__security_group
      
  def _set_security_group(self, v, load=False):
    """
    Setter method for security_group, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/security_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group() directly.

    YANG Description: Name of the security group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security_group must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__security_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security_group(self):
    self.__security_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_dns_server(self):
    """
    Getter method for dns_server, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dns_server (list)
    """
    return self.__dns_server
      
  def _set_dns_server(self, v, load=False):
    """
    Setter method for dns_server, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dns_server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_server() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address",yc_dns_server_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_server must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address",yc_dns_server_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__dns_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_server(self):
    self.__dns_server = YANGDynClass(base=YANGListType("address",yc_dns_server_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_dhcp_params(self):
    """
    Getter method for dhcp_params, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params (container)
    """
    return self.__dhcp_params
      
  def _set_dhcp_params(self, v, load=False):
    """
    Setter method for dhcp_params, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_params() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dhcp_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_params must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dhcp_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__dhcp_params = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_params(self):
    self.__dhcp_params = YANGDynClass(base=yc_dhcp_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)


  def _get_subnet_prefix_pool(self):
    """
    Getter method for subnet_prefix_pool, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/subnet_prefix_pool (string)

    YANG Description: VIM Specific reference to pre-created subnet prefix
    """
    return self.__subnet_prefix_pool
      
  def _set_subnet_prefix_pool(self, v, load=False):
    """
    Setter method for subnet_prefix_pool, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/subnet_prefix_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_prefix_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_prefix_pool() directly.

    YANG Description: VIM Specific reference to pre-created subnet prefix
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subnet-prefix-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnet_prefix_pool must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet-prefix-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__subnet_prefix_pool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnet_prefix_pool(self):
    self.__subnet_prefix_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet-prefix-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  ip_version = __builtin__.property(_get_ip_version, _set_ip_version)
  subnet_address = __builtin__.property(_get_subnet_address, _set_subnet_address)
  gateway_address = __builtin__.property(_get_gateway_address, _set_gateway_address)
  security_group = __builtin__.property(_get_security_group, _set_security_group)
  dns_server = __builtin__.property(_get_dns_server, _set_dns_server)
  dhcp_params = __builtin__.property(_get_dhcp_params, _set_dhcp_params)
  subnet_prefix_pool = __builtin__.property(_get_subnet_prefix_pool, _set_subnet_prefix_pool)


  _pyangbind_elements = OrderedDict([('ip_version', ip_version), ('subnet_address', subnet_address), ('gateway_address', gateway_address), ('security_group', security_group), ('dns_server', dns_server), ('dhcp_params', dhcp_params), ('subnet_prefix_pool', subnet_prefix_pool), ])


class yc_ip_profiles_nsd__nsd_catalog_nsd_ip_profiles(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ip-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__ip_profile_params',)

  _yang_name = 'ip-profiles'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_profile_params = YANGDynClass(base=yc_ip_profile_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params, is_container='container', yang_name="ip-profile-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ip-profiles']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/name (string)

    YANG Description: Name of the IP-Profile
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the IP-Profile
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/description (string)

    YANG Description: Description for IP profile
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description for IP profile
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_ip_profile_params(self):
    """
    Getter method for ip_profile_params, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params (container)
    """
    return self.__ip_profile_params
      
  def _set_ip_profile_params(self, v, load=False):
    """
    Setter method for ip_profile_params, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profile_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profile_params() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ip_profile_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params, is_container='container', yang_name="ip-profile-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_profile_params must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ip_profile_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params, is_container='container', yang_name="ip-profile-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__ip_profile_params = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_profile_params(self):
    self.__ip_profile_params = YANGDynClass(base=yc_ip_profile_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params, is_container='container', yang_name="ip-profile-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  ip_profile_params = __builtin__.property(_get_ip_profile_params, _set_ip_profile_params)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('ip_profile_params', ip_profile_params), ])


class yc_script_nsd__nsd_catalog_nsd_ns_configuration_script(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__script_type',)

  _yang_name = 'script'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'script']

  def _get_script_type(self):
    """
    Getter method for script_type, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/script/script_type (enumeration)

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
    return self.__script_type
      
  def _set_script_type(self, v, load=False):
    """
    Setter method for script_type, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/script/script_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_type() directly.

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script_type must be of a type compatible with enumeration""",
          'defined-type': "nsd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)""",
        })

    self.__script_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script_type(self):
    self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)

  script_type = __builtin__.property(_get_script_type, _set_script_type)

  __choices__ = {u'config-method': {u'script': [u'script_type']}}
  _pyangbind_elements = OrderedDict([('script_type', script_type), ])


class yc_juju_nsd__nsd_catalog_nsd_ns_configuration_juju(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__charm','__proxy','__cloud',)

  _yang_name = 'juju'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'juju']

  def _get_charm(self):
    """
    Getter method for charm, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    return self.__charm
      
  def _set_charm(self, v, load=False):
    """
    Setter method for charm, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """charm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__charm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_charm(self):
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)


  def _get_cloud(self):
    """
    Getter method for cloud, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    return self.__cloud
      
  def _set_cloud(self, v, load=False):
    """
    Setter method for cloud, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud must be of a type compatible with enumeration""",
          'defined-type': "nsd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud(self):
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)

  charm = __builtin__.property(_get_charm, _set_charm)
  proxy = __builtin__.property(_get_proxy, _set_proxy)
  cloud = __builtin__.property(_get_cloud, _set_cloud)

  __choices__ = {u'config-method': {u'juju': [u'charm', u'proxy', u'cloud']}}
  _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_juju_nsd__nsd_catalog_nsd_ns_configuration_execution_environment_list_juju(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/execution-environment-list/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__charm','__proxy','__cloud',)

  _yang_name = 'juju'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'execution-environment-list', u'juju']

  def _get_charm(self):
    """
    Getter method for charm, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    return self.__charm
      
  def _set_charm(self, v, load=False):
    """
    Setter method for charm, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """charm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__charm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_charm(self):
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)


  def _get_cloud(self):
    """
    Getter method for cloud, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    return self.__cloud
      
  def _set_cloud(self, v, load=False):
    """
    Setter method for cloud, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud must be of a type compatible with enumeration""",
          'defined-type': "nsd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud(self):
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)

  charm = __builtin__.property(_get_charm, _set_charm)
  proxy = __builtin__.property(_get_proxy, _set_proxy)
  cloud = __builtin__.property(_get_cloud, _set_cloud)

  __choices__ = {u'execution-environment-model': {u'juju': [u'charm', u'proxy', u'cloud']}}
  _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_execution_environment_list_nsd__nsd_catalog_nsd_ns_configuration_execution_environment_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/execution-environment-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__juju','__helm_chart','__metric_service','__connection_point_ref',)

  _yang_name = 'execution-environment-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__juju = YANGDynClass(base=yc_juju_nsd__nsd_catalog_nsd_ns_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'execution-environment-list']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/id (string)

    YANG Description: Execution environment identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Execution environment identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_juju(self):
    """
    Getter method for juju, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/juju (container)
    """
    return self.__juju
      
  def _set_juju(self, v, load=False):
    """
    Setter method for juju, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_juju_nsd__nsd_catalog_nsd_ns_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_juju_nsd__nsd_catalog_nsd_ns_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__juju = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju(self):
    self.__juju = YANGDynClass(base=yc_juju_nsd__nsd_catalog_nsd_ns_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)


  def _get_helm_chart(self):
    """
    Getter method for helm_chart, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/helm_chart (string)

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
    return self.__helm_chart
      
  def _set_helm_chart(self, v, load=False):
    """
    Setter method for helm_chart, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/helm_chart (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_chart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_chart() directly.

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helm_chart must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__helm_chart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helm_chart(self):
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_metric_service(self):
    """
    Getter method for metric_service, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/metric_service (string)

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
    return self.__metric_service
      
  def _set_metric_service(self, v, load=False):
    """
    Setter method for metric_service, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/metric_service (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_service() directly.

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_service must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__metric_service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_service(self):
    self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_connection_point_ref(self):
    """
    Getter method for connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/connection_point_ref (string)

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
    return self.__connection_point_ref
      
  def _set_connection_point_ref(self, v, load=False):
    """
    Setter method for connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list/connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_point_ref() directly.

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_point_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_point_ref(self):
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  juju = __builtin__.property(_get_juju, _set_juju)
  helm_chart = __builtin__.property(_get_helm_chart, _set_helm_chart)
  metric_service = __builtin__.property(_get_metric_service, _set_metric_service)
  connection_point_ref = __builtin__.property(_get_connection_point_ref, _set_connection_point_ref)

  __choices__ = {u'config-method': {u'execution-environment-list': [u'id', u'metric_service', u'connection_point_ref']}, u'execution-environment-model': {u'juju': [u'juju'], u'helm-chart': [u'helm_chart']}}
  _pyangbind_elements = OrderedDict([('id', id), ('juju', juju), ('helm_chart', helm_chart), ('metric_service', metric_service), ('connection_point_ref', connection_point_ref), ])


class yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the config primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__mandatory','__default_value','__parameter_pool','__read_only','__hidden',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)
    self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_mandatory(self):
    """
    Getter method for mandatory, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
    return self.__mandatory
      
  def _set_mandatory(self, v, load=False):
    """
    Setter method for mandatory, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mandatory must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""",
        })

    self.__mandatory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mandatory(self):
    self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)


  def _get_default_value(self):
    """
    Getter method for default_value, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/default_value (string)

    YANG Description: The default value for this field
    """
    return self.__default_value
      
  def _set_default_value(self, v, load=False):
    """
    Setter method for default_value, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__default_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_value(self):
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_parameter_pool(self):
    """
    Getter method for parameter_pool, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
    return self.__parameter_pool
      
  def _set_parameter_pool(self, v, load=False):
    """
    Setter method for parameter_pool, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter_pool must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__parameter_pool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter_pool(self):
    self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_read_only(self):
    """
    Getter method for read_only, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
    return self.__read_only
      
  def _set_read_only(self, v, load=False):
    """
    Setter method for read_only, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """read_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""",
        })

    self.__read_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_read_only(self):
    self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)


  def _get_hidden(self):
    """
    Getter method for hidden, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
    return self.__hidden
      
  def _set_hidden(self, v, load=False):
    """
    Setter method for hidden, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hidden must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""",
        })

    self.__hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hidden(self):
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  mandatory = __builtin__.property(_get_mandatory, _set_mandatory)
  default_value = __builtin__.property(_get_default_value, _set_default_value)
  parameter_pool = __builtin__.property(_get_parameter_pool, _set_parameter_pool)
  read_only = __builtin__.property(_get_read_only, _set_read_only)
  hidden = __builtin__.property(_get_hidden, _set_hidden)


  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('mandatory', mandatory), ('default_value', default_value), ('parameter_pool', parameter_pool), ('read_only', read_only), ('hidden', hidden), ])


class yc_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__execution_environment_ref','__execution_environment_primitive','__parameter','__user_defined_script',)

  _yang_name = 'config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'config-primitive']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/name (string)

    YANG Description: Name of the config primitive.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the config primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_execution_environment_primitive(self):
    """
    Getter method for execution_environment_primitive, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/execution_environment_primitive (string)

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
    return self.__execution_environment_primitive
      
  def _set_execution_environment_primitive(self, v, load=False):
    """
    Setter method for execution_environment_primitive, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/execution_environment_primitive (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_primitive() directly.

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_primitive must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__execution_environment_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_primitive(self):
    self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter (list)

    YANG Description: List of parameters to the config primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the config primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/user_defined_script (string)

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  execution_environment_primitive = __builtin__.property(_get_execution_environment_primitive, _set_execution_environment_primitive)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)


  _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref), ('execution_environment_primitive', execution_environment_primitive), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_initial_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/initial-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__value',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'initial-config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  value = __builtin__.property(_get_value, _set_value)

  __choices__ = {u'primitive-type': {u'primitive-definition': [u'name', u'data_type', u'value']}}
  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_initial_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_initial_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/initial-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Initial set of configuration primitives.
  """
  __slots__ = ('_path_helper', '_extmethods', '__seq','__name','__execution_environment_ref','__parameter','__user_defined_script',)

  _yang_name = 'initial-config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'initial-config-primitive']

  def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq
      
  def _set_seq(self, v, load=False):
    """
    Setter method for seq, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""",
        })

    self.__seq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq(self):
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/name (string)

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  seq = __builtin__.property(_get_seq, _set_seq)
  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

  __choices__ = {u'primitive-type': {u'primitive-definition': [u'name', u'execution_environment_ref', u'parameter', u'user_defined_script']}}
  _pyangbind_elements = OrderedDict([('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_terminate_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/terminate-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__value',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'terminate-config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_terminate_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_terminate_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/terminate-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Terminate set of configuration primitives.
  """
  __slots__ = ('_path_helper', '_extmethods', '__seq','__name','__execution_environment_ref','__parameter','__user_defined_script',)

  _yang_name = 'terminate-config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'terminate-config-primitive']

  def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq
      
  def _set_seq(self, v, load=False):
    """
    Setter method for seq, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""",
        })

    self.__seq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq(self):
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/name (string)

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_ns_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  seq = __builtin__.property(_get_seq, _set_seq)
  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)


  _pyangbind_elements = OrderedDict([('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_metrics_nsd__nsd_catalog_nsd_ns_configuration_metrics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VCA related metrics
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__execution_environment_ref','__execution_environment_metric',)

  _yang_name = 'metrics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__execution_environment_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'metrics']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/metrics/name (string)

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/metrics/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment getting that metric
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/metrics/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment getting that metric
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_execution_environment_metric(self):
    """
    Getter method for execution_environment_metric, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/metrics/execution_environment_metric (string)

    YANG Description: Metric in the execution environment referenced by execution-environment-ref
    """
    return self.__execution_environment_metric
      
  def _set_execution_environment_metric(self, v, load=False):
    """
    Setter method for execution_environment_metric, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/metrics/execution_environment_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_metric() directly.

    YANG Description: Metric in the execution environment referenced by execution-environment-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_metric must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__execution_environment_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_metric(self):
    self.__execution_environment_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  execution_environment_metric = __builtin__.property(_get_execution_environment_metric, _set_execution_environment_metric)


  _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref), ('execution_environment_metric', execution_environment_metric), ])


class yc_entities_nsd__nsd_catalog_nsd_ns_configuration_relation_entities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/relation/entities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__endpoint',)

  _yang_name = 'entities'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'relation', u'entities']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/relation/entities/id (string)

    YANG Description: A string, reference to the element id in the descriptor.
It could be a vnfd-id or a vdu-id in a VNFD,
or a nsd-id or member-vnf-index in a NSD.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/relation/entities/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: A string, reference to the element id in the descriptor.
It could be a vnfd-id or a vdu-id in a VNFD,
or a nsd-id or member-vnf-index in a NSD.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_endpoint(self):
    """
    Getter method for endpoint, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/relation/entities/endpoint (string)

    YANG Description: Endpoint name defining the relation.
    """
    return self.__endpoint
      
  def _set_endpoint(self, v, load=False):
    """
    Setter method for endpoint, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/relation/entities/endpoint (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endpoint() directly.

    YANG Description: Endpoint name defining the relation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endpoint must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__endpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endpoint(self):
    self.__endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  endpoint = __builtin__.property(_get_endpoint, _set_endpoint)


  _pyangbind_elements = OrderedDict([('id', id), ('endpoint', endpoint), ])


class yc_relation_nsd__nsd_catalog_nsd_ns_configuration_relation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration/relation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of relations between elements in this descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__entities',)

  _yang_name = 'relation'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__entities = YANGDynClass(base=YANGListType("id",yc_entities_nsd__nsd_catalog_nsd_ns_configuration_relation_entities, yang_name="entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration', u'relation']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/relation/name (string)

    YANG Description: Name of the relation.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/relation/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the relation.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_entities(self):
    """
    Getter method for entities, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/relation/entities (list)

    YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
    """
    return self.__entities
      
  def _set_entities(self, v, load=False):
    """
    Setter method for entities, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/relation/entities (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_entities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_entities() directly.

    YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_entities_nsd__nsd_catalog_nsd_ns_configuration_relation_entities, yang_name="entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """entities must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_entities_nsd__nsd_catalog_nsd_ns_configuration_relation_entities, yang_name="entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__entities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_entities(self):
    self.__entities = YANGDynClass(base=YANGListType("id",yc_entities_nsd__nsd_catalog_nsd_ns_configuration_relation_entities, yang_name="entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  entities = __builtin__.property(_get_entities, _set_entities)


  _pyangbind_elements = OrderedDict([('name', name), ('entities', entities), ])


class yc_ns_configuration_nsd__nsd_catalog_nsd_ns_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ns-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about NS configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__script','__juju','__execution_environment_list','__config_primitive','__initial_config_primitive','__terminate_config_primitive','__metrics','__relation',)

  _yang_name = 'ns-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config_primitive = YANGDynClass(base=YANGListType("name",yc_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_nsd__nsd_catalog_nsd_ns_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__execution_environment_list = YANGDynClass(base=YANGListType("id",yc_execution_environment_list_nsd__nsd_catalog_nsd_ns_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__script = YANGDynClass(base=yc_script_nsd__nsd_catalog_nsd_ns_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    self.__juju = YANGDynClass(base=yc_juju_nsd__nsd_catalog_nsd_ns_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    self.__relation = YANGDynClass(base=YANGListType("name",yc_relation_nsd__nsd_catalog_nsd_ns_configuration_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'ns-configuration']

  def _get_script(self):
    """
    Getter method for script, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/script (container)
    """
    return self.__script
      
  def _set_script(self, v, load=False):
    """
    Setter method for script, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/script (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_script_nsd__nsd_catalog_nsd_ns_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_script_nsd__nsd_catalog_nsd_ns_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script(self):
    self.__script = YANGDynClass(base=yc_script_nsd__nsd_catalog_nsd_ns_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)


  def _get_juju(self):
    """
    Getter method for juju, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/juju (container)
    """
    return self.__juju
      
  def _set_juju(self, v, load=False):
    """
    Setter method for juju, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_juju_nsd__nsd_catalog_nsd_ns_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_juju_nsd__nsd_catalog_nsd_ns_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__juju = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju(self):
    self.__juju = YANGDynClass(base=yc_juju_nsd__nsd_catalog_nsd_ns_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)


  def _get_execution_environment_list(self):
    """
    Getter method for execution_environment_list, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list (list)
    """
    return self.__execution_environment_list
      
  def _set_execution_environment_list(self, v, load=False):
    """
    Setter method for execution_environment_list, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/execution_environment_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_execution_environment_list_nsd__nsd_catalog_nsd_ns_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_execution_environment_list_nsd__nsd_catalog_nsd_ns_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__execution_environment_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_list(self):
    self.__execution_environment_list = YANGDynClass(base=YANGListType("id",yc_execution_environment_list_nsd__nsd_catalog_nsd_ns_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_config_primitive(self):
    """
    Getter method for config_primitive, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive (list)

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
    return self.__config_primitive
      
  def _set_config_primitive(self, v, load=False):
    """
    Setter method for config_primitive, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_primitive() directly.

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_primitive(self):
    self.__config_primitive = YANGDynClass(base=YANGListType("name",yc_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_initial_config_primitive(self):
    """
    Getter method for initial_config_primitive, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive (list)

    YANG Description: Initial set of configuration primitives.
    """
    return self.__initial_config_primitive
      
  def _set_initial_config_primitive(self, v, load=False):
    """
    Setter method for initial_config_primitive, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/initial_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_initial_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_initial_config_primitive() directly.

    YANG Description: Initial set of configuration primitives.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("seq",yc_initial_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """initial_config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__initial_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_initial_config_primitive(self):
    self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_terminate_config_primitive(self):
    """
    Getter method for terminate_config_primitive, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive (list)

    YANG Description: Terminate set of configuration primitives.
    """
    return self.__terminate_config_primitive
      
  def _set_terminate_config_primitive(self, v, load=False):
    """
    Setter method for terminate_config_primitive, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/terminate_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_config_primitive() directly.

    YANG Description: Terminate set of configuration primitives.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("seq",yc_terminate_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminate_config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__terminate_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminate_config_primitive(self):
    self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_nsd__nsd_catalog_nsd_ns_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_metrics(self):
    """
    Getter method for metrics, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/metrics (list)

    YANG Description: List of VCA related metrics
    """
    return self.__metrics
      
  def _set_metrics(self, v, load=False):
    """
    Setter method for metrics, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: List of VCA related metrics
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_metrics_nsd__nsd_catalog_nsd_ns_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metrics must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_nsd__nsd_catalog_nsd_ns_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__metrics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metrics(self):
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_nsd__nsd_catalog_nsd_ns_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_relation(self):
    """
    Getter method for relation, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/relation (list)

    YANG Description: List of relations between elements in this descriptor.
    """
    return self.__relation
      
  def _set_relation(self, v, load=False):
    """
    Setter method for relation, mapped from YANG variable /nsd_catalog/nsd/ns_configuration/relation (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relation() directly.

    YANG Description: List of relations between elements in this descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_relation_nsd__nsd_catalog_nsd_ns_configuration_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relation must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_relation_nsd__nsd_catalog_nsd_ns_configuration_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__relation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relation(self):
    self.__relation = YANGDynClass(base=YANGListType("name",yc_relation_nsd__nsd_catalog_nsd_ns_configuration_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  script = __builtin__.property(_get_script, _set_script)
  juju = __builtin__.property(_get_juju, _set_juju)
  execution_environment_list = __builtin__.property(_get_execution_environment_list, _set_execution_environment_list)
  config_primitive = __builtin__.property(_get_config_primitive, _set_config_primitive)
  initial_config_primitive = __builtin__.property(_get_initial_config_primitive, _set_initial_config_primitive)
  terminate_config_primitive = __builtin__.property(_get_terminate_config_primitive, _set_terminate_config_primitive)
  metrics = __builtin__.property(_get_metrics, _set_metrics)
  relation = __builtin__.property(_get_relation, _set_relation)

  __choices__ = {u'config-method': {u'juju': [u'juju'], u'execution-environment-list': [u'execution_environment_list'], u'script': [u'script']}}
  _pyangbind_elements = OrderedDict([('script', script), ('juju', juju), ('execution_environment_list', execution_environment_list), ('config_primitive', config_primitive), ('initial_config_primitive', initial_config_primitive), ('terminate_config_primitive', terminate_config_primitive), ('metrics', metrics), ('relation', relation), ])


class yc_input_parameter_xpath_nsd__nsd_catalog_nsd_input_parameter_xpath(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/input-parameter-xpath. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of xpaths to parameters inside the NSD
the can be customized during the instantiation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__xpath','__label','__default_value',)

  _yang_name = 'input-parameter-xpath'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__xpath = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="xpath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__label = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'input-parameter-xpath']

  def _get_xpath(self):
    """
    Getter method for xpath, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/xpath (string)

    YANG Description: An xpath that specifies the element in a descriptor.
    """
    return self.__xpath
      
  def _set_xpath(self, v, load=False):
    """
    Setter method for xpath, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/xpath (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_xpath is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_xpath() directly.

    YANG Description: An xpath that specifies the element in a descriptor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="xpath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """xpath must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="xpath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__xpath = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_xpath(self):
    self.__xpath = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="xpath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/label (string)

    YANG Description: A descriptive string
    """
    return self.__label
      
  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/label (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: A descriptive string
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_default_value(self):
    """
    Getter method for default_value, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/default_value (string)

    YANG Description: Default Value for the Input Parameter
    """
    return self.__default_value
      
  def _set_default_value(self, v, load=False):
    """
    Setter method for default_value, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: Default Value for the Input Parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__default_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_value(self):
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  xpath = __builtin__.property(_get_xpath, _set_xpath)
  label = __builtin__.property(_get_label, _set_label)
  default_value = __builtin__.property(_get_default_value, _set_default_value)


  _pyangbind_elements = OrderedDict([('xpath', xpath), ('label', label), ('default_value', default_value), ])


class yc_range_nsd__nsd_catalog_nsd_parameter_pool_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/parameter-pool/range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Create a range of values to populate the pool with
  """
  __slots__ = ('_path_helper', '_extmethods', '__start_value','__end_value',)

  _yang_name = 'range'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="start-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    self.__end_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="end-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'parameter-pool', u'range']

  def _get_start_value(self):
    """
    Getter method for start_value, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range/start_value (uint32)

    YANG Description: Generated pool values start at this value
    """
    return self.__start_value
      
  def _set_start_value(self, v, load=False):
    """
    Setter method for start_value, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range/start_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_value() directly.

    YANG Description: Generated pool values start at this value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="start-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="start-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""",
        })

    self.__start_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_value(self):
    self.__start_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="start-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)


  def _get_end_value(self):
    """
    Getter method for end_value, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range/end_value (uint32)

    YANG Description: Generated pool values stop at this value
    """
    return self.__end_value
      
  def _set_end_value(self, v, load=False):
    """
    Setter method for end_value, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range/end_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_value() directly.

    YANG Description: Generated pool values stop at this value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="end-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="end-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""",
        })

    self.__end_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_value(self):
    self.__end_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="end-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)

  start_value = __builtin__.property(_get_start_value, _set_start_value)
  end_value = __builtin__.property(_get_end_value, _set_end_value)


  _pyangbind_elements = OrderedDict([('start_value', start_value), ('end_value', end_value), ])


class yc_parameter_pool_nsd__nsd_catalog_nsd_parameter_pool(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/parameter-pool. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Pool of parameter values which must be
pulled from during configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__range',)

  _yang_name = 'parameter-pool'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__range = YANGDynClass(base=yc_range_nsd__nsd_catalog_nsd_parameter_pool_range, is_container='container', yang_name="range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'parameter-pool']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/name (string)

    YANG Description: Name of the configuration value pool
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration value pool
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_range(self):
    """
    Getter method for range, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range (container)

    YANG Description: Create a range of values to populate the pool with
    """
    return self.__range
      
  def _set_range(self, v, load=False):
    """
    Setter method for range, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_range() directly.

    YANG Description: Create a range of values to populate the pool with
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_range_nsd__nsd_catalog_nsd_parameter_pool_range, is_container='container', yang_name="range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_range_nsd__nsd_catalog_nsd_parameter_pool_range, is_container='container', yang_name="range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_range(self):
    self.__range = YANGDynClass(base=yc_range_nsd__nsd_catalog_nsd_parameter_pool_range, is_container='container', yang_name="range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  range = __builtin__.property(_get_range, _set_range)


  _pyangbind_elements = OrderedDict([('name', name), ('range', range), ])


class yc_key_pair_nsd__nsd_catalog_nsd_key_pair(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/key-pair. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__key',)

  _yang_name = 'key-pair'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'key-pair']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/key_pair/name (string)

    YANG Description: Name of this key pair
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/key_pair/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of this key pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /nsd_catalog/nsd/key_pair/key (string)

    YANG Description: Key associated with this key pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /nsd_catalog/nsd/key_pair/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key associated with this key pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  key = __builtin__.property(_get_key, _set_key)


  _pyangbind_elements = OrderedDict([('name', name), ('key', key), ])


class yc_key_pair_nsd__nsd_catalog_nsd_user_key_pair(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/user/key-pair. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__key',)

  _yang_name = 'key-pair'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'user', u'key-pair']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/user/key_pair/name (string)

    YANG Description: Name of this key pair
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/user/key_pair/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of this key pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /nsd_catalog/nsd/user/key_pair/key (string)

    YANG Description: Key associated with this key pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /nsd_catalog/nsd/user/key_pair/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key associated with this key pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  key = __builtin__.property(_get_key, _set_key)


  _pyangbind_elements = OrderedDict([('name', name), ('key', key), ])


class yc_user_nsd__nsd_catalog_nsd_user(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/user. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of users to be added through cloud-config
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__user_info','__key_pair',)

  _yang_name = 'user'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_info = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__key_pair = YANGDynClass(base=YANGListType("name",yc_key_pair_nsd__nsd_catalog_nsd_user_key_pair, yang_name="key-pair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="key-pair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'user']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/user/name (string)

    YANG Description: Name of the user 
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/user/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the user 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_user_info(self):
    """
    Getter method for user_info, mapped from YANG variable /nsd_catalog/nsd/user/user_info (string)

    YANG Description: The user name's real name
    """
    return self.__user_info
      
  def _set_user_info(self, v, load=False):
    """
    Setter method for user_info, mapped from YANG variable /nsd_catalog/nsd/user/user_info (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_info() directly.

    YANG Description: The user name's real name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_info must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__user_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_info(self):
    self.__user_info = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_key_pair(self):
    """
    Getter method for key_pair, mapped from YANG variable /nsd_catalog/nsd/user/key_pair (list)

    YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
    """
    return self.__key_pair
      
  def _set_key_pair(self, v, load=False):
    """
    Setter method for key_pair, mapped from YANG variable /nsd_catalog/nsd/user/key_pair (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_pair is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_pair() directly.

    YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_key_pair_nsd__nsd_catalog_nsd_user_key_pair, yang_name="key-pair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="key-pair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_pair must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_key_pair_nsd__nsd_catalog_nsd_user_key_pair, yang_name="key-pair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="key-pair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__key_pair = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_pair(self):
    self.__key_pair = YANGDynClass(base=YANGListType("name",yc_key_pair_nsd__nsd_catalog_nsd_user_key_pair, yang_name="key-pair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="key-pair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  user_info = __builtin__.property(_get_user_info, _set_user_info)
  key_pair = __builtin__.property(_get_key_pair, _set_key_pair)


  _pyangbind_elements = OrderedDict([('name', name), ('user_info', user_info), ('key_pair', key_pair), ])


class yc_provider_network_nsd__nsd_catalog_nsd_vld_provider_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vld/provider-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the provider network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__physical_network','__segmentation_id',)

  _yang_name = 'provider-network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__segmentation_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    self.__physical_network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'vld', u'provider-network']

  def _get_physical_network(self):
    """
    Getter method for physical_network, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network/physical_network (string)

    YANG Description: Name of the physical network on which the provider
network is built.
    """
    return self.__physical_network
      
  def _set_physical_network(self, v, load=False):
    """
    Setter method for physical_network, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network/physical_network (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_network() directly.

    YANG Description: Name of the physical network on which the provider
network is built.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_network must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__physical_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_network(self):
    self.__physical_network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_segmentation_id(self):
    """
    Getter method for segmentation_id, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network/segmentation_id (uint32)

    YANG Description: ID of segregated virtual networks
    """
    return self.__segmentation_id
      
  def _set_segmentation_id(self, v, load=False):
    """
    Setter method for segmentation_id, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network/segmentation_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segmentation_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segmentation_id() directly.

    YANG Description: ID of segregated virtual networks
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """segmentation_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""",
        })

    self.__segmentation_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_segmentation_id(self):
    self.__segmentation_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint32', is_config=True)

  physical_network = __builtin__.property(_get_physical_network, _set_physical_network)
  segmentation_id = __builtin__.property(_get_segmentation_id, _set_segmentation_id)


  _pyangbind_elements = OrderedDict([('physical_network', physical_network), ('segmentation_id', segmentation_id), ])


class yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vld_vnfd_connection_point_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vld/vnfd-connection-point-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of references to connection points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__member_vnf_index_ref','__vnfd_connection_point_ref','__vnfd_id_ref','__ip_address',)

  _yang_name = 'vnfd-connection-point-ref'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnfd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'vld', u'vnfd-connection-point-ref']

  def _get_member_vnf_index_ref(self):
    """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/member_vnf_index_ref (leafref)

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
    return self.__member_vnf_index_ref
      
  def _set_member_vnf_index_ref(self, v, load=False):
    """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnf_index_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__member_vnf_index_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnf_index_ref(self):
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnfd_connection_point_ref(self):
    """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/vnfd_connection_point_ref (leafref)

    YANG Description: A reference to a connection point name
    """
    return self.__vnfd_connection_point_ref
      
  def _set_vnfd_connection_point_ref(self, v, load=False):
    """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/vnfd_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_connection_point_ref(self):
    self.__vnfd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnfd_id_ref(self):
    """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/vnfd_id_ref (leafref)

    YANG Description: A reference to a VNFD
    """
    return self.__vnfd_id_ref
      
  def _set_vnfd_id_ref(self, v, load=False):
    """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a VNFD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_id_ref(self):
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/ip_address (inet:ip-address)

    YANG Description: IP address of the connection point
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address of the connection point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)

  member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref, _set_member_vnf_index_ref)
  vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref, _set_vnfd_connection_point_ref)
  vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref, _set_vnfd_id_ref)
  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)


  _pyangbind_elements = OrderedDict([('member_vnf_index_ref', member_vnf_index_ref), ('vnfd_connection_point_ref', vnfd_connection_point_ref), ('vnfd_id_ref', vnfd_id_ref), ('ip_address', ip_address), ])


class yc_vld_nsd__nsd_catalog_nsd_vld(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__short_name','__vendor','__description','__version','__type','__root_bandwidth','__leaf_bandwidth','__provider_network','__mgmt_network','__vim_network_name','__ip_profile_ref','__vnfd_connection_point_ref',)

  _yang_name = 'vld'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    self.__vnfd_connection_point_ref = YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref",yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vld_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-connection-point-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    self.__provider_network = YANGDynClass(base=yc_provider_network_nsd__nsd_catalog_nsd_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    self.__mgmt_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__ip_profile_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-profile-ref", parent=self, choice=(u'init-params', u'vim-network-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__vim_network_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, choice=(u'init-params', u'vim-network-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:virtual-link-type', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'vld']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/vld/id (string)

    YANG Description: Identifier for the VLD.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/vld/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the VLD.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/vld/name (string)

    YANG Description: Virtual Link Descriptor (VLD) name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/vld/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Virtual Link Descriptor (VLD) name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /nsd_catalog/nsd/vld/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /nsd_catalog/nsd/vld/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_vendor(self):
    """
    Getter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vld/vendor (string)

    YANG Description: Provider of the VLD.
    """
    return self.__vendor
      
  def _set_vendor(self, v, load=False):
    """
    Setter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vld/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Provider of the VLD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor(self):
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /nsd_catalog/nsd/vld/description (string)

    YANG Description: Description of the VLD.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /nsd_catalog/nsd/vld/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the VLD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /nsd_catalog/nsd/vld/version (string)

    YANG Description: Version of the VLD
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /nsd_catalog/nsd/vld/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the VLD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /nsd_catalog/nsd/vld/type (manotypes:virtual-link-type)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /nsd_catalog/nsd/vld/type (manotypes:virtual-link-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:virtual-link-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with manotypes:virtual-link-type""",
          'defined-type': "manotypes:virtual-link-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:virtual-link-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:virtual-link-type', is_config=True)


  def _get_root_bandwidth(self):
    """
    Getter method for root_bandwidth, mapped from YANG variable /nsd_catalog/nsd/vld/root_bandwidth (uint64)

    YANG Description: For ELAN this is the aggregate bandwidth.
    """
    return self.__root_bandwidth
      
  def _set_root_bandwidth(self, v, load=False):
    """
    Setter method for root_bandwidth, mapped from YANG variable /nsd_catalog/nsd/vld/root_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_bandwidth() directly.

    YANG Description: For ELAN this is the aggregate bandwidth.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """root_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""",
        })

    self.__root_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_root_bandwidth(self):
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)


  def _get_leaf_bandwidth(self):
    """
    Getter method for leaf_bandwidth, mapped from YANG variable /nsd_catalog/nsd/vld/leaf_bandwidth (uint64)

    YANG Description: For ELAN this is the bandwidth of branches.
    """
    return self.__leaf_bandwidth
      
  def _set_leaf_bandwidth(self, v, load=False):
    """
    Setter method for leaf_bandwidth, mapped from YANG variable /nsd_catalog/nsd/vld/leaf_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf_bandwidth() directly.

    YANG Description: For ELAN this is the bandwidth of branches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leaf_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""",
        })

    self.__leaf_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leaf_bandwidth(self):
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)


  def _get_provider_network(self):
    """
    Getter method for provider_network, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network (container)

    YANG Description: Container for the provider network.
    """
    return self.__provider_network
      
  def _set_provider_network(self, v, load=False):
    """
    Setter method for provider_network, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_network() directly.

    YANG Description: Container for the provider network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_provider_network_nsd__nsd_catalog_nsd_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provider_network must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_provider_network_nsd__nsd_catalog_nsd_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__provider_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provider_network(self):
    self.__provider_network = YANGDynClass(base=yc_provider_network_nsd__nsd_catalog_nsd_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)


  def _get_mgmt_network(self):
    """
    Getter method for mgmt_network, mapped from YANG variable /nsd_catalog/nsd/vld/mgmt_network (boolean)

    YANG Description: Flag indicating whether this network is a VIM management network
    """
    return self.__mgmt_network
      
  def _set_mgmt_network(self, v, load=False):
    """
    Setter method for mgmt_network, mapped from YANG variable /nsd_catalog/nsd/vld/mgmt_network (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_network() directly.

    YANG Description: Flag indicating whether this network is a VIM management network
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_network must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""",
        })

    self.__mgmt_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_network(self):
    self.__mgmt_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)


  def _get_vim_network_name(self):
    """
    Getter method for vim_network_name, mapped from YANG variable /nsd_catalog/nsd/vld/vim_network_name (string)

    YANG Description: Name of network in VIM account. This is used to indicate
      pre-provisioned network name in cloud account.
    """
    return self.__vim_network_name
      
  def _set_vim_network_name(self, v, load=False):
    """
    Setter method for vim_network_name, mapped from YANG variable /nsd_catalog/nsd/vld/vim_network_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_network_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_network_name() directly.

    YANG Description: Name of network in VIM account. This is used to indicate
      pre-provisioned network name in cloud account.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, choice=(u'init-params', u'vim-network-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vim_network_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, choice=(u'init-params', u'vim-network-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__vim_network_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vim_network_name(self):
    self.__vim_network_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, choice=(u'init-params', u'vim-network-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_ip_profile_ref(self):
    """
    Getter method for ip_profile_ref, mapped from YANG variable /nsd_catalog/nsd/vld/ip_profile_ref (leafref)

    YANG Description: Named reference to IP-profile object
    """
    return self.__ip_profile_ref
      
  def _set_ip_profile_ref(self, v, load=False):
    """
    Setter method for ip_profile_ref, mapped from YANG variable /nsd_catalog/nsd/vld/ip_profile_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profile_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profile_ref() directly.

    YANG Description: Named reference to IP-profile object
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip-profile-ref", parent=self, choice=(u'init-params', u'vim-network-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_profile_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-profile-ref", parent=self, choice=(u'init-params', u'vim-network-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__ip_profile_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_profile_ref(self):
    self.__ip_profile_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-profile-ref", parent=self, choice=(u'init-params', u'vim-network-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnfd_connection_point_ref(self):
    """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref (list)

    YANG Description: A list of references to connection points.
    """
    return self.__vnfd_connection_point_ref
      
  def _set_vnfd_connection_point_ref(self, v, load=False):
    """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.

    YANG Description: A list of references to connection points.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref",yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vld_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-connection-point-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_connection_point_ref must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref",yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vld_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-connection-point-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__vnfd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_connection_point_ref(self):
    self.__vnfd_connection_point_ref = YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref",yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vld_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-connection-point-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  vendor = __builtin__.property(_get_vendor, _set_vendor)
  description = __builtin__.property(_get_description, _set_description)
  version = __builtin__.property(_get_version, _set_version)
  type = __builtin__.property(_get_type, _set_type)
  root_bandwidth = __builtin__.property(_get_root_bandwidth, _set_root_bandwidth)
  leaf_bandwidth = __builtin__.property(_get_leaf_bandwidth, _set_leaf_bandwidth)
  provider_network = __builtin__.property(_get_provider_network, _set_provider_network)
  mgmt_network = __builtin__.property(_get_mgmt_network, _set_mgmt_network)
  vim_network_name = __builtin__.property(_get_vim_network_name, _set_vim_network_name)
  ip_profile_ref = __builtin__.property(_get_ip_profile_ref, _set_ip_profile_ref)
  vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref, _set_vnfd_connection_point_ref)

  __choices__ = {u'init-params': {u'vim-network-profile': [u'ip_profile_ref'], u'vim-network-ref': [u'vim_network_name']}}
  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('short_name', short_name), ('vendor', vendor), ('description', description), ('version', version), ('type', type), ('root_bandwidth', root_bandwidth), ('leaf_bandwidth', leaf_bandwidth), ('provider_network', provider_network), ('mgmt_network', mgmt_network), ('vim_network_name', vim_network_name), ('ip_profile_ref', ip_profile_ref), ('vnfd_connection_point_ref', vnfd_connection_point_ref), ])


class yc_constituent_vnfd_nsd__nsd_catalog_nsd_constituent_vnfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/constituent-vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNFDs that are part of this
network service.
  """
  __slots__ = ('_path_helper', '_extmethods', '__member_vnf_index','__vnfd_id_ref','__start_by_default',)

  _yang_name = 'constituent-vnfd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__member_vnf_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__start_by_default = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="start-by-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'constituent-vnfd']

  def _get_member_vnf_index(self):
    """
    Getter method for member_vnf_index, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/member_vnf_index (string)

    YANG Description: Identifier/index for the VNFD. This separate id
is required to ensure that multiple VNFs can be
part of single NS
    """
    return self.__member_vnf_index
      
  def _set_member_vnf_index(self, v, load=False):
    """
    Setter method for member_vnf_index, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/member_vnf_index (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index() directly.

    YANG Description: Identifier/index for the VNFD. This separate id
is required to ensure that multiple VNFs can be
part of single NS
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vnf-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnf_index must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__member_vnf_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnf_index(self):
    self.__member_vnf_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_vnfd_id_ref(self):
    """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/vnfd_id_ref (leafref)

    YANG Description: Identifier for the VNFD.
    """
    return self.__vnfd_id_ref
      
  def _set_vnfd_id_ref(self, v, load=False):
    """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: Identifier for the VNFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_id_ref(self):
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_start_by_default(self):
    """
    Getter method for start_by_default, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/start_by_default (boolean)

    YANG Description: VNFD is started as part of the NS instantiation
    """
    return self.__start_by_default
      
  def _set_start_by_default(self, v, load=False):
    """
    Setter method for start_by_default, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/start_by_default (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_by_default is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_by_default() directly.

    YANG Description: VNFD is started as part of the NS instantiation
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="start-by-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_by_default must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="start-by-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""",
        })

    self.__start_by_default = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_by_default(self):
    self.__start_by_default = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="start-by-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='boolean', is_config=True)

  member_vnf_index = __builtin__.property(_get_member_vnf_index, _set_member_vnf_index)
  vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref, _set_vnfd_id_ref)
  start_by_default = __builtin__.property(_get_start_by_default, _set_start_by_default)


  _pyangbind_elements = OrderedDict([('member_vnf_index', member_vnf_index), ('vnfd_id_ref', vnfd_id_ref), ('start_by_default', start_by_default), ])


class yc_member_vnfd_nsd__nsd_catalog_nsd_placement_groups_member_vnfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/placement-groups/member-vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNFDs that are part of this placement group
  """
  __slots__ = ('_path_helper', '_extmethods', '__member_vnf_index_ref','__vnfd_id_ref',)

  _yang_name = 'member-vnfd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'placement-groups', u'member-vnfd']

  def _get_member_vnf_index_ref(self):
    """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd/member_vnf_index_ref (leafref)

    YANG Description: Member VNF index of this member VNF
    """
    return self.__member_vnf_index_ref
      
  def _set_member_vnf_index_ref(self, v, load=False):
    """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Member VNF index of this member VNF
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnf_index_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__member_vnf_index_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnf_index_ref(self):
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnfd_id_ref(self):
    """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd/vnfd_id_ref (leafref)

    YANG Description: Identifier for the VNFD.
    """
    return self.__vnfd_id_ref
      
  def _set_vnfd_id_ref(self, v, load=False):
    """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: Identifier for the VNFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_id_ref(self):
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

  member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref, _set_member_vnf_index_ref)
  vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref, _set_vnfd_id_ref)


  _pyangbind_elements = OrderedDict([('member_vnf_index_ref', member_vnf_index_ref), ('vnfd_id_ref', vnfd_id_ref), ])


class yc_placement_groups_nsd__nsd_catalog_nsd_placement_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/placement-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of placement groups at NS level
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__requirement','__strategy','__member_vnfd',)

  _yang_name = 'placement-groups'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__requirement = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__member_vnfd = YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_member_vnfd_nsd__nsd_catalog_nsd_placement_groups_member_vnfd, yang_name="member-vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="member-vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__strategy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COLOCATION': {}, u'ISOLATION': {}},), default=six.text_type("COLOCATION"), is_leaf=True, yang_name="strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'placement-groups']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/placement_groups/name (string)

    YANG Description: Place group construct to define the compute resource placement strategy
in cloud environment
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/placement_groups/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Place group construct to define the compute resource placement strategy
in cloud environment
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_requirement(self):
    """
    Getter method for requirement, mapped from YANG variable /nsd_catalog/nsd/placement_groups/requirement (string)

    YANG Description: This is free text space used to describe the intent/rationale
behind this placement group. This is for human consumption only
    """
    return self.__requirement
      
  def _set_requirement(self, v, load=False):
    """
    Setter method for requirement, mapped from YANG variable /nsd_catalog/nsd/placement_groups/requirement (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requirement() directly.

    YANG Description: This is free text space used to describe the intent/rationale
behind this placement group. This is for human consumption only
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """requirement must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__requirement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_requirement(self):
    self.__requirement = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_strategy(self):
    """
    Getter method for strategy, mapped from YANG variable /nsd_catalog/nsd/placement_groups/strategy (enumeration)

    YANG Description: Strategy associated with this placement group
  Following values are possible
    - COLOCATION: Colocation strategy imply intent to share the physical
                  infrastructure (hypervisor/network) among all members
                  of this group.
    - ISOLATION: Isolation strategy imply intent to not share the physical
                 infrastructure (hypervisor/network) among the members
                 of this group.
  
    """
    return self.__strategy
      
  def _set_strategy(self, v, load=False):
    """
    Setter method for strategy, mapped from YANG variable /nsd_catalog/nsd/placement_groups/strategy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_strategy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_strategy() directly.

    YANG Description: Strategy associated with this placement group
  Following values are possible
    - COLOCATION: Colocation strategy imply intent to share the physical
                  infrastructure (hypervisor/network) among all members
                  of this group.
    - ISOLATION: Isolation strategy imply intent to not share the physical
                 infrastructure (hypervisor/network) among the members
                 of this group.
  
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COLOCATION': {}, u'ISOLATION': {}},), default=six.text_type("COLOCATION"), is_leaf=True, yang_name="strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """strategy must be of a type compatible with enumeration""",
          'defined-type': "nsd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COLOCATION': {}, u'ISOLATION': {}},), default=six.text_type("COLOCATION"), is_leaf=True, yang_name="strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)""",
        })

    self.__strategy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_strategy(self):
    self.__strategy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COLOCATION': {}, u'ISOLATION': {}},), default=six.text_type("COLOCATION"), is_leaf=True, yang_name="strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)


  def _get_member_vnfd(self):
    """
    Getter method for member_vnfd, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd (list)

    YANG Description: List of VNFDs that are part of this placement group
    """
    return self.__member_vnfd
      
  def _set_member_vnfd(self, v, load=False):
    """
    Setter method for member_vnfd, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnfd() directly.

    YANG Description: List of VNFDs that are part of this placement group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("member_vnf_index_ref",yc_member_vnfd_nsd__nsd_catalog_nsd_placement_groups_member_vnfd, yang_name="member-vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="member-vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnfd must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_member_vnfd_nsd__nsd_catalog_nsd_placement_groups_member_vnfd, yang_name="member-vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="member-vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__member_vnfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnfd(self):
    self.__member_vnfd = YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_member_vnfd_nsd__nsd_catalog_nsd_placement_groups_member_vnfd, yang_name="member-vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="member-vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  requirement = __builtin__.property(_get_requirement, _set_requirement)
  strategy = __builtin__.property(_get_strategy, _set_strategy)
  member_vnfd = __builtin__.property(_get_member_vnfd, _set_member_vnfd)


  _pyangbind_elements = OrderedDict([('name', name), ('requirement', requirement), ('strategy', strategy), ('member_vnfd', member_vnfd), ])


class yc_vnf_dependency_nsd__nsd_catalog_nsd_vnf_dependency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnf-dependency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNF dependencies.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vnf_source_ref','__vnf_depends_on_ref',)

  _yang_name = 'vnf-dependency'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnf_source_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-source-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__vnf_depends_on_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-depends-on-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'vnf-dependency']

  def _get_vnf_source_ref(self):
    """
    Getter method for vnf_source_ref, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency/vnf_source_ref (leafref)
    """
    return self.__vnf_source_ref
      
  def _set_vnf_source_ref(self, v, load=False):
    """
    Setter method for vnf_source_ref, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency/vnf_source_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_source_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_source_ref() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnf-source-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_source_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-source-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnf_source_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_source_ref(self):
    self.__vnf_source_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-source-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnf_depends_on_ref(self):
    """
    Getter method for vnf_depends_on_ref, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency/vnf_depends_on_ref (leafref)

    YANG Description: Reference to VNF that sorce VNF depends.
    """
    return self.__vnf_depends_on_ref
      
  def _set_vnf_depends_on_ref(self, v, load=False):
    """
    Setter method for vnf_depends_on_ref, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency/vnf_depends_on_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_depends_on_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_depends_on_ref() directly.

    YANG Description: Reference to VNF that sorce VNF depends.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnf-depends-on-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_depends_on_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-depends-on-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnf_depends_on_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_depends_on_ref(self):
    self.__vnf_depends_on_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-depends-on-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

  vnf_source_ref = __builtin__.property(_get_vnf_source_ref, _set_vnf_source_ref)
  vnf_depends_on_ref = __builtin__.property(_get_vnf_depends_on_ref, _set_vnf_depends_on_ref)


  _pyangbind_elements = OrderedDict([('vnf_source_ref', vnf_source_ref), ('vnf_depends_on_ref', vnf_depends_on_ref), ])


class yc_numeric_constraints_nsd__nsd_catalog_nsd_monitoring_param_numeric_constraints(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/monitoring-param/numeric-constraints. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__min_value','__max_value',)

  _yang_name = 'numeric-constraints'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    self.__min_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'monitoring-param', u'numeric-constraints']

  def _get_min_value(self):
    """
    Getter method for min_value, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints/min_value (uint64)

    YANG Description: Minimum value for the parameter
    """
    return self.__min_value
      
  def _set_min_value(self, v, load=False):
    """
    Setter method for min_value, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints/min_value (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_value() directly.

    YANG Description: Minimum value for the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_value must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""",
        })

    self.__min_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_value(self):
    self.__min_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)


  def _get_max_value(self):
    """
    Getter method for max_value, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints/max_value (uint64)

    YANG Description: Maximum value for the parameter
    """
    return self.__max_value
      
  def _set_max_value(self, v, load=False):
    """
    Setter method for max_value, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints/max_value (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_value() directly.

    YANG Description: Maximum value for the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_value must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""",
        })

    self.__max_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_value(self):
    self.__max_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint64', is_config=True)

  min_value = __builtin__.property(_get_min_value, _set_min_value)
  max_value = __builtin__.property(_get_max_value, _set_max_value)


  _pyangbind_elements = OrderedDict([('min_value', min_value), ('max_value', max_value), ])


class yc_text_constraints_nsd__nsd_catalog_nsd_monitoring_param_text_constraints(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/monitoring-param/text-constraints. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__min_length','__max_length',)

  _yang_name = 'text-constraints'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__min_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)
    self.__max_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'monitoring-param', u'text-constraints']

  def _get_min_length(self):
    """
    Getter method for min_length, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints/min_length (uint8)

    YANG Description: Minimum string length for the parameter
    """
    return self.__min_length
      
  def _set_min_length(self, v, load=False):
    """
    Setter method for min_length, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints/min_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_length() directly.

    YANG Description: Minimum string length for the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)""",
        })

    self.__min_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_length(self):
    self.__min_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)


  def _get_max_length(self):
    """
    Getter method for max_length, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints/max_length (uint8)

    YANG Description: Maximum string length for the parameter
    """
    return self.__max_length
      
  def _set_max_length(self, v, load=False):
    """
    Setter method for max_length, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints/max_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_length() directly.

    YANG Description: Maximum string length for the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)""",
        })

    self.__max_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_length(self):
    self.__max_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='uint8', is_config=True)

  min_length = __builtin__.property(_get_min_length, _set_min_length)
  max_length = __builtin__.property(_get_max_length, _set_max_length)


  _pyangbind_elements = OrderedDict([('min_length', min_length), ('max_length', max_length), ])


class yc_vnfd_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param_vnfd_monitoring_param(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/monitoring-param/vnfd-monitoring-param. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of VNFD monitoring params
  """
  __slots__ = ('_path_helper', '_extmethods', '__vnfd_id_ref','__vnfd_monitoring_param_ref','__member_vnf_index_ref',)

  _yang_name = 'vnfd-monitoring-param'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__vnfd_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'monitoring-param', u'vnfd-monitoring-param']

  def _get_vnfd_id_ref(self):
    """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/vnfd_id_ref (leafref)

    YANG Description: A reference to a VNFD. This is a leafref
    """
    return self.__vnfd_id_ref
      
  def _set_vnfd_id_ref(self, v, load=False):
    """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a VNFD. This is a leafref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_id_ref(self):
    self.__vnfd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_vnfd_monitoring_param_ref(self):
    """
    Getter method for vnfd_monitoring_param_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/vnfd_monitoring_param_ref (leafref)

    YANG Description: A reference to the VNFD monitoring param
    """
    return self.__vnfd_monitoring_param_ref
      
  def _set_vnfd_monitoring_param_ref(self, v, load=False):
    """
    Setter method for vnfd_monitoring_param_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/vnfd_monitoring_param_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_monitoring_param_ref() directly.

    YANG Description: A reference to the VNFD monitoring param
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_monitoring_param_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_monitoring_param_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_monitoring_param_ref(self):
    self.__vnfd_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)


  def _get_member_vnf_index_ref(self):
    """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/member_vnf_index_ref (leafref)

    YANG Description: Mandatory reference to member-vnf within constituent-vnfds
    """
    return self.__member_vnf_index_ref
      
  def _set_member_vnf_index_ref(self, v, load=False):
    """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Mandatory reference to member-vnf within constituent-vnfds
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnf_index_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""",
        })

    self.__member_vnf_index_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnf_index_ref(self):
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='leafref', is_config=True)

  vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref, _set_vnfd_id_ref)
  vnfd_monitoring_param_ref = __builtin__.property(_get_vnfd_monitoring_param_ref, _set_vnfd_monitoring_param_ref)
  member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref, _set_member_vnf_index_ref)


  _pyangbind_elements = OrderedDict([('vnfd_id_ref', vnfd_id_ref), ('vnfd_monitoring_param_ref', vnfd_monitoring_param_ref), ('member_vnf_index_ref', member_vnf_index_ref), ])


class yc_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/monitoring-param. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__value_type','__numeric_constraints','__text_constraints','__value_integer','__value_decimal','__value_string','__description','__group_tag','__widget_type','__units','__aggregation_type','__vnfd_monitoring_param',)

  _yang_name = 'monitoring-param'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value_integer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="value-integer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='int64', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__vnfd_monitoring_param = YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_monitoring_param_ref",yc_vnfd_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param_vnfd_monitoring_param, yang_name="vnfd-monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-monitoring-param-ref', extensions=None), is_container='list', yang_name="vnfd-monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__text_constraints = YANGDynClass(base=yc_text_constraints_nsd__nsd_catalog_nsd_monitoring_param_text_constraints, is_container='container', yang_name="text-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    self.__group_tag = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__value_string = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__widget_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'BAR': {}, u'COUNTER': {}, u'HISTOGRAM': {}, u'SLIDER': {}, u'GAUGE': {}, u'TEXTBOX': {}},), default=six.text_type("COUNTER"), is_leaf=True, yang_name="widget-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:widget-type', is_config=True)
    self.__aggregation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="aggregation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='aggregation-type', is_config=True)
    self.__value_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INT': {}, u'DECIMAL': {}, u'STRING': {}},), default=six.text_type("INT"), is_leaf=True, yang_name="value-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='param-value-type', is_config=True)
    self.__value_decimal = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value-decimal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='decimal64', is_config=True)
    self.__units = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="units", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__numeric_constraints = YANGDynClass(base=yc_numeric_constraints_nsd__nsd_catalog_nsd_monitoring_param_numeric_constraints, is_container='container', yang_name="numeric-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd', u'monitoring-param']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_value_type(self):
    """
    Getter method for value_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_type (param-value-type)
    """
    return self.__value_type
      
  def _set_value_type(self, v, load=False):
    """
    Setter method for value_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_type (param-value-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INT': {}, u'DECIMAL': {}, u'STRING': {}},), default=six.text_type("INT"), is_leaf=True, yang_name="value-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='param-value-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value_type must be of a type compatible with param-value-type""",
          'defined-type': "nsd:param-value-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INT': {}, u'DECIMAL': {}, u'STRING': {}},), default=six.text_type("INT"), is_leaf=True, yang_name="value-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='param-value-type', is_config=True)""",
        })

    self.__value_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value_type(self):
    self.__value_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INT': {}, u'DECIMAL': {}, u'STRING': {}},), default=six.text_type("INT"), is_leaf=True, yang_name="value-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='param-value-type', is_config=True)


  def _get_numeric_constraints(self):
    """
    Getter method for numeric_constraints, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints (container)
    """
    return self.__numeric_constraints
      
  def _set_numeric_constraints(self, v, load=False):
    """
    Setter method for numeric_constraints, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numeric_constraints is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numeric_constraints() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_numeric_constraints_nsd__nsd_catalog_nsd_monitoring_param_numeric_constraints, is_container='container', yang_name="numeric-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numeric_constraints must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_numeric_constraints_nsd__nsd_catalog_nsd_monitoring_param_numeric_constraints, is_container='container', yang_name="numeric-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__numeric_constraints = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numeric_constraints(self):
    self.__numeric_constraints = YANGDynClass(base=yc_numeric_constraints_nsd__nsd_catalog_nsd_monitoring_param_numeric_constraints, is_container='container', yang_name="numeric-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)


  def _get_text_constraints(self):
    """
    Getter method for text_constraints, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints (container)
    """
    return self.__text_constraints
      
  def _set_text_constraints(self, v, load=False):
    """
    Setter method for text_constraints, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_text_constraints is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_text_constraints() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_text_constraints_nsd__nsd_catalog_nsd_monitoring_param_text_constraints, is_container='container', yang_name="text-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """text_constraints must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_text_constraints_nsd__nsd_catalog_nsd_monitoring_param_text_constraints, is_container='container', yang_name="text-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__text_constraints = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_text_constraints(self):
    self.__text_constraints = YANGDynClass(base=yc_text_constraints_nsd__nsd_catalog_nsd_monitoring_param_text_constraints, is_container='container', yang_name="text-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)


  def _get_value_integer(self):
    """
    Getter method for value_integer, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_integer (int64)

    YANG Description: Current value for an integer parameter
    """
    return self.__value_integer
      
  def _set_value_integer(self, v, load=False):
    """
    Setter method for value_integer, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_integer (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_integer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_integer() directly.

    YANG Description: Current value for an integer parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="value-integer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value_integer must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="value-integer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='int64', is_config=True)""",
        })

    self.__value_integer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value_integer(self):
    self.__value_integer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="value-integer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='int64', is_config=True)


  def _get_value_decimal(self):
    """
    Getter method for value_decimal, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_decimal (decimal64)

    YANG Description: Current value for a decimal parameter
    """
    return self.__value_decimal
      
  def _set_value_decimal(self, v, load=False):
    """
    Setter method for value_decimal, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_decimal (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_decimal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_decimal() directly.

    YANG Description: Current value for a decimal parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value-decimal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value_decimal must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value-decimal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='decimal64', is_config=True)""",
        })

    self.__value_decimal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value_decimal(self):
    self.__value_decimal = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value-decimal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='decimal64', is_config=True)


  def _get_value_string(self):
    """
    Getter method for value_string, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_string (string)

    YANG Description: Current value for a string parameter
    """
    return self.__value_string
      
  def _set_value_string(self, v, load=False):
    """
    Setter method for value_string, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_string() directly.

    YANG Description: Current value for a string parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__value_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value_string(self):
    self.__value_string = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/description (string)
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_group_tag(self):
    """
    Getter method for group_tag, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/group_tag (string)

    YANG Description: A tag to group monitoring parameters
    """
    return self.__group_tag
      
  def _set_group_tag(self, v, load=False):
    """
    Setter method for group_tag, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/group_tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_tag() directly.

    YANG Description: A tag to group monitoring parameters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="group-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__group_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_tag(self):
    self.__group_tag = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_widget_type(self):
    """
    Getter method for widget_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/widget_type (manotypes:widget-type)

    YANG Description: Defines the UI Display variant of measured counters.
    """
    return self.__widget_type
      
  def _set_widget_type(self, v, load=False):
    """
    Setter method for widget_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/widget_type (manotypes:widget-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_widget_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_widget_type() directly.

    YANG Description: Defines the UI Display variant of measured counters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'BAR': {}, u'COUNTER': {}, u'HISTOGRAM': {}, u'SLIDER': {}, u'GAUGE': {}, u'TEXTBOX': {}},), default=six.text_type("COUNTER"), is_leaf=True, yang_name="widget-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:widget-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """widget_type must be of a type compatible with manotypes:widget-type""",
          'defined-type': "manotypes:widget-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'BAR': {}, u'COUNTER': {}, u'HISTOGRAM': {}, u'SLIDER': {}, u'GAUGE': {}, u'TEXTBOX': {}},), default=six.text_type("COUNTER"), is_leaf=True, yang_name="widget-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:widget-type', is_config=True)""",
        })

    self.__widget_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_widget_type(self):
    self.__widget_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'BAR': {}, u'COUNTER': {}, u'HISTOGRAM': {}, u'SLIDER': {}, u'GAUGE': {}, u'TEXTBOX': {}},), default=six.text_type("COUNTER"), is_leaf=True, yang_name="widget-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='manotypes:widget-type', is_config=True)


  def _get_units(self):
    """
    Getter method for units, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/units (string)

    YANG Description: Measured Counter Units (e.g., Packets, Kbps, Mbps, etc.)
    """
    return self.__units
      
  def _set_units(self, v, load=False):
    """
    Setter method for units, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/units (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_units is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_units() directly.

    YANG Description: Measured Counter Units (e.g., Packets, Kbps, Mbps, etc.)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="units", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """units must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="units", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__units = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_units(self):
    self.__units = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="units", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_aggregation_type(self):
    """
    Getter method for aggregation_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/aggregation_type (aggregation-type)
    """
    return self.__aggregation_type
      
  def _set_aggregation_type(self, v, load=False):
    """
    Setter method for aggregation_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/aggregation_type (aggregation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregation_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="aggregation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='aggregation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregation_type must be of a type compatible with aggregation-type""",
          'defined-type': "nsd:aggregation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="aggregation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='aggregation-type', is_config=True)""",
        })

    self.__aggregation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregation_type(self):
    self.__aggregation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="aggregation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='aggregation-type', is_config=True)


  def _get_vnfd_monitoring_param(self):
    """
    Getter method for vnfd_monitoring_param, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param (list)

    YANG Description: A list of VNFD monitoring params
    """
    return self.__vnfd_monitoring_param
      
  def _set_vnfd_monitoring_param(self, v, load=False):
    """
    Setter method for vnfd_monitoring_param, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_monitoring_param is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_monitoring_param() directly.

    YANG Description: A list of VNFD monitoring params
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("member_vnf_index_ref vnfd_monitoring_param_ref",yc_vnfd_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param_vnfd_monitoring_param, yang_name="vnfd-monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-monitoring-param-ref', extensions=None), is_container='list', yang_name="vnfd-monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_monitoring_param must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_monitoring_param_ref",yc_vnfd_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param_vnfd_monitoring_param, yang_name="vnfd-monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-monitoring-param-ref', extensions=None), is_container='list', yang_name="vnfd-monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__vnfd_monitoring_param = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_monitoring_param(self):
    self.__vnfd_monitoring_param = YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_monitoring_param_ref",yc_vnfd_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param_vnfd_monitoring_param, yang_name="vnfd-monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-monitoring-param-ref', extensions=None), is_container='list', yang_name="vnfd-monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  value_type = __builtin__.property(_get_value_type, _set_value_type)
  numeric_constraints = __builtin__.property(_get_numeric_constraints, _set_numeric_constraints)
  text_constraints = __builtin__.property(_get_text_constraints, _set_text_constraints)
  value_integer = __builtin__.property(_get_value_integer, _set_value_integer)
  value_decimal = __builtin__.property(_get_value_decimal, _set_value_decimal)
  value_string = __builtin__.property(_get_value_string, _set_value_string)
  description = __builtin__.property(_get_description, _set_description)
  group_tag = __builtin__.property(_get_group_tag, _set_group_tag)
  widget_type = __builtin__.property(_get_widget_type, _set_widget_type)
  units = __builtin__.property(_get_units, _set_units)
  aggregation_type = __builtin__.property(_get_aggregation_type, _set_aggregation_type)
  vnfd_monitoring_param = __builtin__.property(_get_vnfd_monitoring_param, _set_vnfd_monitoring_param)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('value_type', value_type), ('numeric_constraints', numeric_constraints), ('text_constraints', text_constraints), ('value_integer', value_integer), ('value_decimal', value_decimal), ('value_string', value_string), ('description', description), ('group_tag', group_tag), ('widget_type', widget_type), ('units', units), ('aggregation_type', aggregation_type), ('vnfd_monitoring_param', vnfd_monitoring_param), ])


class yc_nsd_nsd__nsd_catalog_nsd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__short_name','__vendor','__logo','__description','__version','__connection_point','__scaling_group_descriptor','__vnffgd','__ip_profiles','__ns_configuration','__input_parameter_xpath','__parameter_pool','__key_pair','__user','__vld','__constituent_vnfd','__placement_groups','__vnf_dependency','__monitoring_param',)

  _yang_name = 'nsd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnf_dependency = YANGDynClass(base=YANGListType("vnf_source_ref",yc_vnf_dependency_nsd__nsd_catalog_nsd_vnf_dependency, yang_name="vnf-dependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vnf-source-ref', extensions=None), is_container='list', yang_name="vnf-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__input_parameter_xpath = YANGDynClass(base=YANGListType("xpath",yc_input_parameter_xpath_nsd__nsd_catalog_nsd_input_parameter_xpath, yang_name="input-parameter-xpath", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='xpath', extensions=None), is_container='list', yang_name="input-parameter-xpath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__constituent_vnfd = YANGDynClass(base=YANGListType("member_vnf_index",yc_constituent_vnfd_nsd__nsd_catalog_nsd_constituent_vnfd, yang_name="constituent-vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index', extensions=None), is_container='list', yang_name="constituent-vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__placement_groups = YANGDynClass(base=YANGListType("name",yc_placement_groups_nsd__nsd_catalog_nsd_placement_groups, yang_name="placement-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="placement-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__connection_point = YANGDynClass(base=YANGListType("name",yc_connection_point_nsd__nsd_catalog_nsd_connection_point, yang_name="connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__monitoring_param = YANGDynClass(base=YANGListType("id",yc_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__vld = YANGDynClass(base=YANGListType("id",yc_vld_nsd__nsd_catalog_nsd_vld, yang_name="vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__scaling_group_descriptor = YANGDynClass(base=YANGListType("name",yc_scaling_group_descriptor_nsd__nsd_catalog_nsd_scaling_group_descriptor, yang_name="scaling-group-descriptor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-group-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__ns_configuration = YANGDynClass(base=yc_ns_configuration_nsd__nsd_catalog_nsd_ns_configuration, is_container='container', yang_name="ns-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__parameter_pool = YANGDynClass(base=YANGListType("name",yc_parameter_pool_nsd__nsd_catalog_nsd_parameter_pool, yang_name="parameter-pool", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__user = YANGDynClass(base=YANGListType("name",yc_user_nsd__nsd_catalog_nsd_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__key_pair = YANGDynClass(base=YANGListType("name",yc_key_pair_nsd__nsd_catalog_nsd_key_pair, yang_name="key-pair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="key-pair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__vnffgd = YANGDynClass(base=YANGListType("id",yc_vnffgd_nsd__nsd_catalog_nsd_vnffgd, yang_name="vnffgd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnffgd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__logo = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__ip_profiles = YANGDynClass(base=YANGListType("name",yc_ip_profiles_nsd__nsd_catalog_nsd_ip_profiles, yang_name="ip-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ip-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog', u'nsd']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/id (string)

    YANG Description: Identifier for the NSD.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the NSD.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/name (string)

    YANG Description: NSD name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: NSD name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /nsd_catalog/nsd/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /nsd_catalog/nsd/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_vendor(self):
    """
    Getter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vendor (string)

    YANG Description: Vendor of the NSD.
    """
    return self.__vendor
      
  def _set_vendor(self, v, load=False):
    """
    Setter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Vendor of the NSD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor(self):
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_logo(self):
    """
    Getter method for logo, mapped from YANG variable /nsd_catalog/nsd/logo (string)

    YANG Description: File path for  the vendor specific logo. For example icons/mylogo.png.
The logo  should be part of the network service
    """
    return self.__logo
      
  def _set_logo(self, v, load=False):
    """
    Setter method for logo, mapped from YANG variable /nsd_catalog/nsd/logo (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logo() directly.

    YANG Description: File path for  the vendor specific logo. For example icons/mylogo.png.
The logo  should be part of the network service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="logo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logo must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__logo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logo(self):
    self.__logo = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /nsd_catalog/nsd/description (string)

    YANG Description: Description of the NSD.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /nsd_catalog/nsd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the NSD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /nsd_catalog/nsd/version (string)

    YANG Description: Version of the NSD
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /nsd_catalog/nsd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the NSD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_connection_point(self):
    """
    Getter method for connection_point, mapped from YANG variable /nsd_catalog/nsd/connection_point (list)

    YANG Description: List for external connection points.
Each NS has one or more external connection
points. As the name implies that external
connection points are used for connecting
the NS to other NS or to external networks.
Each NS exposes these connection points to
the orchestrator. The orchestrator can
construct network service chains by
connecting the connection points between
different NS.
    """
    return self.__connection_point
      
  def _set_connection_point(self, v, load=False):
    """
    Setter method for connection_point, mapped from YANG variable /nsd_catalog/nsd/connection_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_point() directly.

    YANG Description: List for external connection points.
Each NS has one or more external connection
points. As the name implies that external
connection points are used for connecting
the NS to other NS or to external networks.
Each NS exposes these connection points to
the orchestrator. The orchestrator can
construct network service chains by
connecting the connection points between
different NS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_connection_point_nsd__nsd_catalog_nsd_connection_point, yang_name="connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_connection_point_nsd__nsd_catalog_nsd_connection_point, yang_name="connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__connection_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_point(self):
    self.__connection_point = YANGDynClass(base=YANGListType("name",yc_connection_point_nsd__nsd_catalog_nsd_connection_point, yang_name="connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_scaling_group_descriptor(self):
    """
    Getter method for scaling_group_descriptor, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor (list)

    YANG Description: scaling group descriptor within this network service.
The scaling group defines a group of VNFs,
and the ratio of VNFs in the network service
that is used as target for scaling action
    """
    return self.__scaling_group_descriptor
      
  def _set_scaling_group_descriptor(self, v, load=False):
    """
    Setter method for scaling_group_descriptor, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_group_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_group_descriptor() directly.

    YANG Description: scaling group descriptor within this network service.
The scaling group defines a group of VNFs,
and the ratio of VNFs in the network service
that is used as target for scaling action
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_scaling_group_descriptor_nsd__nsd_catalog_nsd_scaling_group_descriptor, yang_name="scaling-group-descriptor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-group-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scaling_group_descriptor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_group_descriptor_nsd__nsd_catalog_nsd_scaling_group_descriptor, yang_name="scaling-group-descriptor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-group-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__scaling_group_descriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scaling_group_descriptor(self):
    self.__scaling_group_descriptor = YANGDynClass(base=YANGListType("name",yc_scaling_group_descriptor_nsd__nsd_catalog_nsd_scaling_group_descriptor, yang_name="scaling-group-descriptor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-group-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_vnffgd(self):
    """
    Getter method for vnffgd, mapped from YANG variable /nsd_catalog/nsd/vnffgd (list)

    YANG Description: List of VNF Forwarding Graph Descriptors (VNFFGD).
    """
    return self.__vnffgd
      
  def _set_vnffgd(self, v, load=False):
    """
    Setter method for vnffgd, mapped from YANG variable /nsd_catalog/nsd/vnffgd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnffgd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnffgd() directly.

    YANG Description: List of VNF Forwarding Graph Descriptors (VNFFGD).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_vnffgd_nsd__nsd_catalog_nsd_vnffgd, yang_name="vnffgd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnffgd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnffgd must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_vnffgd_nsd__nsd_catalog_nsd_vnffgd, yang_name="vnffgd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnffgd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__vnffgd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnffgd(self):
    self.__vnffgd = YANGDynClass(base=YANGListType("id",yc_vnffgd_nsd__nsd_catalog_nsd_vnffgd, yang_name="vnffgd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnffgd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_ip_profiles(self):
    """
    Getter method for ip_profiles, mapped from YANG variable /nsd_catalog/nsd/ip_profiles (list)

    YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
    """
    return self.__ip_profiles
      
  def _set_ip_profiles(self, v, load=False):
    """
    Setter method for ip_profiles, mapped from YANG variable /nsd_catalog/nsd/ip_profiles (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profiles() directly.

    YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_ip_profiles_nsd__nsd_catalog_nsd_ip_profiles, yang_name="ip-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ip-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_profiles must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_ip_profiles_nsd__nsd_catalog_nsd_ip_profiles, yang_name="ip-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ip-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__ip_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_profiles(self):
    self.__ip_profiles = YANGDynClass(base=YANGListType("name",yc_ip_profiles_nsd__nsd_catalog_nsd_ip_profiles, yang_name="ip-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ip-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_ns_configuration(self):
    """
    Getter method for ns_configuration, mapped from YANG variable /nsd_catalog/nsd/ns_configuration (container)

    YANG Description: Information about NS configuration.
    """
    return self.__ns_configuration
      
  def _set_ns_configuration(self, v, load=False):
    """
    Setter method for ns_configuration, mapped from YANG variable /nsd_catalog/nsd/ns_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_configuration() directly.

    YANG Description: Information about NS configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ns_configuration_nsd__nsd_catalog_nsd_ns_configuration, is_container='container', yang_name="ns-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ns_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ns_configuration_nsd__nsd_catalog_nsd_ns_configuration, is_container='container', yang_name="ns-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__ns_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ns_configuration(self):
    self.__ns_configuration = YANGDynClass(base=yc_ns_configuration_nsd__nsd_catalog_nsd_ns_configuration, is_container='container', yang_name="ns-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)


  def _get_input_parameter_xpath(self):
    """
    Getter method for input_parameter_xpath, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath (list)

    YANG Description: List of xpaths to parameters inside the NSD
the can be customized during the instantiation.
    """
    return self.__input_parameter_xpath
      
  def _set_input_parameter_xpath(self, v, load=False):
    """
    Setter method for input_parameter_xpath, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_parameter_xpath is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_parameter_xpath() directly.

    YANG Description: List of xpaths to parameters inside the NSD
the can be customized during the instantiation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("xpath",yc_input_parameter_xpath_nsd__nsd_catalog_nsd_input_parameter_xpath, yang_name="input-parameter-xpath", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='xpath', extensions=None), is_container='list', yang_name="input-parameter-xpath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_parameter_xpath must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("xpath",yc_input_parameter_xpath_nsd__nsd_catalog_nsd_input_parameter_xpath, yang_name="input-parameter-xpath", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='xpath', extensions=None), is_container='list', yang_name="input-parameter-xpath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__input_parameter_xpath = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_parameter_xpath(self):
    self.__input_parameter_xpath = YANGDynClass(base=YANGListType("xpath",yc_input_parameter_xpath_nsd__nsd_catalog_nsd_input_parameter_xpath, yang_name="input-parameter-xpath", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='xpath', extensions=None), is_container='list', yang_name="input-parameter-xpath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_parameter_pool(self):
    """
    Getter method for parameter_pool, mapped from YANG variable /nsd_catalog/nsd/parameter_pool (list)

    YANG Description: Pool of parameter values which must be
pulled from during configuration
    """
    return self.__parameter_pool
      
  def _set_parameter_pool(self, v, load=False):
    """
    Setter method for parameter_pool, mapped from YANG variable /nsd_catalog/nsd/parameter_pool (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: Pool of parameter values which must be
pulled from during configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_pool_nsd__nsd_catalog_nsd_parameter_pool, yang_name="parameter-pool", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter_pool must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_pool_nsd__nsd_catalog_nsd_parameter_pool, yang_name="parameter-pool", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__parameter_pool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter_pool(self):
    self.__parameter_pool = YANGDynClass(base=YANGListType("name",yc_parameter_pool_nsd__nsd_catalog_nsd_parameter_pool, yang_name="parameter-pool", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_key_pair(self):
    """
    Getter method for key_pair, mapped from YANG variable /nsd_catalog/nsd/key_pair (list)

    YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
    """
    return self.__key_pair
      
  def _set_key_pair(self, v, load=False):
    """
    Setter method for key_pair, mapped from YANG variable /nsd_catalog/nsd/key_pair (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_pair is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_pair() directly.

    YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_key_pair_nsd__nsd_catalog_nsd_key_pair, yang_name="key-pair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="key-pair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_pair must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_key_pair_nsd__nsd_catalog_nsd_key_pair, yang_name="key-pair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="key-pair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__key_pair = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_pair(self):
    self.__key_pair = YANGDynClass(base=YANGListType("name",yc_key_pair_nsd__nsd_catalog_nsd_key_pair, yang_name="key-pair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="key-pair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_user(self):
    """
    Getter method for user, mapped from YANG variable /nsd_catalog/nsd/user (list)

    YANG Description: List of users to be added through cloud-config
    """
    return self.__user
      
  def _set_user(self, v, load=False):
    """
    Setter method for user, mapped from YANG variable /nsd_catalog/nsd/user (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user() directly.

    YANG Description: List of users to be added through cloud-config
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_user_nsd__nsd_catalog_nsd_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_user_nsd__nsd_catalog_nsd_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user(self):
    self.__user = YANGDynClass(base=YANGListType("name",yc_user_nsd__nsd_catalog_nsd_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_vld(self):
    """
    Getter method for vld, mapped from YANG variable /nsd_catalog/nsd/vld (list)
    """
    return self.__vld
      
  def _set_vld(self, v, load=False):
    """
    Setter method for vld, mapped from YANG variable /nsd_catalog/nsd/vld (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vld is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vld() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_vld_nsd__nsd_catalog_nsd_vld, yang_name="vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vld must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_vld_nsd__nsd_catalog_nsd_vld, yang_name="vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__vld = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vld(self):
    self.__vld = YANGDynClass(base=YANGListType("id",yc_vld_nsd__nsd_catalog_nsd_vld, yang_name="vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_constituent_vnfd(self):
    """
    Getter method for constituent_vnfd, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd (list)

    YANG Description: List of VNFDs that are part of this
network service.
    """
    return self.__constituent_vnfd
      
  def _set_constituent_vnfd(self, v, load=False):
    """
    Setter method for constituent_vnfd, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_vnfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_vnfd() directly.

    YANG Description: List of VNFDs that are part of this
network service.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("member_vnf_index",yc_constituent_vnfd_nsd__nsd_catalog_nsd_constituent_vnfd, yang_name="constituent-vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index', extensions=None), is_container='list', yang_name="constituent-vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """constituent_vnfd must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index",yc_constituent_vnfd_nsd__nsd_catalog_nsd_constituent_vnfd, yang_name="constituent-vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index', extensions=None), is_container='list', yang_name="constituent-vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__constituent_vnfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_constituent_vnfd(self):
    self.__constituent_vnfd = YANGDynClass(base=YANGListType("member_vnf_index",yc_constituent_vnfd_nsd__nsd_catalog_nsd_constituent_vnfd, yang_name="constituent-vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index', extensions=None), is_container='list', yang_name="constituent-vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_placement_groups(self):
    """
    Getter method for placement_groups, mapped from YANG variable /nsd_catalog/nsd/placement_groups (list)

    YANG Description: List of placement groups at NS level
    """
    return self.__placement_groups
      
  def _set_placement_groups(self, v, load=False):
    """
    Setter method for placement_groups, mapped from YANG variable /nsd_catalog/nsd/placement_groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_placement_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_placement_groups() directly.

    YANG Description: List of placement groups at NS level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_placement_groups_nsd__nsd_catalog_nsd_placement_groups, yang_name="placement-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="placement-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """placement_groups must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_placement_groups_nsd__nsd_catalog_nsd_placement_groups, yang_name="placement-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="placement-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__placement_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_placement_groups(self):
    self.__placement_groups = YANGDynClass(base=YANGListType("name",yc_placement_groups_nsd__nsd_catalog_nsd_placement_groups, yang_name="placement-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="placement-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_vnf_dependency(self):
    """
    Getter method for vnf_dependency, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency (list)

    YANG Description: List of VNF dependencies.
    """
    return self.__vnf_dependency
      
  def _set_vnf_dependency(self, v, load=False):
    """
    Setter method for vnf_dependency, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_dependency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_dependency() directly.

    YANG Description: List of VNF dependencies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vnf_source_ref",yc_vnf_dependency_nsd__nsd_catalog_nsd_vnf_dependency, yang_name="vnf-dependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vnf-source-ref', extensions=None), is_container='list', yang_name="vnf-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_dependency must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vnf_source_ref",yc_vnf_dependency_nsd__nsd_catalog_nsd_vnf_dependency, yang_name="vnf-dependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vnf-source-ref', extensions=None), is_container='list', yang_name="vnf-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__vnf_dependency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_dependency(self):
    self.__vnf_dependency = YANGDynClass(base=YANGListType("vnf_source_ref",yc_vnf_dependency_nsd__nsd_catalog_nsd_vnf_dependency, yang_name="vnf-dependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vnf-source-ref', extensions=None), is_container='list', yang_name="vnf-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)


  def _get_monitoring_param(self):
    """
    Getter method for monitoring_param, mapped from YANG variable /nsd_catalog/nsd/monitoring_param (list)
    """
    return self.__monitoring_param
      
  def _set_monitoring_param(self, v, load=False):
    """
    Setter method for monitoring_param, mapped from YANG variable /nsd_catalog/nsd/monitoring_param (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_param is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_param() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitoring_param must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__monitoring_param = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitoring_param(self):
    self.__monitoring_param = YANGDynClass(base=YANGListType("id",yc_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  vendor = __builtin__.property(_get_vendor, _set_vendor)
  logo = __builtin__.property(_get_logo, _set_logo)
  description = __builtin__.property(_get_description, _set_description)
  version = __builtin__.property(_get_version, _set_version)
  connection_point = __builtin__.property(_get_connection_point, _set_connection_point)
  scaling_group_descriptor = __builtin__.property(_get_scaling_group_descriptor, _set_scaling_group_descriptor)
  vnffgd = __builtin__.property(_get_vnffgd, _set_vnffgd)
  ip_profiles = __builtin__.property(_get_ip_profiles, _set_ip_profiles)
  ns_configuration = __builtin__.property(_get_ns_configuration, _set_ns_configuration)
  input_parameter_xpath = __builtin__.property(_get_input_parameter_xpath, _set_input_parameter_xpath)
  parameter_pool = __builtin__.property(_get_parameter_pool, _set_parameter_pool)
  key_pair = __builtin__.property(_get_key_pair, _set_key_pair)
  user = __builtin__.property(_get_user, _set_user)
  vld = __builtin__.property(_get_vld, _set_vld)
  constituent_vnfd = __builtin__.property(_get_constituent_vnfd, _set_constituent_vnfd)
  placement_groups = __builtin__.property(_get_placement_groups, _set_placement_groups)
  vnf_dependency = __builtin__.property(_get_vnf_dependency, _set_vnf_dependency)
  monitoring_param = __builtin__.property(_get_monitoring_param, _set_monitoring_param)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('short_name', short_name), ('vendor', vendor), ('logo', logo), ('description', description), ('version', version), ('connection_point', connection_point), ('scaling_group_descriptor', scaling_group_descriptor), ('vnffgd', vnffgd), ('ip_profiles', ip_profiles), ('ns_configuration', ns_configuration), ('input_parameter_xpath', input_parameter_xpath), ('parameter_pool', parameter_pool), ('key_pair', key_pair), ('user', user), ('vld', vld), ('constituent_vnfd', constituent_vnfd), ('placement_groups', placement_groups), ('vnf_dependency', vnf_dependency), ('monitoring_param', monitoring_param), ])


class yc_nsd_catalog_nsd__nsd_catalog(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__schema_version','__nsd',)

  _yang_name = 'nsd-catalog'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nsd = YANGDynClass(base=YANGListType("id",yc_nsd_nsd__nsd_catalog_nsd, yang_name="nsd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nsd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    self.__schema_version = YANGDynClass(base=six.text_type, default=six.text_type("v3.0"), is_leaf=True, yang_name="schema-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nsd-catalog']

  def _get_schema_version(self):
    """
    Getter method for schema_version, mapped from YANG variable /nsd_catalog/schema_version (string)

    YANG Description: Schema version for the NSD. If unspecified, it assumes v3.0
    """
    return self.__schema_version
      
  def _set_schema_version(self, v, load=False):
    """
    Setter method for schema_version, mapped from YANG variable /nsd_catalog/schema_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema_version() directly.

    YANG Description: Schema version for the NSD. If unspecified, it assumes v3.0
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("v3.0"), is_leaf=True, yang_name="schema-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """schema_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("v3.0"), is_leaf=True, yang_name="schema-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)""",
        })

    self.__schema_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_schema_version(self):
    self.__schema_version = YANGDynClass(base=six.text_type, default=six.text_type("v3.0"), is_leaf=True, yang_name="schema-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='string', is_config=True)


  def _get_nsd(self):
    """
    Getter method for nsd, mapped from YANG variable /nsd_catalog/nsd (list)
    """
    return self.__nsd
      
  def _set_nsd(self, v, load=False):
    """
    Setter method for nsd, mapped from YANG variable /nsd_catalog/nsd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_nsd_nsd__nsd_catalog_nsd, yang_name="nsd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nsd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_nsd_nsd__nsd_catalog_nsd, yang_name="nsd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nsd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)""",
        })

    self.__nsd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd(self):
    self.__nsd = YANGDynClass(base=YANGListType("id",yc_nsd_nsd__nsd_catalog_nsd, yang_name="nsd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nsd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='list', is_config=True)

  schema_version = __builtin__.property(_get_schema_version, _set_schema_version)
  nsd = __builtin__.property(_get_nsd, _set_nsd)


  _pyangbind_elements = OrderedDict([('schema_version', schema_version), ('nsd', nsd), ])


class nsd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nsd_catalog',)

  _yang_name = 'nsd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nsd_catalog = YANGDynClass(base=yc_nsd_catalog_nsd__nsd_catalog, is_container='container', yang_name="nsd-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_nsd_catalog(self):
    """
    Getter method for nsd_catalog, mapped from YANG variable /nsd_catalog (container)
    """
    return self.__nsd_catalog
      
  def _set_nsd_catalog(self, v, load=False):
    """
    Setter method for nsd_catalog, mapped from YANG variable /nsd_catalog (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_catalog is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_catalog() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_nsd_catalog_nsd__nsd_catalog, is_container='container', yang_name="nsd-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd_catalog must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nsd_catalog_nsd__nsd_catalog, is_container='container', yang_name="nsd-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)""",
        })

    self.__nsd_catalog = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd_catalog(self):
    self.__nsd_catalog = YANGDynClass(base=yc_nsd_catalog_nsd__nsd_catalog, is_container='container', yang_name="nsd-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nsd', defining_module='nsd', yang_type='container', is_config=True)

  nsd_catalog = __builtin__.property(_get_nsd_catalog, _set_nsd_catalog)


  _pyangbind_elements = OrderedDict([('nsd_catalog', nsd_catalog), ])


