# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six
 
# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_SNSSAI_identifier_nst__nst_SNSSAI_identifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/SNSSAI-identifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__slice_service_type','__slice_differentiator',)

  _yang_name = 'SNSSAI-identifier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__slice_differentiator = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slice-differentiator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__slice_service_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'URLLC': {}, u'eMBB': {}, u'mMTC': {}},), is_leaf=True, yang_name="slice-service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='network-slice-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'SNSSAI-identifier']

  def _get_slice_service_type(self):
    """
    Getter method for slice_service_type, mapped from YANG variable /nst/SNSSAI_identifier/slice_service_type (network-slice-type)

    YANG Description: Network slice service type 
    """
    return self.__slice_service_type
      
  def _set_slice_service_type(self, v, load=False):
    """
    Setter method for slice_service_type, mapped from YANG variable /nst/SNSSAI_identifier/slice_service_type (network-slice-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slice_service_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slice_service_type() directly.

    YANG Description: Network slice service type 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'URLLC': {}, u'eMBB': {}, u'mMTC': {}},), is_leaf=True, yang_name="slice-service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='network-slice-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slice_service_type must be of a type compatible with network-slice-type""",
          'defined-type': "nst:network-slice-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'URLLC': {}, u'eMBB': {}, u'mMTC': {}},), is_leaf=True, yang_name="slice-service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='network-slice-type', is_config=True)""",
        })

    self.__slice_service_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slice_service_type(self):
    self.__slice_service_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'URLLC': {}, u'eMBB': {}, u'mMTC': {}},), is_leaf=True, yang_name="slice-service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='network-slice-type', is_config=True)


  def _get_slice_differentiator(self):
    """
    Getter method for slice_differentiator, mapped from YANG variable /nst/SNSSAI_identifier/slice_differentiator (string)

    YANG Description: Network slice differentiator
    """
    return self.__slice_differentiator
      
  def _set_slice_differentiator(self, v, load=False):
    """
    Setter method for slice_differentiator, mapped from YANG variable /nst/SNSSAI_identifier/slice_differentiator (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slice_differentiator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slice_differentiator() directly.

    YANG Description: Network slice differentiator
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="slice-differentiator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slice_differentiator must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slice-differentiator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__slice_differentiator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slice_differentiator(self):
    self.__slice_differentiator = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slice-differentiator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

  slice_service_type = __builtin__.property(_get_slice_service_type, _set_slice_service_type)
  slice_differentiator = __builtin__.property(_get_slice_differentiator, _set_slice_differentiator)


  _pyangbind_elements = OrderedDict([('slice_service_type', slice_service_type), ('slice_differentiator', slice_differentiator), ])


class yc_quality_of_service_nst__nst_quality_of_service(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/quality-of-service. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__resource_type','__priority_level','__packet_delay_budget','__packet_error_rate','__default_max_data_burst',)

  _yang_name = 'quality-of-service'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__priority_level = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="priority-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)
    self.__default_max_data_burst = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="default-max-data-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)
    self.__packet_error_rate = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packet-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)
    self.__packet_delay_budget = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packet-delay-budget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)
    self.__resource_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'non-GBR': {}, u'GBR': {}, u'delay-critical-GBR': {}},), is_leaf=True, yang_name="resource-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='resource-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'quality-of-service']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nst/quality_of_service/id (uint16)

    YANG Description: Quality of service identifier
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nst/quality_of_service/id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Quality of service identifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)


  def _get_resource_type(self):
    """
    Getter method for resource_type, mapped from YANG variable /nst/quality_of_service/resource_type (resource-type)

    YANG Description: Quality of service resource type
    """
    return self.__resource_type
      
  def _set_resource_type(self, v, load=False):
    """
    Setter method for resource_type, mapped from YANG variable /nst/quality_of_service/resource_type (resource-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resource_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resource_type() directly.

    YANG Description: Quality of service resource type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'non-GBR': {}, u'GBR': {}, u'delay-critical-GBR': {}},), is_leaf=True, yang_name="resource-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='resource-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resource_type must be of a type compatible with resource-type""",
          'defined-type': "nst:resource-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'non-GBR': {}, u'GBR': {}, u'delay-critical-GBR': {}},), is_leaf=True, yang_name="resource-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='resource-type', is_config=True)""",
        })

    self.__resource_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resource_type(self):
    self.__resource_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'non-GBR': {}, u'GBR': {}, u'delay-critical-GBR': {}},), is_leaf=True, yang_name="resource-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='resource-type', is_config=True)


  def _get_priority_level(self):
    """
    Getter method for priority_level, mapped from YANG variable /nst/quality_of_service/priority_level (uint16)

    YANG Description: Priority level of the service
    """
    return self.__priority_level
      
  def _set_priority_level(self, v, load=False):
    """
    Setter method for priority_level, mapped from YANG variable /nst/quality_of_service/priority_level (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_level() directly.

    YANG Description: Priority level of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="priority-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_level must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="priority-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)""",
        })

    self.__priority_level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_level(self):
    self.__priority_level = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="priority-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)


  def _get_packet_delay_budget(self):
    """
    Getter method for packet_delay_budget, mapped from YANG variable /nst/quality_of_service/packet_delay_budget (uint16)

    YANG Description: Packet delay budget in miliseconds (ms)
    """
    return self.__packet_delay_budget
      
  def _set_packet_delay_budget(self, v, load=False):
    """
    Setter method for packet_delay_budget, mapped from YANG variable /nst/quality_of_service/packet_delay_budget (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_delay_budget is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_delay_budget() directly.

    YANG Description: Packet delay budget in miliseconds (ms)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packet-delay-budget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_delay_budget must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packet-delay-budget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)""",
        })

    self.__packet_delay_budget = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_delay_budget(self):
    self.__packet_delay_budget = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packet-delay-budget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)


  def _get_packet_error_rate(self):
    """
    Getter method for packet_error_rate, mapped from YANG variable /nst/quality_of_service/packet_error_rate (uint16)

    YANG Description: Packet error rate (PER) given in powers of ten
    """
    return self.__packet_error_rate
      
  def _set_packet_error_rate(self, v, load=False):
    """
    Setter method for packet_error_rate, mapped from YANG variable /nst/quality_of_service/packet_error_rate (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_error_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_error_rate() directly.

    YANG Description: Packet error rate (PER) given in powers of ten
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packet-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_error_rate must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packet-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)""",
        })

    self.__packet_error_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_error_rate(self):
    self.__packet_error_rate = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="packet-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)


  def _get_default_max_data_burst(self):
    """
    Getter method for default_max_data_burst, mapped from YANG variable /nst/quality_of_service/default_max_data_burst (uint16)

    YANG Description: Maximum data burst given in bytes (B)
    """
    return self.__default_max_data_burst
      
  def _set_default_max_data_burst(self, v, load=False):
    """
    Setter method for default_max_data_burst, mapped from YANG variable /nst/quality_of_service/default_max_data_burst (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_max_data_burst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_max_data_burst() directly.

    YANG Description: Maximum data burst given in bytes (B)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="default-max-data-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_max_data_burst must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="default-max-data-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)""",
        })

    self.__default_max_data_burst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_max_data_burst(self):
    self.__default_max_data_burst = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="default-max-data-burst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint16', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  resource_type = __builtin__.property(_get_resource_type, _set_resource_type)
  priority_level = __builtin__.property(_get_priority_level, _set_priority_level)
  packet_delay_budget = __builtin__.property(_get_packet_delay_budget, _set_packet_delay_budget)
  packet_error_rate = __builtin__.property(_get_packet_error_rate, _set_packet_error_rate)
  default_max_data_burst = __builtin__.property(_get_default_max_data_burst, _set_default_max_data_burst)


  _pyangbind_elements = OrderedDict([('id', id), ('resource_type', resource_type), ('priority_level', priority_level), ('packet_delay_budget', packet_delay_budget), ('packet_error_rate', packet_error_rate), ('default_max_data_burst', default_max_data_burst), ])


class yc_volume_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu_volume(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vnf/vdu/volume. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__vim_volume_id',)

  _yang_name = 'volume'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__vim_volume_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-volume-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vnf', u'vdu', u'volume']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/volume/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/volume/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_vim_volume_id(self):
    """
    Getter method for vim_volume_id, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/volume/vim_volume_id (string)
    """
    return self.__vim_volume_id
      
  def _set_vim_volume_id(self, v, load=False):
    """
    Setter method for vim_volume_id, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/volume/vim_volume_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_volume_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_volume_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vim-volume-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vim_volume_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-volume-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__vim_volume_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vim_volume_id(self):
    self.__vim_volume_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-volume-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  vim_volume_id = __builtin__.property(_get_vim_volume_id, _set_vim_volume_id)


  _pyangbind_elements = OrderedDict([('name', name), ('vim_volume_id', vim_volume_id), ])


class yc_interface_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vnf/vdu/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__ip_address','__mac_address','__floating_ip_required',)

  _yang_name = 'interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__floating_ip_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='ietf-yang:mac-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vnf', u'vdu', u'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/interface/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/interface/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/interface/ip_address (inet:ip-address)
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/interface/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/interface/mac_address (ietf-yang:mac-address)
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/interface/mac_address (ietf-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='ietf-yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with ietf-yang:mac-address""",
          'defined-type': "ietf-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='ietf-yang:mac-address', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='ietf-yang:mac-address', is_config=True)


  def _get_floating_ip_required(self):
    """
    Getter method for floating_ip_required, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/interface/floating_ip_required (boolean)
    """
    return self.__floating_ip_required
      
  def _set_floating_ip_required(self, v, load=False):
    """
    Setter method for floating_ip_required, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/interface/floating_ip_required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_required() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """floating_ip_required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)""",
        })

    self.__floating_ip_required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_floating_ip_required(self):
    self.__floating_ip_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  floating_ip_required = __builtin__.property(_get_floating_ip_required, _set_floating_ip_required)


  _pyangbind_elements = OrderedDict([('name', name), ('ip_address', ip_address), ('mac_address', mac_address), ('floating_ip_required', floating_ip_required), ])


class yc_vdu_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vnf/vdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__volume','__interface',)

  _yang_name = 'vdu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__volume = YANGDynClass(base=YANGListType("name",yc_volume_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu_volume, yang_name="volume", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="volume", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vnf', u'vdu']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_volume(self):
    """
    Getter method for volume, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/volume (list)
    """
    return self.__volume
      
  def _set_volume(self, v, load=False):
    """
    Setter method for volume, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/volume (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_volume is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_volume() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_volume_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu_volume, yang_name="volume", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="volume", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """volume must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_volume_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu_volume, yang_name="volume", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="volume", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__volume = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_volume(self):
    self.__volume = YANGDynClass(base=YANGListType("name",yc_volume_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu_volume, yang_name="volume", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="volume", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/interface (list)
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  volume = __builtin__.property(_get_volume, _set_volume)
  interface = __builtin__.property(_get_interface, _set_interface)


  _pyangbind_elements = OrderedDict([('id', id), ('volume', volume), ('interface', interface), ])


class yc_dns_server_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile_dns_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vnf/internal-vld/ip-profile/dns-server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'dns-server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vnf', u'internal-vld', u'ip-profile', u'dns-server']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dns_server/address (inet:ip-address)
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dns_server/address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_dhcp_params_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile_dhcp_params(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vnf/internal-vld/ip-profile/dhcp-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__count','__start_address',)

  _yang_name = 'dhcp-params'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)
    self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vnf', u'internal-vld', u'ip-profile', u'dhcp-params']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dhcp_params/enabled (boolean)
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dhcp_params/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dhcp_params/count (uint8)
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dhcp_params/count (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)


  def _get_start_address(self):
    """
    Getter method for start_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dhcp_params/start_address (inet:ip-address)
    """
    return self.__start_address
      
  def _set_start_address(self, v, load=False):
    """
    Setter method for start_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dhcp_params/start_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__start_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_address(self):
    self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  count = __builtin__.property(_get_count, _set_count)
  start_address = __builtin__.property(_get_start_address, _set_start_address)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('count', count), ('start_address', start_address), ])


class yc_ip_profile_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vnf/internal-vld/ip-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_version','__subnet_address','__gateway_address','__dns_server','__dhcp_params',)

  _yang_name = 'ip-profile'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-version', is_config=True)
    self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    self.__dns_server = YANGDynClass(base=YANGListType("address",yc_dns_server_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-prefix', is_config=True)
    self.__dhcp_params = YANGDynClass(base=yc_dhcp_params_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vnf', u'internal-vld', u'ip-profile']

  def _get_ip_version(self):
    """
    Getter method for ip_version, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/ip_version (inet:ip-version)
    """
    return self.__ip_version
      
  def _set_ip_version(self, v, load=False):
    """
    Setter method for ip_version, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/ip_version (inet:ip-version)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-version', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_version must be of a type compatible with inet:ip-version""",
          'defined-type': "inet:ip-version",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-version', is_config=True)""",
        })

    self.__ip_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_version(self):
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-version', is_config=True)


  def _get_subnet_address(self):
    """
    Getter method for subnet_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/subnet_address (inet:ip-prefix)
    """
    return self.__subnet_address
      
  def _set_subnet_address(self, v, load=False):
    """
    Setter method for subnet_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/subnet_address (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnet_address must be of a type compatible with inet:ip-prefix""",
          'defined-type': "inet:ip-prefix",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-prefix', is_config=True)""",
        })

    self.__subnet_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnet_address(self):
    self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-prefix', is_config=True)


  def _get_gateway_address(self):
    """
    Getter method for gateway_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/gateway_address (inet:ip-address)
    """
    return self.__gateway_address
      
  def _set_gateway_address(self, v, load=False):
    """
    Setter method for gateway_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/gateway_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__gateway_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway_address(self):
    self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)


  def _get_dns_server(self):
    """
    Getter method for dns_server, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dns_server (list)
    """
    return self.__dns_server
      
  def _set_dns_server(self, v, load=False):
    """
    Setter method for dns_server, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dns_server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_server() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address",yc_dns_server_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_server must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address",yc_dns_server_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__dns_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_server(self):
    self.__dns_server = YANGDynClass(base=YANGListType("address",yc_dns_server_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)


  def _get_dhcp_params(self):
    """
    Getter method for dhcp_params, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dhcp_params (container)
    """
    return self.__dhcp_params
      
  def _set_dhcp_params(self, v, load=False):
    """
    Setter method for dhcp_params, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile/dhcp_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_params() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dhcp_params_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_params must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dhcp_params_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)""",
        })

    self.__dhcp_params = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_params(self):
    self.__dhcp_params = YANGDynClass(base=yc_dhcp_params_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)

  ip_version = __builtin__.property(_get_ip_version, _set_ip_version)
  subnet_address = __builtin__.property(_get_subnet_address, _set_subnet_address)
  gateway_address = __builtin__.property(_get_gateway_address, _set_gateway_address)
  dns_server = __builtin__.property(_get_dns_server, _set_dns_server)
  dhcp_params = __builtin__.property(_get_dhcp_params, _set_dhcp_params)


  _pyangbind_elements = OrderedDict([('ip_version', ip_version), ('subnet_address', subnet_address), ('gateway_address', gateway_address), ('dns_server', dns_server), ('dhcp_params', dhcp_params), ])


class yc_internal_connection_point_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_internal_connection_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vnf/internal-vld/internal-connection-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id_ref','__ip_address',)

  _yang_name = 'internal-connection-point'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vnf', u'internal-vld', u'internal-connection-point']

  def _get_id_ref(self):
    """
    Getter method for id_ref, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/internal_connection_point/id_ref (string)
    """
    return self.__id_ref
      
  def _set_id_ref(self, v, load=False):
    """
    Setter method for id_ref, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/internal_connection_point/id_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id_ref() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id_ref(self):
    self.__id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/internal_connection_point/ip_address (inet:ip-address)
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/internal_connection_point/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

  id_ref = __builtin__.property(_get_id_ref, _set_id_ref)
  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)


  _pyangbind_elements = OrderedDict([('id_ref', id_ref), ('ip_address', ip_address), ])


class yc_internal_vld_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vnf/internal-vld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__vim_network_name','__ip_profile','__internal_connection_point',)

  _yang_name = 'internal-vld'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__internal_connection_point = YANGDynClass(base=YANGListType("id_ref",yc_internal_connection_point_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id-ref', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__vim_network_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__ip_profile = YANGDynClass(base=yc_ip_profile_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile, is_container='container', yang_name="ip-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vnf', u'internal-vld']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_vim_network_name(self):
    """
    Getter method for vim_network_name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/vim_network_name (string)
    """
    return self.__vim_network_name
      
  def _set_vim_network_name(self, v, load=False):
    """
    Setter method for vim_network_name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/vim_network_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_network_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_network_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vim_network_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__vim_network_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vim_network_name(self):
    self.__vim_network_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_ip_profile(self):
    """
    Getter method for ip_profile, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile (container)
    """
    return self.__ip_profile
      
  def _set_ip_profile(self, v, load=False):
    """
    Setter method for ip_profile, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/ip_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profile() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ip_profile_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile, is_container='container', yang_name="ip-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_profile must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ip_profile_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile, is_container='container', yang_name="ip-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)""",
        })

    self.__ip_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_profile(self):
    self.__ip_profile = YANGDynClass(base=yc_ip_profile_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_ip_profile, is_container='container', yang_name="ip-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)


  def _get_internal_connection_point(self):
    """
    Getter method for internal_connection_point, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/internal_connection_point (list)
    """
    return self.__internal_connection_point
      
  def _set_internal_connection_point(self, v, load=False):
    """
    Setter method for internal_connection_point, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld/internal_connection_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_connection_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_connection_point() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id_ref",yc_internal_connection_point_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id-ref', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """internal_connection_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id_ref",yc_internal_connection_point_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id-ref', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__internal_connection_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_internal_connection_point(self):
    self.__internal_connection_point = YANGDynClass(base=YANGListType("id_ref",yc_internal_connection_point_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id-ref', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  vim_network_name = __builtin__.property(_get_vim_network_name, _set_vim_network_name)
  ip_profile = __builtin__.property(_get_ip_profile, _set_ip_profile)
  internal_connection_point = __builtin__.property(_get_internal_connection_point, _set_internal_connection_point)


  _pyangbind_elements = OrderedDict([('name', name), ('vim_network_name', vim_network_name), ('ip_profile', ip_profile), ('internal_connection_point', internal_connection_point), ])


class yc_vnf_nst__nst_netslice_subnet_instantiation_parameters_vnf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vnf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__member_vnf_index','__vimAccountId','__vdu','__internal_vld',)

  _yang_name = 'vnf'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__member_vnf_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__internal_vld = YANGDynClass(base=YANGListType("name",yc_internal_vld_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld, yang_name="internal-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="internal-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__vdu = YANGDynClass(base=YANGListType("id",yc_vdu_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__vimAccountId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vimAccountId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vnf']

  def _get_member_vnf_index(self):
    """
    Getter method for member_vnf_index, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/member_vnf_index (string)
    """
    return self.__member_vnf_index
      
  def _set_member_vnf_index(self, v, load=False):
    """
    Setter method for member_vnf_index, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/member_vnf_index (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vnf-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnf_index must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__member_vnf_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnf_index(self):
    self.__member_vnf_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_vimAccountId(self):
    """
    Getter method for vimAccountId, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vimAccountId (string)
    """
    return self.__vimAccountId
      
  def _set_vimAccountId(self, v, load=False):
    """
    Setter method for vimAccountId, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vimAccountId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vimAccountId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vimAccountId() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vimAccountId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vimAccountId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vimAccountId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__vimAccountId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vimAccountId(self):
    self.__vimAccountId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vimAccountId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_vdu(self):
    """
    Getter method for vdu, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu (list)
    """
    return self.__vdu
      
  def _set_vdu(self, v, load=False):
    """
    Setter method for vdu, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/vdu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_vdu_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_vdu_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__vdu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu(self):
    self.__vdu = YANGDynClass(base=YANGListType("id",yc_vdu_nst__nst_netslice_subnet_instantiation_parameters_vnf_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)


  def _get_internal_vld(self):
    """
    Getter method for internal_vld, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld (list)
    """
    return self.__internal_vld
      
  def _set_internal_vld(self, v, load=False):
    """
    Setter method for internal_vld, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf/internal_vld (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_vld is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_vld() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_internal_vld_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld, yang_name="internal-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="internal-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """internal_vld must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_internal_vld_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld, yang_name="internal-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="internal-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__internal_vld = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_internal_vld(self):
    self.__internal_vld = YANGDynClass(base=YANGListType("name",yc_internal_vld_nst__nst_netslice_subnet_instantiation_parameters_vnf_internal_vld, yang_name="internal-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="internal-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

  member_vnf_index = __builtin__.property(_get_member_vnf_index, _set_member_vnf_index)
  vimAccountId = __builtin__.property(_get_vimAccountId, _set_vimAccountId)
  vdu = __builtin__.property(_get_vdu, _set_vdu)
  internal_vld = __builtin__.property(_get_internal_vld, _set_internal_vld)


  _pyangbind_elements = OrderedDict([('member_vnf_index', member_vnf_index), ('vimAccountId', vimAccountId), ('vdu', vdu), ('internal_vld', internal_vld), ])


class yc_dns_server_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile_dns_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vld/ip-profile/dns-server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'dns-server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vld', u'ip-profile', u'dns-server']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dns_server/address (inet:ip-address)
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dns_server/address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_dhcp_params_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile_dhcp_params(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vld/ip-profile/dhcp-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__count','__start_address',)

  _yang_name = 'dhcp-params'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)
    self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vld', u'ip-profile', u'dhcp-params']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dhcp_params/enabled (boolean)
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dhcp_params/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dhcp_params/count (uint8)
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dhcp_params/count (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)


  def _get_start_address(self):
    """
    Getter method for start_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dhcp_params/start_address (inet:ip-address)
    """
    return self.__start_address
      
  def _set_start_address(self, v, load=False):
    """
    Setter method for start_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dhcp_params/start_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__start_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_address(self):
    self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  count = __builtin__.property(_get_count, _set_count)
  start_address = __builtin__.property(_get_start_address, _set_start_address)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('count', count), ('start_address', start_address), ])


class yc_ip_profile_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vld/ip-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_version','__subnet_address','__gateway_address','__dns_server','__dhcp_params',)

  _yang_name = 'ip-profile'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-version', is_config=True)
    self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    self.__dns_server = YANGDynClass(base=YANGListType("address",yc_dns_server_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-prefix', is_config=True)
    self.__dhcp_params = YANGDynClass(base=yc_dhcp_params_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vld', u'ip-profile']

  def _get_ip_version(self):
    """
    Getter method for ip_version, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/ip_version (inet:ip-version)
    """
    return self.__ip_version
      
  def _set_ip_version(self, v, load=False):
    """
    Setter method for ip_version, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/ip_version (inet:ip-version)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-version', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_version must be of a type compatible with inet:ip-version""",
          'defined-type': "inet:ip-version",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-version', is_config=True)""",
        })

    self.__ip_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_version(self):
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-version', is_config=True)


  def _get_subnet_address(self):
    """
    Getter method for subnet_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/subnet_address (inet:ip-prefix)
    """
    return self.__subnet_address
      
  def _set_subnet_address(self, v, load=False):
    """
    Setter method for subnet_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/subnet_address (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnet_address must be of a type compatible with inet:ip-prefix""",
          'defined-type': "inet:ip-prefix",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-prefix', is_config=True)""",
        })

    self.__subnet_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnet_address(self):
    self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-prefix', is_config=True)


  def _get_gateway_address(self):
    """
    Getter method for gateway_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/gateway_address (inet:ip-address)
    """
    return self.__gateway_address
      
  def _set_gateway_address(self, v, load=False):
    """
    Setter method for gateway_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/gateway_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__gateway_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway_address(self):
    self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)


  def _get_dns_server(self):
    """
    Getter method for dns_server, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dns_server (list)
    """
    return self.__dns_server
      
  def _set_dns_server(self, v, load=False):
    """
    Setter method for dns_server, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dns_server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_server() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address",yc_dns_server_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_server must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address",yc_dns_server_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__dns_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_server(self):
    self.__dns_server = YANGDynClass(base=YANGListType("address",yc_dns_server_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)


  def _get_dhcp_params(self):
    """
    Getter method for dhcp_params, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dhcp_params (container)
    """
    return self.__dhcp_params
      
  def _set_dhcp_params(self, v, load=False):
    """
    Setter method for dhcp_params, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile/dhcp_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_params() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dhcp_params_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_params must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dhcp_params_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)""",
        })

    self.__dhcp_params = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_params(self):
    self.__dhcp_params = YANGDynClass(base=yc_dhcp_params_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)

  ip_version = __builtin__.property(_get_ip_version, _set_ip_version)
  subnet_address = __builtin__.property(_get_subnet_address, _set_subnet_address)
  gateway_address = __builtin__.property(_get_gateway_address, _set_gateway_address)
  dns_server = __builtin__.property(_get_dns_server, _set_dns_server)
  dhcp_params = __builtin__.property(_get_dhcp_params, _set_dhcp_params)


  _pyangbind_elements = OrderedDict([('ip_version', ip_version), ('subnet_address', subnet_address), ('gateway_address', gateway_address), ('dns_server', dns_server), ('dhcp_params', dhcp_params), ])


class yc_vnfd_connection_point_ref_nst__nst_netslice_subnet_instantiation_parameters_vld_vnfd_connection_point_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vld/vnfd-connection-point-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__member_vnf_index_ref','__vnfd_connection_point_ref','__ip_address',)

  _yang_name = 'vnfd-connection-point-ref'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnfd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vld', u'vnfd-connection-point-ref']

  def _get_member_vnf_index_ref(self):
    """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/vnfd_connection_point_ref/member_vnf_index_ref (leafref)
    """
    return self.__member_vnf_index_ref
      
  def _set_member_vnf_index_ref(self, v, load=False):
    """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/vnfd_connection_point_ref/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vnf_index_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__member_vnf_index_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vnf_index_ref(self):
    self.__member_vnf_index_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)


  def _get_vnfd_connection_point_ref(self):
    """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/vnfd_connection_point_ref/vnfd_connection_point_ref (leafref)
    """
    return self.__vnfd_connection_point_ref
      
  def _set_vnfd_connection_point_ref(self, v, load=False):
    """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/vnfd_connection_point_ref/vnfd_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__vnfd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_connection_point_ref(self):
    self.__vnfd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/vnfd_connection_point_ref/ip_address (inet:ip-address)
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/vnfd_connection_point_ref/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

  member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref, _set_member_vnf_index_ref)
  vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref, _set_vnfd_connection_point_ref)
  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)


  _pyangbind_elements = OrderedDict([('member_vnf_index_ref', member_vnf_index_ref), ('vnfd_connection_point_ref', vnfd_connection_point_ref), ('ip_address', ip_address), ])


class yc_vld_nst__nst_netslice_subnet_instantiation_parameters_vld(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters/vld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__vim_network_name','__ip_profile','__vnfd_connection_point_ref',)

  _yang_name = 'vld'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnfd_connection_point_ref = YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref",yc_vnfd_connection_point_ref_nst__nst_netslice_subnet_instantiation_parameters_vld_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-connection-point-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__vim_network_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__ip_profile = YANGDynClass(base=yc_ip_profile_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile, is_container='container', yang_name="ip-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters', u'vld']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_vim_network_name(self):
    """
    Getter method for vim_network_name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/vim_network_name (string)
    """
    return self.__vim_network_name
      
  def _set_vim_network_name(self, v, load=False):
    """
    Setter method for vim_network_name, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/vim_network_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_network_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_network_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vim_network_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__vim_network_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vim_network_name(self):
    self.__vim_network_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_ip_profile(self):
    """
    Getter method for ip_profile, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile (container)
    """
    return self.__ip_profile
      
  def _set_ip_profile(self, v, load=False):
    """
    Setter method for ip_profile, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/ip_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profile() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ip_profile_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile, is_container='container', yang_name="ip-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_profile must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ip_profile_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile, is_container='container', yang_name="ip-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)""",
        })

    self.__ip_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_profile(self):
    self.__ip_profile = YANGDynClass(base=yc_ip_profile_nst__nst_netslice_subnet_instantiation_parameters_vld_ip_profile, is_container='container', yang_name="ip-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)


  def _get_vnfd_connection_point_ref(self):
    """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/vnfd_connection_point_ref (list)
    """
    return self.__vnfd_connection_point_ref
      
  def _set_vnfd_connection_point_ref(self, v, load=False):
    """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld/vnfd_connection_point_ref (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref",yc_vnfd_connection_point_ref_nst__nst_netslice_subnet_instantiation_parameters_vld_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-connection-point-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_connection_point_ref must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref",yc_vnfd_connection_point_ref_nst__nst_netslice_subnet_instantiation_parameters_vld_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-connection-point-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__vnfd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_connection_point_ref(self):
    self.__vnfd_connection_point_ref = YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref",yc_vnfd_connection_point_ref_nst__nst_netslice_subnet_instantiation_parameters_vld_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-connection-point-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  vim_network_name = __builtin__.property(_get_vim_network_name, _set_vim_network_name)
  ip_profile = __builtin__.property(_get_ip_profile, _set_ip_profile)
  vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref, _set_vnfd_connection_point_ref)


  _pyangbind_elements = OrderedDict([('name', name), ('vim_network_name', vim_network_name), ('ip_profile', ip_profile), ('vnfd_connection_point_ref', vnfd_connection_point_ref), ])


class yc_instantiation_parameters_nst__nst_netslice_subnet_instantiation_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet/instantiation-parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vimAccountId','__ssh_keys','__vnf','__vld',)

  _yang_name = 'instantiation-parameters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnf = YANGDynClass(base=YANGListType("member_vnf_index",yc_vnf_nst__nst_netslice_subnet_instantiation_parameters_vnf, yang_name="vnf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index', extensions=None), is_container='list', yang_name="vnf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__ssh_keys = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssh_keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__vimAccountId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vimAccountId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__vld = YANGDynClass(base=YANGListType("name",yc_vld_nst__nst_netslice_subnet_instantiation_parameters_vld, yang_name="vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet', u'instantiation-parameters']

  def _get_vimAccountId(self):
    """
    Getter method for vimAccountId, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vimAccountId (string)
    """
    return self.__vimAccountId
      
  def _set_vimAccountId(self, v, load=False):
    """
    Setter method for vimAccountId, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vimAccountId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vimAccountId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vimAccountId() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vimAccountId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vimAccountId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vimAccountId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__vimAccountId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vimAccountId(self):
    self.__vimAccountId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vimAccountId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_ssh_keys(self):
    """
    Getter method for ssh_keys, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/ssh_keys (string)
    """
    return self.__ssh_keys
      
  def _set_ssh_keys(self, v, load=False):
    """
    Setter method for ssh_keys, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/ssh_keys (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_keys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_keys() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ssh_keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_keys must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssh_keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__ssh_keys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_keys(self):
    self.__ssh_keys = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ssh_keys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_vnf(self):
    """
    Getter method for vnf, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf (list)
    """
    return self.__vnf
      
  def _set_vnf(self, v, load=False):
    """
    Setter method for vnf, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vnf (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("member_vnf_index",yc_vnf_nst__nst_netslice_subnet_instantiation_parameters_vnf, yang_name="vnf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index', extensions=None), is_container='list', yang_name="vnf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index",yc_vnf_nst__nst_netslice_subnet_instantiation_parameters_vnf, yang_name="vnf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index', extensions=None), is_container='list', yang_name="vnf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__vnf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf(self):
    self.__vnf = YANGDynClass(base=YANGListType("member_vnf_index",yc_vnf_nst__nst_netslice_subnet_instantiation_parameters_vnf, yang_name="vnf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index', extensions=None), is_container='list', yang_name="vnf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)


  def _get_vld(self):
    """
    Getter method for vld, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld (list)
    """
    return self.__vld
      
  def _set_vld(self, v, load=False):
    """
    Setter method for vld, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters/vld (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vld is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vld() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_vld_nst__nst_netslice_subnet_instantiation_parameters_vld, yang_name="vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vld must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_vld_nst__nst_netslice_subnet_instantiation_parameters_vld, yang_name="vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__vld = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vld(self):
    self.__vld = YANGDynClass(base=YANGListType("name",yc_vld_nst__nst_netslice_subnet_instantiation_parameters_vld, yang_name="vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

  vimAccountId = __builtin__.property(_get_vimAccountId, _set_vimAccountId)
  ssh_keys = __builtin__.property(_get_ssh_keys, _set_ssh_keys)
  vnf = __builtin__.property(_get_vnf, _set_vnf)
  vld = __builtin__.property(_get_vld, _set_vld)


  _pyangbind_elements = OrderedDict([('vimAccountId', vimAccountId), ('ssh_keys', ssh_keys), ('vnf', vnf), ('vld', vld), ])


class yc_netslice_subnet_nst__nst_netslice_subnet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-subnet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__description','__is_shared_nss','__nsd_ref','__instantiation_parameters',)

  _yang_name = 'netslice-subnet'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instantiation_parameters = YANGDynClass(base=yc_instantiation_parameters_nst__nst_netslice_subnet_instantiation_parameters, is_container='container', yang_name="instantiation-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    self.__nsd_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    self.__is_shared_nss = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-shared-nss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-subnet']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nst/netslice_subnet/id (string)

    YANG Description: Identifier or name for the netslice-subnet in NST scope.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nst/netslice_subnet/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier or name for the netslice-subnet in NST scope.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /nst/netslice_subnet/description (string)

    YANG Description: Description of the NSD.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /nst/netslice_subnet/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the NSD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_is_shared_nss(self):
    """
    Getter method for is_shared_nss, mapped from YANG variable /nst/netslice_subnet/is_shared_nss (boolean)

    YANG Description: NSS is shared between NS
    """
    return self.__is_shared_nss
      
  def _set_is_shared_nss(self, v, load=False):
    """
    Setter method for is_shared_nss, mapped from YANG variable /nst/netslice_subnet/is_shared_nss (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_shared_nss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_shared_nss() directly.

    YANG Description: NSS is shared between NS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-shared-nss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_shared_nss must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-shared-nss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)""",
        })

    self.__is_shared_nss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_shared_nss(self):
    self.__is_shared_nss = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-shared-nss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)


  def _get_nsd_ref(self):
    """
    Getter method for nsd_ref, mapped from YANG variable /nst/netslice_subnet/nsd_ref (leafref)

    YANG Description: Reference to catalog NSD
    """
    return self.__nsd_ref
      
  def _set_nsd_ref(self, v, load=False):
    """
    Setter method for nsd_ref, mapped from YANG variable /nst/netslice_subnet/nsd_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_ref() directly.

    YANG Description: Reference to catalog NSD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__nsd_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd_ref(self):
    self.__nsd_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)


  def _get_instantiation_parameters(self):
    """
    Getter method for instantiation_parameters, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters (container)
    """
    return self.__instantiation_parameters
      
  def _set_instantiation_parameters(self, v, load=False):
    """
    Setter method for instantiation_parameters, mapped from YANG variable /nst/netslice_subnet/instantiation_parameters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instantiation_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instantiation_parameters() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_instantiation_parameters_nst__nst_netslice_subnet_instantiation_parameters, is_container='container', yang_name="instantiation-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instantiation_parameters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_instantiation_parameters_nst__nst_netslice_subnet_instantiation_parameters, is_container='container', yang_name="instantiation-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)""",
        })

    self.__instantiation_parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instantiation_parameters(self):
    self.__instantiation_parameters = YANGDynClass(base=yc_instantiation_parameters_nst__nst_netslice_subnet_instantiation_parameters, is_container='container', yang_name="instantiation-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  description = __builtin__.property(_get_description, _set_description)
  is_shared_nss = __builtin__.property(_get_is_shared_nss, _set_is_shared_nss)
  nsd_ref = __builtin__.property(_get_nsd_ref, _set_nsd_ref)
  instantiation_parameters = __builtin__.property(_get_instantiation_parameters, _set_instantiation_parameters)


  _pyangbind_elements = OrderedDict([('id', id), ('description', description), ('is_shared_nss', is_shared_nss), ('nsd_ref', nsd_ref), ('instantiation_parameters', instantiation_parameters), ])


class yc_netslice_connection_point_nst__nst_netslice_connection_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-connection-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__floating_ip_required','__netslice_vld_id_ref','__nsd_id_ref','__nsd_connection_point_ref',)

  _yang_name = 'netslice-connection-point'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nsd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id-ref", parent=self, choice=(u'connection', u'nsd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    self.__floating_ip_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)
    self.__nsd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, choice=(u'connection', u'nsd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__netslice_vld_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="netslice-vld-id-ref", parent=self, choice=(u'connection', u'netslice-vld-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-connection-point']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nst/netslice_connection_point/name (string)

    YANG Description: Name of the connection point.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nst/netslice_connection_point/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the connection point.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_floating_ip_required(self):
    """
    Getter method for floating_ip_required, mapped from YANG variable /nst/netslice_connection_point/floating_ip_required (boolean)

    YANG Description: Boolean parameter to indicate whether the CP must be exposed.
A public IP address will be allocated to this CP if exposed is true.
The default is false meaning a floating IP address is not required.
It must be explicitly asked for a floating IP address to be allocated.
    """
    return self.__floating_ip_required
      
  def _set_floating_ip_required(self, v, load=False):
    """
    Setter method for floating_ip_required, mapped from YANG variable /nst/netslice_connection_point/floating_ip_required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_required() directly.

    YANG Description: Boolean parameter to indicate whether the CP must be exposed.
A public IP address will be allocated to this CP if exposed is true.
The default is false meaning a floating IP address is not required.
It must be explicitly asked for a floating IP address to be allocated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """floating_ip_required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)""",
        })

    self.__floating_ip_required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_floating_ip_required(self):
    self.__floating_ip_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)


  def _get_netslice_vld_id_ref(self):
    """
    Getter method for netslice_vld_id_ref, mapped from YANG variable /nst/netslice_connection_point/netslice_vld_id_ref (leafref)

    YANG Description: ID reference to a NSVLD in the NS
    """
    return self.__netslice_vld_id_ref
      
  def _set_netslice_vld_id_ref(self, v, load=False):
    """
    Setter method for netslice_vld_id_ref, mapped from YANG variable /nst/netslice_connection_point/netslice_vld_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netslice_vld_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netslice_vld_id_ref() directly.

    YANG Description: ID reference to a NSVLD in the NS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="netslice-vld-id-ref", parent=self, choice=(u'connection', u'netslice-vld-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netslice_vld_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="netslice-vld-id-ref", parent=self, choice=(u'connection', u'netslice-vld-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__netslice_vld_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netslice_vld_id_ref(self):
    self.__netslice_vld_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="netslice-vld-id-ref", parent=self, choice=(u'connection', u'netslice-vld-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)


  def _get_nsd_id_ref(self):
    """
    Getter method for nsd_id_ref, mapped from YANG variable /nst/netslice_connection_point/nsd_id_ref (leafref)

    YANG Description: A reference to a nsd.
    """
    return self.__nsd_id_ref
      
  def _set_nsd_id_ref(self, v, load=False):
    """
    Setter method for nsd_id_ref, mapped from YANG variable /nst/netslice_connection_point/nsd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_id_ref() directly.

    YANG Description: A reference to a nsd.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nsd-id-ref", parent=self, choice=(u'connection', u'nsd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id-ref", parent=self, choice=(u'connection', u'nsd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__nsd_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd_id_ref(self):
    self.__nsd_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id-ref", parent=self, choice=(u'connection', u'nsd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)


  def _get_nsd_connection_point_ref(self):
    """
    Getter method for nsd_connection_point_ref, mapped from YANG variable /nst/netslice_connection_point/nsd_connection_point_ref (leafref)
    """
    return self.__nsd_connection_point_ref
      
  def _set_nsd_connection_point_ref(self, v, load=False):
    """
    Setter method for nsd_connection_point_ref, mapped from YANG variable /nst/netslice_connection_point/nsd_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_connection_point_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, choice=(u'connection', u'nsd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, choice=(u'connection', u'nsd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__nsd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd_connection_point_ref(self):
    self.__nsd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, choice=(u'connection', u'nsd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  floating_ip_required = __builtin__.property(_get_floating_ip_required, _set_floating_ip_required)
  netslice_vld_id_ref = __builtin__.property(_get_netslice_vld_id_ref, _set_netslice_vld_id_ref)
  nsd_id_ref = __builtin__.property(_get_nsd_id_ref, _set_nsd_id_ref)
  nsd_connection_point_ref = __builtin__.property(_get_nsd_connection_point_ref, _set_nsd_connection_point_ref)

  __choices__ = {u'connection': {u'netslice-vld-ref': [u'netslice_vld_id_ref'], u'nsd-connection-point-ref': [u'nsd_id_ref', u'nsd_connection_point_ref']}}
  _pyangbind_elements = OrderedDict([('name', name), ('floating_ip_required', floating_ip_required), ('netslice_vld_id_ref', netslice_vld_id_ref), ('nsd_id_ref', nsd_id_ref), ('nsd_connection_point_ref', nsd_connection_point_ref), ])


class yc_provider_network_nst__nst_netslice_vld_provider_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-vld/provider-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the provider network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__physical_network','__segmentation_id',)

  _yang_name = 'provider-network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__segmentation_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint32', is_config=True)
    self.__physical_network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-vld', u'provider-network']

  def _get_physical_network(self):
    """
    Getter method for physical_network, mapped from YANG variable /nst/netslice_vld/provider_network/physical_network (string)

    YANG Description: Name of the physical network on which the provider
network is built.
    """
    return self.__physical_network
      
  def _set_physical_network(self, v, load=False):
    """
    Setter method for physical_network, mapped from YANG variable /nst/netslice_vld/provider_network/physical_network (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_network() directly.

    YANG Description: Name of the physical network on which the provider
network is built.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_network must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__physical_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_network(self):
    self.__physical_network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_segmentation_id(self):
    """
    Getter method for segmentation_id, mapped from YANG variable /nst/netslice_vld/provider_network/segmentation_id (uint32)

    YANG Description: ID of segregated virtual networks
    """
    return self.__segmentation_id
      
  def _set_segmentation_id(self, v, load=False):
    """
    Setter method for segmentation_id, mapped from YANG variable /nst/netslice_vld/provider_network/segmentation_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segmentation_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segmentation_id() directly.

    YANG Description: ID of segregated virtual networks
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """segmentation_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint32', is_config=True)""",
        })

    self.__segmentation_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_segmentation_id(self):
    self.__segmentation_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint32', is_config=True)

  physical_network = __builtin__.property(_get_physical_network, _set_physical_network)
  segmentation_id = __builtin__.property(_get_segmentation_id, _set_segmentation_id)


  _pyangbind_elements = OrderedDict([('physical_network', physical_network), ('segmentation_id', segmentation_id), ])


class yc_nss_connection_point_ref_nst__nst_netslice_vld_nss_connection_point_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-vld/nss-connection-point-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of references to connection points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nss_ref','__nsd_connection_point_ref','__ip_address',)

  _yang_name = 'nss-connection-point-ref'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nss_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nss-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    self.__nsd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-vld', u'nss-connection-point-ref']

  def _get_nss_ref(self):
    """
    Getter method for nss_ref, mapped from YANG variable /nst/netslice_vld/nss_connection_point_ref/nss_ref (leafref)

    YANG Description: Reference to nsd
    """
    return self.__nss_ref
      
  def _set_nss_ref(self, v, load=False):
    """
    Setter method for nss_ref, mapped from YANG variable /nst/netslice_vld/nss_connection_point_ref/nss_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nss_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nss_ref() directly.

    YANG Description: Reference to nsd
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nss-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nss_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nss-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__nss_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nss_ref(self):
    self.__nss_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nss-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)


  def _get_nsd_connection_point_ref(self):
    """
    Getter method for nsd_connection_point_ref, mapped from YANG variable /nst/netslice_vld/nss_connection_point_ref/nsd_connection_point_ref (leafref)

    YANG Description: A reference to a connection point name
    """
    return self.__nsd_connection_point_ref
      
  def _set_nsd_connection_point_ref(self, v, load=False):
    """
    Setter method for nsd_connection_point_ref, mapped from YANG variable /nst/netslice_vld/nss_connection_point_ref/nsd_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__nsd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd_connection_point_ref(self):
    self.__nsd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /nst/netslice_vld/nss_connection_point_ref/ip_address (inet:ip-address)

    YANG Description: IP address of the connection point
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /nst/netslice_vld/nss_connection_point_ref/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address of the connection point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)

  nss_ref = __builtin__.property(_get_nss_ref, _set_nss_ref)
  nsd_connection_point_ref = __builtin__.property(_get_nsd_connection_point_ref, _set_nsd_connection_point_ref)
  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)


  _pyangbind_elements = OrderedDict([('nss_ref', nss_ref), ('nsd_connection_point_ref', nsd_connection_point_ref), ('ip_address', ip_address), ])


class yc_netslice_vld_nst__nst_netslice_vld(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslice-vld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__short_name','__vendor','__description','__version','__type','__root_bandwidth','__leaf_bandwidth','__provider_network','__mgmt_network','__nss_connection_point_ref',)

  _yang_name = 'netslice-vld'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint64', is_config=True)
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint64', is_config=True)
    self.__provider_network = YANGDynClass(base=yc_provider_network_nst__nst_netslice_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    self.__mgmt_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__nss_connection_point_ref = YANGDynClass(base=YANGListType("nss_ref nsd_connection_point_ref",yc_nss_connection_point_ref_nst__nst_netslice_vld_nss_connection_point_ref, yang_name="nss-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nss-ref nsd-connection-point-ref', extensions=None), is_container='list', yang_name="nss-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='manotypes:virtual-link-type', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslice-vld']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nst/netslice_vld/id (string)

    YANG Description: Identifier for the VLD.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nst/netslice_vld/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the VLD.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nst/netslice_vld/name (string)

    YANG Description: Virtual Link Descriptor (VLD) name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nst/netslice_vld/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Virtual Link Descriptor (VLD) name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /nst/netslice_vld/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /nst/netslice_vld/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_vendor(self):
    """
    Getter method for vendor, mapped from YANG variable /nst/netslice_vld/vendor (string)

    YANG Description: Provider of the VLD.
    """
    return self.__vendor
      
  def _set_vendor(self, v, load=False):
    """
    Setter method for vendor, mapped from YANG variable /nst/netslice_vld/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Provider of the VLD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor(self):
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /nst/netslice_vld/description (string)

    YANG Description: Description of the VLD.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /nst/netslice_vld/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the VLD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /nst/netslice_vld/version (string)

    YANG Description: Version of the VLD
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /nst/netslice_vld/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the VLD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /nst/netslice_vld/type (manotypes:virtual-link-type)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /nst/netslice_vld/type (manotypes:virtual-link-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='manotypes:virtual-link-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with manotypes:virtual-link-type""",
          'defined-type': "manotypes:virtual-link-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='manotypes:virtual-link-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='manotypes:virtual-link-type', is_config=True)


  def _get_root_bandwidth(self):
    """
    Getter method for root_bandwidth, mapped from YANG variable /nst/netslice_vld/root_bandwidth (uint64)

    YANG Description: For ELAN this is the aggregate bandwidth.
    """
    return self.__root_bandwidth
      
  def _set_root_bandwidth(self, v, load=False):
    """
    Setter method for root_bandwidth, mapped from YANG variable /nst/netslice_vld/root_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_bandwidth() directly.

    YANG Description: For ELAN this is the aggregate bandwidth.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """root_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint64', is_config=True)""",
        })

    self.__root_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_root_bandwidth(self):
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint64', is_config=True)


  def _get_leaf_bandwidth(self):
    """
    Getter method for leaf_bandwidth, mapped from YANG variable /nst/netslice_vld/leaf_bandwidth (uint64)

    YANG Description: For ELAN this is the bandwidth of branches.
    """
    return self.__leaf_bandwidth
      
  def _set_leaf_bandwidth(self, v, load=False):
    """
    Setter method for leaf_bandwidth, mapped from YANG variable /nst/netslice_vld/leaf_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf_bandwidth() directly.

    YANG Description: For ELAN this is the bandwidth of branches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leaf_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint64', is_config=True)""",
        })

    self.__leaf_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leaf_bandwidth(self):
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint64', is_config=True)


  def _get_provider_network(self):
    """
    Getter method for provider_network, mapped from YANG variable /nst/netslice_vld/provider_network (container)

    YANG Description: Container for the provider network.
    """
    return self.__provider_network
      
  def _set_provider_network(self, v, load=False):
    """
    Setter method for provider_network, mapped from YANG variable /nst/netslice_vld/provider_network (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_network() directly.

    YANG Description: Container for the provider network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_provider_network_nst__nst_netslice_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provider_network must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_provider_network_nst__nst_netslice_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)""",
        })

    self.__provider_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provider_network(self):
    self.__provider_network = YANGDynClass(base=yc_provider_network_nst__nst_netslice_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)


  def _get_mgmt_network(self):
    """
    Getter method for mgmt_network, mapped from YANG variable /nst/netslice_vld/mgmt_network (boolean)

    YANG Description: Flag indicating whether this network is a VIM management network
    """
    return self.__mgmt_network
      
  def _set_mgmt_network(self, v, load=False):
    """
    Setter method for mgmt_network, mapped from YANG variable /nst/netslice_vld/mgmt_network (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_network() directly.

    YANG Description: Flag indicating whether this network is a VIM management network
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_network must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)""",
        })

    self.__mgmt_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_network(self):
    self.__mgmt_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='boolean', is_config=True)


  def _get_nss_connection_point_ref(self):
    """
    Getter method for nss_connection_point_ref, mapped from YANG variable /nst/netslice_vld/nss_connection_point_ref (list)

    YANG Description: A list of references to connection points.
    """
    return self.__nss_connection_point_ref
      
  def _set_nss_connection_point_ref(self, v, load=False):
    """
    Setter method for nss_connection_point_ref, mapped from YANG variable /nst/netslice_vld/nss_connection_point_ref (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nss_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nss_connection_point_ref() directly.

    YANG Description: A list of references to connection points.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("nss_ref nsd_connection_point_ref",yc_nss_connection_point_ref_nst__nst_netslice_vld_nss_connection_point_ref, yang_name="nss-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nss-ref nsd-connection-point-ref', extensions=None), is_container='list', yang_name="nss-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nss_connection_point_ref must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("nss_ref nsd_connection_point_ref",yc_nss_connection_point_ref_nst__nst_netslice_vld_nss_connection_point_ref, yang_name="nss-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nss-ref nsd-connection-point-ref', extensions=None), is_container='list', yang_name="nss-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__nss_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nss_connection_point_ref(self):
    self.__nss_connection_point_ref = YANGDynClass(base=YANGListType("nss_ref nsd_connection_point_ref",yc_nss_connection_point_ref_nst__nst_netslice_vld_nss_connection_point_ref, yang_name="nss-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nss-ref nsd-connection-point-ref', extensions=None), is_container='list', yang_name="nss-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  vendor = __builtin__.property(_get_vendor, _set_vendor)
  description = __builtin__.property(_get_description, _set_description)
  version = __builtin__.property(_get_version, _set_version)
  type = __builtin__.property(_get_type, _set_type)
  root_bandwidth = __builtin__.property(_get_root_bandwidth, _set_root_bandwidth)
  leaf_bandwidth = __builtin__.property(_get_leaf_bandwidth, _set_leaf_bandwidth)
  provider_network = __builtin__.property(_get_provider_network, _set_provider_network)
  mgmt_network = __builtin__.property(_get_mgmt_network, _set_mgmt_network)
  nss_connection_point_ref = __builtin__.property(_get_nss_connection_point_ref, _set_nss_connection_point_ref)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('short_name', short_name), ('vendor', vendor), ('description', description), ('version', version), ('type', type), ('root_bandwidth', root_bandwidth), ('leaf_bandwidth', leaf_bandwidth), ('provider_network', provider_network), ('mgmt_network', mgmt_network), ('nss_connection_point_ref', nss_connection_point_ref), ])


class yc_nsd_connection_point_ref_nst__nst_netslicefgd_rsp_nsd_connection_point_ref(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslicefgd/rsp/nsd-connection-point-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of references to connection points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nsd_ref','__order','__nsd_connection_point_ref',)

  _yang_name = 'nsd-connection-point-ref'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nsd_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    self.__order = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)
    self.__nsd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslicefgd', u'rsp', u'nsd-connection-point-ref']

  def _get_nsd_ref(self):
    """
    Getter method for nsd_ref, mapped from YANG variable /nst/netslicefgd/rsp/nsd_connection_point_ref/nsd_ref (leafref)

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
    return self.__nsd_ref
      
  def _set_nsd_ref(self, v, load=False):
    """
    Setter method for nsd_ref, mapped from YANG variable /nst/netslicefgd/rsp/nsd_connection_point_ref/nsd_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_ref() directly.

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__nsd_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd_ref(self):
    self.__nsd_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)


  def _get_order(self):
    """
    Getter method for order, mapped from YANG variable /nst/netslicefgd/rsp/nsd_connection_point_ref/order (uint8)

    YANG Description: A number that denotes the order of a NSD in a chain
    """
    return self.__order
      
  def _set_order(self, v, load=False):
    """
    Setter method for order, mapped from YANG variable /nst/netslicefgd/rsp/nsd_connection_point_ref/order (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_order is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_order() directly.

    YANG Description: A number that denotes the order of a NSD in a chain
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """order must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)""",
        })

    self.__order = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_order(self):
    self.__order = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)


  def _get_nsd_connection_point_ref(self):
    """
    Getter method for nsd_connection_point_ref, mapped from YANG variable /nst/netslicefgd/rsp/nsd_connection_point_ref/nsd_connection_point_ref (leafref)
    """
    return self.__nsd_connection_point_ref
      
  def _set_nsd_connection_point_ref(self, v, load=False):
    """
    Setter method for nsd_connection_point_ref, mapped from YANG variable /nst/netslicefgd/rsp/nsd_connection_point_ref/nsd_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_connection_point_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__nsd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd_connection_point_ref(self):
    self.__nsd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)

  nsd_ref = __builtin__.property(_get_nsd_ref, _set_nsd_ref)
  order = __builtin__.property(_get_order, _set_order)
  nsd_connection_point_ref = __builtin__.property(_get_nsd_connection_point_ref, _set_nsd_connection_point_ref)


  _pyangbind_elements = OrderedDict([('nsd_ref', nsd_ref), ('order', order), ('nsd_connection_point_ref', nsd_connection_point_ref), ])


class yc_rsp_nst__nst_netslicefgd_rsp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslicefgd/rsp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Rendered Service Paths (RSP).
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__nsd_connection_point_ref',)

  _yang_name = 'rsp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nsd_connection_point_ref = YANGDynClass(base=YANGListType("nsd_ref",yc_nsd_connection_point_ref_nst__nst_netslicefgd_rsp_nsd_connection_point_ref, yang_name="nsd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nsd-ref', extensions=None), is_container='list', yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslicefgd', u'rsp']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nst/netslicefgd/rsp/id (string)

    YANG Description: Identifier for the RSP.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nst/netslicefgd/rsp/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the RSP.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nst/netslicefgd/rsp/name (string)

    YANG Description: RSP name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nst/netslicefgd/rsp/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: RSP name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_nsd_connection_point_ref(self):
    """
    Getter method for nsd_connection_point_ref, mapped from YANG variable /nst/netslicefgd/rsp/nsd_connection_point_ref (list)

    YANG Description: A list of references to connection points.
    """
    return self.__nsd_connection_point_ref
      
  def _set_nsd_connection_point_ref(self, v, load=False):
    """
    Setter method for nsd_connection_point_ref, mapped from YANG variable /nst/netslicefgd/rsp/nsd_connection_point_ref (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_connection_point_ref() directly.

    YANG Description: A list of references to connection points.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("nsd_ref",yc_nsd_connection_point_ref_nst__nst_netslicefgd_rsp_nsd_connection_point_ref, yang_name="nsd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nsd-ref', extensions=None), is_container='list', yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd_connection_point_ref must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("nsd_ref",yc_nsd_connection_point_ref_nst__nst_netslicefgd_rsp_nsd_connection_point_ref, yang_name="nsd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nsd-ref', extensions=None), is_container='list', yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__nsd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd_connection_point_ref(self):
    self.__nsd_connection_point_ref = YANGDynClass(base=YANGListType("nsd_ref",yc_nsd_connection_point_ref_nst__nst_netslicefgd_rsp_nsd_connection_point_ref, yang_name="nsd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='nsd-ref', extensions=None), is_container='list', yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  nsd_connection_point_ref = __builtin__.property(_get_nsd_connection_point_ref, _set_nsd_connection_point_ref)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('nsd_connection_point_ref', nsd_connection_point_ref), ])


class yc_match_attributes_nst__nst_netslicefgd_classifier_match_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslicefgd/classifier/match-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of match attributes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__ip_proto','__source_ip_address','__destination_ip_address','__source_port','__destination_port',)

  _yang_name = 'match-attributes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    self.__destination_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    self.__source_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:port-number', is_config=True)
    self.__ip_proto = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-proto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)
    self.__destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:port-number', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslicefgd', u'classifier', u'match-attributes']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/id (string)

    YANG Description: Identifier for the classifier match attribute rule.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the classifier match attribute rule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_ip_proto(self):
    """
    Getter method for ip_proto, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/ip_proto (uint8)

    YANG Description: IP Protocol.
    """
    return self.__ip_proto
      
  def _set_ip_proto(self, v, load=False):
    """
    Setter method for ip_proto, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/ip_proto (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_proto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_proto() directly.

    YANG Description: IP Protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-proto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_proto must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-proto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)""",
        })

    self.__ip_proto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_proto(self):
    self.__ip_proto = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-proto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='uint8', is_config=True)


  def _get_source_ip_address(self):
    """
    Getter method for source_ip_address, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/source_ip_address (inet:ip-address)

    YANG Description: Source IP address.
    """
    return self.__source_ip_address
      
  def _set_source_ip_address(self, v, load=False):
    """
    Setter method for source_ip_address, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/source_ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ip_address() directly.

    YANG Description: Source IP address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__source_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ip_address(self):
    self.__source_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)


  def _get_destination_ip_address(self):
    """
    Getter method for destination_ip_address, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/destination_ip_address (inet:ip-address)

    YANG Description: Destination IP address.
    """
    return self.__destination_ip_address
      
  def _set_destination_ip_address(self, v, load=False):
    """
    Setter method for destination_ip_address, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/destination_ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ip_address() directly.

    YANG Description: Destination IP address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__destination_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_ip_address(self):
    self.__destination_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:ip-address', is_config=True)


  def _get_source_port(self):
    """
    Getter method for source_port, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/source_port (inet:port-number)

    YANG Description: Source port number.
    """
    return self.__source_port
      
  def _set_source_port(self, v, load=False):
    """
    Setter method for source_port, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/source_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_port() directly.

    YANG Description: Source port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:port-number', is_config=True)""",
        })

    self.__source_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_port(self):
    self.__source_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:port-number', is_config=True)


  def _get_destination_port(self):
    """
    Getter method for destination_port, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/destination_port (inet:port-number)

    YANG Description: Destination port number.
    """
    return self.__destination_port
      
  def _set_destination_port(self, v, load=False):
    """
    Setter method for destination_port, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes/destination_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_port() directly.

    YANG Description: Destination port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:port-number', is_config=True)""",
        })

    self.__destination_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_port(self):
    self.__destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='inet:port-number', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  ip_proto = __builtin__.property(_get_ip_proto, _set_ip_proto)
  source_ip_address = __builtin__.property(_get_source_ip_address, _set_source_ip_address)
  destination_ip_address = __builtin__.property(_get_destination_ip_address, _set_destination_ip_address)
  source_port = __builtin__.property(_get_source_port, _set_source_port)
  destination_port = __builtin__.property(_get_destination_port, _set_destination_port)


  _pyangbind_elements = OrderedDict([('id', id), ('ip_proto', ip_proto), ('source_ip_address', source_ip_address), ('destination_ip_address', destination_ip_address), ('source_port', source_port), ('destination_port', destination_port), ])


class yc_classifier_nst__nst_netslicefgd_classifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslicefgd/classifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of classifier rules.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__rsp_id_ref','__match_attributes','__nsd_ref','__nsd_connection_point_ref',)

  _yang_name = 'classifier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__rsp_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rsp-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    self.__match_attributes = YANGDynClass(base=YANGListType("id",yc_match_attributes_nst__nst_netslicefgd_classifier_match_attributes, yang_name="match-attributes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="match-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__nsd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    self.__nsd_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslicefgd', u'classifier']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nst/netslicefgd/classifier/id (string)

    YANG Description: Identifier for the classifier rule.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nst/netslicefgd/classifier/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the classifier rule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nst/netslicefgd/classifier/name (string)

    YANG Description: Name of the classifier.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nst/netslicefgd/classifier/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the classifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_rsp_id_ref(self):
    """
    Getter method for rsp_id_ref, mapped from YANG variable /nst/netslicefgd/classifier/rsp_id_ref (leafref)

    YANG Description: A reference to the RSP.
    """
    return self.__rsp_id_ref
      
  def _set_rsp_id_ref(self, v, load=False):
    """
    Setter method for rsp_id_ref, mapped from YANG variable /nst/netslicefgd/classifier/rsp_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rsp_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rsp_id_ref() directly.

    YANG Description: A reference to the RSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="rsp-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rsp_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rsp-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__rsp_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rsp_id_ref(self):
    self.__rsp_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rsp-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)


  def _get_match_attributes(self):
    """
    Getter method for match_attributes, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes (list)

    YANG Description: List of match attributes.
    """
    return self.__match_attributes
      
  def _set_match_attributes(self, v, load=False):
    """
    Setter method for match_attributes, mapped from YANG variable /nst/netslicefgd/classifier/match_attributes (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_match_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_match_attributes() directly.

    YANG Description: List of match attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_match_attributes_nst__nst_netslicefgd_classifier_match_attributes, yang_name="match-attributes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="match-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """match_attributes must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_match_attributes_nst__nst_netslicefgd_classifier_match_attributes, yang_name="match-attributes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="match-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__match_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_match_attributes(self):
    self.__match_attributes = YANGDynClass(base=YANGListType("id",yc_match_attributes_nst__nst_netslicefgd_classifier_match_attributes, yang_name="match-attributes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="match-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)


  def _get_nsd_ref(self):
    """
    Getter method for nsd_ref, mapped from YANG variable /nst/netslicefgd/classifier/nsd_ref (leafref)
    """
    return self.__nsd_ref
      
  def _set_nsd_ref(self, v, load=False):
    """
    Setter method for nsd_ref, mapped from YANG variable /nst/netslicefgd/classifier/nsd_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__nsd_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd_ref(self):
    self.__nsd_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)


  def _get_nsd_connection_point_ref(self):
    """
    Getter method for nsd_connection_point_ref, mapped from YANG variable /nst/netslicefgd/classifier/nsd_connection_point_ref (leafref)
    """
    return self.__nsd_connection_point_ref
      
  def _set_nsd_connection_point_ref(self, v, load=False):
    """
    Setter method for nsd_connection_point_ref, mapped from YANG variable /nst/netslicefgd/classifier/nsd_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_connection_point_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nsd_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)""",
        })

    self.__nsd_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nsd_connection_point_ref(self):
    self.__nsd_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='leafref', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  rsp_id_ref = __builtin__.property(_get_rsp_id_ref, _set_rsp_id_ref)
  match_attributes = __builtin__.property(_get_match_attributes, _set_match_attributes)
  nsd_ref = __builtin__.property(_get_nsd_ref, _set_nsd_ref)
  nsd_connection_point_ref = __builtin__.property(_get_nsd_connection_point_ref, _set_nsd_connection_point_ref)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('rsp_id_ref', rsp_id_ref), ('match_attributes', match_attributes), ('nsd_ref', nsd_ref), ('nsd_connection_point_ref', nsd_connection_point_ref), ])


class yc_netslicefgd_nst__nst_netslicefgd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst/netslicefgd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__short_name','__vendor','__description','__version','__rsp','__classifier',)

  _yang_name = 'netslicefgd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__classifier = YANGDynClass(base=YANGListType("id",yc_classifier_nst__nst_netslicefgd_classifier, yang_name="classifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="classifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__rsp = YANGDynClass(base=YANGListType("id",yc_rsp_nst__nst_netslicefgd_rsp, yang_name="rsp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst', u'netslicefgd']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nst/netslicefgd/id (string)

    YANG Description: Identifier for the FGD.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nst/netslicefgd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the FGD.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nst/netslicefgd/name (string)

    YANG Description: FGD name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nst/netslicefgd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: FGD name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /nst/netslicefgd/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /nst/netslicefgd/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_vendor(self):
    """
    Getter method for vendor, mapped from YANG variable /nst/netslicefgd/vendor (string)

    YANG Description: Provider of the FGD.
    """
    return self.__vendor
      
  def _set_vendor(self, v, load=False):
    """
    Setter method for vendor, mapped from YANG variable /nst/netslicefgd/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Provider of the FGD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor(self):
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /nst/netslicefgd/description (string)

    YANG Description: Description of the FGD.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /nst/netslicefgd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the FGD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /nst/netslicefgd/version (string)

    YANG Description: Version of the FGD
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /nst/netslicefgd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the FGD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_rsp(self):
    """
    Getter method for rsp, mapped from YANG variable /nst/netslicefgd/rsp (list)

    YANG Description: List of Rendered Service Paths (RSP).
    """
    return self.__rsp
      
  def _set_rsp(self, v, load=False):
    """
    Setter method for rsp, mapped from YANG variable /nst/netslicefgd/rsp (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rsp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rsp() directly.

    YANG Description: List of Rendered Service Paths (RSP).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_rsp_nst__nst_netslicefgd_rsp, yang_name="rsp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rsp must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_rsp_nst__nst_netslicefgd_rsp, yang_name="rsp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__rsp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rsp(self):
    self.__rsp = YANGDynClass(base=YANGListType("id",yc_rsp_nst__nst_netslicefgd_rsp, yang_name="rsp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)


  def _get_classifier(self):
    """
    Getter method for classifier, mapped from YANG variable /nst/netslicefgd/classifier (list)

    YANG Description: List of classifier rules.
    """
    return self.__classifier
      
  def _set_classifier(self, v, load=False):
    """
    Setter method for classifier, mapped from YANG variable /nst/netslicefgd/classifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_classifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_classifier() directly.

    YANG Description: List of classifier rules.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_classifier_nst__nst_netslicefgd_classifier, yang_name="classifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="classifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """classifier must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_classifier_nst__nst_netslicefgd_classifier, yang_name="classifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="classifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__classifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_classifier(self):
    self.__classifier = YANGDynClass(base=YANGListType("id",yc_classifier_nst__nst_netslicefgd_classifier, yang_name="classifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="classifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  vendor = __builtin__.property(_get_vendor, _set_vendor)
  description = __builtin__.property(_get_description, _set_description)
  version = __builtin__.property(_get_version, _set_version)
  rsp = __builtin__.property(_get_rsp, _set_rsp)
  classifier = __builtin__.property(_get_classifier, _set_classifier)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('short_name', short_name), ('vendor', vendor), ('description', description), ('version', version), ('rsp', rsp), ('classifier', classifier), ])


class yc_nst_nst__nst(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__SNSSAI_identifier','__quality_of_service','__netslice_subnet','__netslice_connection_point','__netslice_vld','__netslicefgd',)

  _yang_name = 'nst'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__netslice_connection_point = YANGDynClass(base=YANGListType("name",yc_netslice_connection_point_nst__nst_netslice_connection_point, yang_name="netslice-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="netslice-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__netslicefgd = YANGDynClass(base=YANGListType("id",yc_netslicefgd_nst__nst_netslicefgd, yang_name="netslicefgd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslicefgd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__netslice_subnet = YANGDynClass(base=YANGListType("id",yc_netslice_subnet_nst__nst_netslice_subnet, yang_name="netslice-subnet", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslice-subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    self.__SNSSAI_identifier = YANGDynClass(base=yc_SNSSAI_identifier_nst__nst_SNSSAI_identifier, is_container='container', yang_name="SNSSAI-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    self.__quality_of_service = YANGDynClass(base=yc_quality_of_service_nst__nst_quality_of_service, is_container='container', yang_name="quality-of-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    self.__netslice_vld = YANGDynClass(base=YANGListType("id",yc_netslice_vld_nst__nst_netslice_vld, yang_name="netslice-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslice-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'nst']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /nst/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /nst/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nst/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /nst/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='string', is_config=True)


  def _get_SNSSAI_identifier(self):
    """
    Getter method for SNSSAI_identifier, mapped from YANG variable /nst/SNSSAI_identifier (container)
    """
    return self.__SNSSAI_identifier
      
  def _set_SNSSAI_identifier(self, v, load=False):
    """
    Setter method for SNSSAI_identifier, mapped from YANG variable /nst/SNSSAI_identifier (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_SNSSAI_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_SNSSAI_identifier() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_SNSSAI_identifier_nst__nst_SNSSAI_identifier, is_container='container', yang_name="SNSSAI-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """SNSSAI_identifier must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_SNSSAI_identifier_nst__nst_SNSSAI_identifier, is_container='container', yang_name="SNSSAI-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)""",
        })

    self.__SNSSAI_identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_SNSSAI_identifier(self):
    self.__SNSSAI_identifier = YANGDynClass(base=yc_SNSSAI_identifier_nst__nst_SNSSAI_identifier, is_container='container', yang_name="SNSSAI-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)


  def _get_quality_of_service(self):
    """
    Getter method for quality_of_service, mapped from YANG variable /nst/quality_of_service (container)
    """
    return self.__quality_of_service
      
  def _set_quality_of_service(self, v, load=False):
    """
    Setter method for quality_of_service, mapped from YANG variable /nst/quality_of_service (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_quality_of_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_quality_of_service() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_quality_of_service_nst__nst_quality_of_service, is_container='container', yang_name="quality-of-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """quality_of_service must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_quality_of_service_nst__nst_quality_of_service, is_container='container', yang_name="quality-of-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)""",
        })

    self.__quality_of_service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_quality_of_service(self):
    self.__quality_of_service = YANGDynClass(base=yc_quality_of_service_nst__nst_quality_of_service, is_container='container', yang_name="quality-of-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='container', is_config=True)


  def _get_netslice_subnet(self):
    """
    Getter method for netslice_subnet, mapped from YANG variable /nst/netslice_subnet (list)
    """
    return self.__netslice_subnet
      
  def _set_netslice_subnet(self, v, load=False):
    """
    Setter method for netslice_subnet, mapped from YANG variable /nst/netslice_subnet (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netslice_subnet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netslice_subnet() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_netslice_subnet_nst__nst_netslice_subnet, yang_name="netslice-subnet", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslice-subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netslice_subnet must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_netslice_subnet_nst__nst_netslice_subnet, yang_name="netslice-subnet", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslice-subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__netslice_subnet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netslice_subnet(self):
    self.__netslice_subnet = YANGDynClass(base=YANGListType("id",yc_netslice_subnet_nst__nst_netslice_subnet, yang_name="netslice-subnet", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslice-subnet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)


  def _get_netslice_connection_point(self):
    """
    Getter method for netslice_connection_point, mapped from YANG variable /nst/netslice_connection_point (list)
    """
    return self.__netslice_connection_point
      
  def _set_netslice_connection_point(self, v, load=False):
    """
    Setter method for netslice_connection_point, mapped from YANG variable /nst/netslice_connection_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netslice_connection_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netslice_connection_point() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_netslice_connection_point_nst__nst_netslice_connection_point, yang_name="netslice-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="netslice-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netslice_connection_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_netslice_connection_point_nst__nst_netslice_connection_point, yang_name="netslice-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="netslice-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__netslice_connection_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netslice_connection_point(self):
    self.__netslice_connection_point = YANGDynClass(base=YANGListType("name",yc_netslice_connection_point_nst__nst_netslice_connection_point, yang_name="netslice-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="netslice-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)


  def _get_netslice_vld(self):
    """
    Getter method for netslice_vld, mapped from YANG variable /nst/netslice_vld (list)
    """
    return self.__netslice_vld
      
  def _set_netslice_vld(self, v, load=False):
    """
    Setter method for netslice_vld, mapped from YANG variable /nst/netslice_vld (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netslice_vld is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netslice_vld() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_netslice_vld_nst__nst_netslice_vld, yang_name="netslice-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslice-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netslice_vld must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_netslice_vld_nst__nst_netslice_vld, yang_name="netslice-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslice-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__netslice_vld = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netslice_vld(self):
    self.__netslice_vld = YANGDynClass(base=YANGListType("id",yc_netslice_vld_nst__nst_netslice_vld, yang_name="netslice-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslice-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)


  def _get_netslicefgd(self):
    """
    Getter method for netslicefgd, mapped from YANG variable /nst/netslicefgd (list)
    """
    return self.__netslicefgd
      
  def _set_netslicefgd(self, v, load=False):
    """
    Setter method for netslicefgd, mapped from YANG variable /nst/netslicefgd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netslicefgd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netslicefgd() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_netslicefgd_nst__nst_netslicefgd, yang_name="netslicefgd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslicefgd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netslicefgd must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_netslicefgd_nst__nst_netslicefgd, yang_name="netslicefgd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslicefgd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__netslicefgd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netslicefgd(self):
    self.__netslicefgd = YANGDynClass(base=YANGListType("id",yc_netslicefgd_nst__nst_netslicefgd, yang_name="netslicefgd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="netslicefgd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  SNSSAI_identifier = __builtin__.property(_get_SNSSAI_identifier, _set_SNSSAI_identifier)
  quality_of_service = __builtin__.property(_get_quality_of_service, _set_quality_of_service)
  netslice_subnet = __builtin__.property(_get_netslice_subnet, _set_netslice_subnet)
  netslice_connection_point = __builtin__.property(_get_netslice_connection_point, _set_netslice_connection_point)
  netslice_vld = __builtin__.property(_get_netslice_vld, _set_netslice_vld)
  netslicefgd = __builtin__.property(_get_netslicefgd, _set_netslicefgd)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('SNSSAI_identifier', SNSSAI_identifier), ('quality_of_service', quality_of_service), ('netslice_subnet', netslice_subnet), ('netslice_connection_point', netslice_connection_point), ('netslice_vld', netslice_vld), ('netslicefgd', netslicefgd), ])


class nst(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nst - based on the path /nst. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nst',)

  _yang_name = 'nst'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nst = YANGDynClass(base=YANGListType("id",yc_nst_nst__nst, yang_name="nst", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_nst(self):
    """
    Getter method for nst, mapped from YANG variable /nst (list)
    """
    return self.__nst
      
  def _set_nst(self, v, load=False):
    """
    Setter method for nst, mapped from YANG variable /nst (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nst is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nst() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_nst_nst__nst, yang_name="nst", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nst must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_nst_nst__nst, yang_name="nst", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)""",
        })

    self.__nst = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nst(self):
    self.__nst = YANGDynClass(base=YANGListType("id",yc_nst_nst__nst, yang_name="nst", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nst", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:nst', defining_module='nst', yang_type='list', is_config=True)

  nst = __builtin__.property(_get_nst, _set_nst)


  _pyangbind_elements = OrderedDict([('nst', nst), ])


