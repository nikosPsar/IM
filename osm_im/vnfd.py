# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six
 
# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__
 
class yc_script_vnfd__vnfd_catalog_vnfd_vnf_configuration_script(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__script_type',)

  _yang_name = 'script'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'script']

  def _get_script_type(self):
    """
    Getter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/script/script_type (enumeration)

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
    return self.__script_type
      
  def _set_script_type(self, v, load=False):
    """
    Setter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/script/script_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_type() directly.

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script_type must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__script_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script_type(self):
    self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  script_type = __builtin__.property(_get_script_type, _set_script_type)

  __choices__ = {u'config-method': {u'script': [u'script_type']}}
  _pyangbind_elements = OrderedDict([('script_type', script_type), ])


class yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__charm','__proxy','__cloud',)

  _yang_name = 'juju'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'juju']

  def _get_charm(self):
    """
    Getter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    return self.__charm
      
  def _set_charm(self, v, load=False):
    """
    Setter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """charm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__charm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_charm(self):
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_cloud(self):
    """
    Getter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    return self.__cloud
      
  def _set_cloud(self, v, load=False):
    """
    Setter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud(self):
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  charm = __builtin__.property(_get_charm, _set_charm)
  proxy = __builtin__.property(_get_proxy, _set_proxy)
  cloud = __builtin__.property(_get_cloud, _set_cloud)

  __choices__ = {u'config-method': {u'juju': [u'charm', u'proxy', u'cloud']}}
  _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_execution_environment_list_juju(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/execution-environment-list/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__charm','__proxy','__cloud',)

  _yang_name = 'juju'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'execution-environment-list', u'juju']

  def _get_charm(self):
    """
    Getter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    return self.__charm
      
  def _set_charm(self, v, load=False):
    """
    Setter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """charm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__charm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_charm(self):
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_cloud(self):
    """
    Getter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    return self.__cloud
      
  def _set_cloud(self, v, load=False):
    """
    Setter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud(self):
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  charm = __builtin__.property(_get_charm, _set_charm)
  proxy = __builtin__.property(_get_proxy, _set_proxy)
  cloud = __builtin__.property(_get_cloud, _set_cloud)

  __choices__ = {u'execution-environment-model': {u'juju': [u'charm', u'proxy', u'cloud']}}
  _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_vnf_configuration_execution_environment_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/execution-environment-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__juju','__helm_chart','__metric_service','__connection_point_ref',)

  _yang_name = 'execution-environment-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'execution-environment-list']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/id (string)

    YANG Description: Execution environment identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Execution environment identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_juju(self):
    """
    Getter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/juju (container)
    """
    return self.__juju
      
  def _set_juju(self, v, load=False):
    """
    Setter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__juju = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju(self):
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_helm_chart(self):
    """
    Getter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/helm_chart (string)

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
    return self.__helm_chart
      
  def _set_helm_chart(self, v, load=False):
    """
    Setter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/helm_chart (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_chart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_chart() directly.

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helm_chart must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__helm_chart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helm_chart(self):
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_metric_service(self):
    """
    Getter method for metric_service, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/metric_service (string)

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
    return self.__metric_service
      
  def _set_metric_service(self, v, load=False):
    """
    Setter method for metric_service, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/metric_service (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_service() directly.

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_service must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__metric_service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_service(self):
    self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_connection_point_ref(self):
    """
    Getter method for connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/connection_point_ref (string)

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
    return self.__connection_point_ref
      
  def _set_connection_point_ref(self, v, load=False):
    """
    Setter method for connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list/connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_point_ref() directly.

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_point_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_point_ref(self):
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  juju = __builtin__.property(_get_juju, _set_juju)
  helm_chart = __builtin__.property(_get_helm_chart, _set_helm_chart)
  metric_service = __builtin__.property(_get_metric_service, _set_metric_service)
  connection_point_ref = __builtin__.property(_get_connection_point_ref, _set_connection_point_ref)

  __choices__ = {u'config-method': {u'execution-environment-list': [u'id', u'metric_service', u'connection_point_ref']}, u'execution-environment-model': {u'juju': [u'juju'], u'helm-chart': [u'helm_chart']}}
  _pyangbind_elements = OrderedDict([('id', id), ('juju', juju), ('helm_chart', helm_chart), ('metric_service', metric_service), ('connection_point_ref', connection_point_ref), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the config primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__mandatory','__default_value','__parameter_pool','__read_only','__hidden',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_mandatory(self):
    """
    Getter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
    return self.__mandatory
      
  def _set_mandatory(self, v, load=False):
    """
    Setter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mandatory must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__mandatory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mandatory(self):
    self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_default_value(self):
    """
    Getter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/default_value (string)

    YANG Description: The default value for this field
    """
    return self.__default_value
      
  def _set_default_value(self, v, load=False):
    """
    Setter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__default_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_value(self):
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_parameter_pool(self):
    """
    Getter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
    return self.__parameter_pool
      
  def _set_parameter_pool(self, v, load=False):
    """
    Setter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter_pool must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__parameter_pool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter_pool(self):
    self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_read_only(self):
    """
    Getter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
    return self.__read_only
      
  def _set_read_only(self, v, load=False):
    """
    Setter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """read_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__read_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_read_only(self):
    self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_hidden(self):
    """
    Getter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
    return self.__hidden
      
  def _set_hidden(self, v, load=False):
    """
    Setter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hidden must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hidden(self):
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  mandatory = __builtin__.property(_get_mandatory, _set_mandatory)
  default_value = __builtin__.property(_get_default_value, _set_default_value)
  parameter_pool = __builtin__.property(_get_parameter_pool, _set_parameter_pool)
  read_only = __builtin__.property(_get_read_only, _set_read_only)
  hidden = __builtin__.property(_get_hidden, _set_hidden)


  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('mandatory', mandatory), ('default_value', default_value), ('parameter_pool', parameter_pool), ('read_only', read_only), ('hidden', hidden), ])


class yc_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__execution_environment_ref','__execution_environment_primitive','__parameter','__user_defined_script',)

  _yang_name = 'config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'config-primitive']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/name (string)

    YANG Description: Name of the config primitive.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the config primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_execution_environment_primitive(self):
    """
    Getter method for execution_environment_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/execution_environment_primitive (string)

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
    return self.__execution_environment_primitive
      
  def _set_execution_environment_primitive(self, v, load=False):
    """
    Setter method for execution_environment_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/execution_environment_primitive (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_primitive() directly.

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_primitive must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__execution_environment_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_primitive(self):
    self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter (list)

    YANG Description: List of parameters to the config primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the config primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/user_defined_script (string)

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  execution_environment_primitive = __builtin__.property(_get_execution_environment_primitive, _set_execution_environment_primitive)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)


  _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref), ('execution_environment_primitive', execution_environment_primitive), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/initial-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__value',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'initial-config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  value = __builtin__.property(_get_value, _set_value)

  __choices__ = {u'primitive-type': {u'primitive-definition': [u'name', u'data_type', u'value']}}
  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/initial-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Initial set of configuration primitives.
  """
  __slots__ = ('_path_helper', '_extmethods', '__seq','__name','__execution_environment_ref','__parameter','__user_defined_script',)

  _yang_name = 'initial-config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'initial-config-primitive']

  def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq
      
  def _set_seq(self, v, load=False):
    """
    Setter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__seq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq(self):
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/name (string)

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  seq = __builtin__.property(_get_seq, _set_seq)
  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

  __choices__ = {u'primitive-type': {u'primitive-definition': [u'name', u'execution_environment_ref', u'parameter', u'user_defined_script']}}
  _pyangbind_elements = OrderedDict([('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_terminate_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/terminate-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__value',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'terminate-config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_terminate_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/terminate-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Terminate set of configuration primitives.
  """
  __slots__ = ('_path_helper', '_extmethods', '__seq','__name','__execution_environment_ref','__parameter','__user_defined_script',)

  _yang_name = 'terminate-config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'terminate-config-primitive']

  def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq
      
  def _set_seq(self, v, load=False):
    """
    Setter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__seq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq(self):
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/name (string)

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  seq = __builtin__.property(_get_seq, _set_seq)
  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)


  _pyangbind_elements = OrderedDict([('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_metrics_vnfd__vnfd_catalog_vnfd_vnf_configuration_metrics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VCA related metrics
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__execution_environment_ref','__execution_environment_metric',)

  _yang_name = 'metrics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__execution_environment_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'metrics']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics/name (string)

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment getting that metric
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment getting that metric
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_execution_environment_metric(self):
    """
    Getter method for execution_environment_metric, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics/execution_environment_metric (string)

    YANG Description: Metric in the execution environment referenced by execution-environment-ref
    """
    return self.__execution_environment_metric
      
  def _set_execution_environment_metric(self, v, load=False):
    """
    Setter method for execution_environment_metric, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics/execution_environment_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_metric() directly.

    YANG Description: Metric in the execution environment referenced by execution-environment-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_metric must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__execution_environment_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_metric(self):
    self.__execution_environment_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  execution_environment_metric = __builtin__.property(_get_execution_environment_metric, _set_execution_environment_metric)


  _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref), ('execution_environment_metric', execution_environment_metric), ])


class yc_entities_vnfd__vnfd_catalog_vnfd_vnf_configuration_relation_entities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/relation/entities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__endpoint',)

  _yang_name = 'entities'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'relation', u'entities']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/relation/entities/id (string)

    YANG Description: A string, reference to the element id in the descriptor.
It could be a vnfd-id or a vdu-id in a VNFD,
or a nsd-id or member-vnf-index in a NSD.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/relation/entities/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: A string, reference to the element id in the descriptor.
It could be a vnfd-id or a vdu-id in a VNFD,
or a nsd-id or member-vnf-index in a NSD.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_endpoint(self):
    """
    Getter method for endpoint, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/relation/entities/endpoint (string)

    YANG Description: Endpoint name defining the relation.
    """
    return self.__endpoint
      
  def _set_endpoint(self, v, load=False):
    """
    Setter method for endpoint, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/relation/entities/endpoint (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endpoint() directly.

    YANG Description: Endpoint name defining the relation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endpoint must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__endpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endpoint(self):
    self.__endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  endpoint = __builtin__.property(_get_endpoint, _set_endpoint)


  _pyangbind_elements = OrderedDict([('id', id), ('endpoint', endpoint), ])


class yc_relation_vnfd__vnfd_catalog_vnfd_vnf_configuration_relation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/relation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of relations between elements in this descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__entities',)

  _yang_name = 'relation'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__entities = YANGDynClass(base=YANGListType("id",yc_entities_vnfd__vnfd_catalog_vnfd_vnf_configuration_relation_entities, yang_name="entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'relation']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/relation/name (string)

    YANG Description: Name of the relation.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/relation/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the relation.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_entities(self):
    """
    Getter method for entities, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/relation/entities (list)

    YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
    """
    return self.__entities
      
  def _set_entities(self, v, load=False):
    """
    Setter method for entities, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/relation/entities (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_entities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_entities() directly.

    YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_entities_vnfd__vnfd_catalog_vnfd_vnf_configuration_relation_entities, yang_name="entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """entities must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_entities_vnfd__vnfd_catalog_vnfd_vnf_configuration_relation_entities, yang_name="entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__entities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_entities(self):
    self.__entities = YANGDynClass(base=YANGListType("id",yc_entities_vnfd__vnfd_catalog_vnfd_vnf_configuration_relation_entities, yang_name="entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  entities = __builtin__.property(_get_entities, _set_entities)


  _pyangbind_elements = OrderedDict([('name', name), ('entities', entities), ])


class yc_ssh_access_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_access_ssh_access(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/config-access/ssh-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
  """
  __slots__ = ('_path_helper', '_extmethods', '__required','__default_user',)

  _yang_name = 'ssh-access'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__required = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__default_user = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'config-access', u'ssh-access']

  def _get_required(self):
    """
    Getter method for required, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_access/ssh_access/required (boolean)

    YANG Description: whether ssh access is needed or not
    """
    return self.__required
      
  def _set_required(self, v, load=False):
    """
    Setter method for required, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_access/ssh_access/required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required() directly.

    YANG Description: whether ssh access is needed or not
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required(self):
    self.__required = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_default_user(self):
    """
    Getter method for default_user, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_access/ssh_access/default_user (string)

    YANG Description: Default user for ssh
    """
    return self.__default_user
      
  def _set_default_user(self, v, load=False):
    """
    Setter method for default_user, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_access/ssh_access/default_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_user() directly.

    YANG Description: Default user for ssh
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_user must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__default_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_user(self):
    self.__default_user = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  required = __builtin__.property(_get_required, _set_required)
  default_user = __builtin__.property(_get_default_user, _set_default_user)


  _pyangbind_elements = OrderedDict([('required', required), ('default_user', default_user), ])


class yc_config_access_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_access(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/config-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
  """
  __slots__ = ('_path_helper', '_extmethods', '__ssh_access',)

  _yang_name = 'config-access'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ssh_access = YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration', u'config-access']

  def _get_ssh_access(self):
    """
    Getter method for ssh_access, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_access/ssh_access (container)

    YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
    """
    return self.__ssh_access
      
  def _set_ssh_access(self, v, load=False):
    """
    Setter method for ssh_access, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_access/ssh_access (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_access() directly.

    YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_access must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__ssh_access = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_access(self):
    self.__ssh_access = YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  ssh_access = __builtin__.property(_get_ssh_access, _set_ssh_access)


  _pyangbind_elements = OrderedDict([('ssh_access', ssh_access), ])


class yc_vnf_configuration_vnfd__vnfd_catalog_vnfd_vnf_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__script','__juju','__execution_environment_list','__config_primitive','__initial_config_primitive','__terminate_config_primitive','__metrics','__relation','__config_access',)

  _yang_name = 'vnf-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config_primitive = YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_vnf_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__execution_environment_list = YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_vnf_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vnf_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__relation = YANGDynClass(base=YANGListType("name",yc_relation_vnfd__vnfd_catalog_vnfd_vnf_configuration_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__config_access = YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vnf-configuration']

  def _get_script(self):
    """
    Getter method for script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/script (container)
    """
    return self.__script
      
  def _set_script(self, v, load=False):
    """
    Setter method for script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/script (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_script_vnfd__vnfd_catalog_vnfd_vnf_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vnf_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script(self):
    self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vnf_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_juju(self):
    """
    Getter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju (container)
    """
    return self.__juju
      
  def _set_juju(self, v, load=False):
    """
    Setter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__juju = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju(self):
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_execution_environment_list(self):
    """
    Getter method for execution_environment_list, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list (list)
    """
    return self.__execution_environment_list
      
  def _set_execution_environment_list(self, v, load=False):
    """
    Setter method for execution_environment_list, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/execution_environment_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_vnf_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_vnf_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__execution_environment_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_list(self):
    self.__execution_environment_list = YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_vnf_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_config_primitive(self):
    """
    Getter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive (list)

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
    return self.__config_primitive
      
  def _set_config_primitive(self, v, load=False):
    """
    Setter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_primitive() directly.

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_primitive(self):
    self.__config_primitive = YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_initial_config_primitive(self):
    """
    Getter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive (list)

    YANG Description: Initial set of configuration primitives.
    """
    return self.__initial_config_primitive
      
  def _set_initial_config_primitive(self, v, load=False):
    """
    Setter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_initial_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_initial_config_primitive() directly.

    YANG Description: Initial set of configuration primitives.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """initial_config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__initial_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_initial_config_primitive(self):
    self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_terminate_config_primitive(self):
    """
    Getter method for terminate_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive (list)

    YANG Description: Terminate set of configuration primitives.
    """
    return self.__terminate_config_primitive
      
  def _set_terminate_config_primitive(self, v, load=False):
    """
    Setter method for terminate_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/terminate_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_config_primitive() directly.

    YANG Description: Terminate set of configuration primitives.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminate_config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__terminate_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminate_config_primitive(self):
    self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_metrics(self):
    """
    Getter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics (list)

    YANG Description: List of VCA related metrics
    """
    return self.__metrics
      
  def _set_metrics(self, v, load=False):
    """
    Setter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: List of VCA related metrics
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_vnf_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metrics must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_vnf_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__metrics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metrics(self):
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_vnf_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_relation(self):
    """
    Getter method for relation, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/relation (list)

    YANG Description: List of relations between elements in this descriptor.
    """
    return self.__relation
      
  def _set_relation(self, v, load=False):
    """
    Setter method for relation, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/relation (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relation() directly.

    YANG Description: List of relations between elements in this descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_relation_vnfd__vnfd_catalog_vnfd_vnf_configuration_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relation must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_relation_vnfd__vnfd_catalog_vnfd_vnf_configuration_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__relation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relation(self):
    self.__relation = YANGDynClass(base=YANGListType("name",yc_relation_vnfd__vnfd_catalog_vnfd_vnf_configuration_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_config_access(self):
    """
    Getter method for config_access, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_access (container)

    YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
    """
    return self.__config_access
      
  def _set_config_access(self, v, load=False):
    """
    Setter method for config_access, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_access (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_access() directly.

    YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_access_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_access must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__config_access = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_access(self):
    self.__config_access = YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  script = __builtin__.property(_get_script, _set_script)
  juju = __builtin__.property(_get_juju, _set_juju)
  execution_environment_list = __builtin__.property(_get_execution_environment_list, _set_execution_environment_list)
  config_primitive = __builtin__.property(_get_config_primitive, _set_config_primitive)
  initial_config_primitive = __builtin__.property(_get_initial_config_primitive, _set_initial_config_primitive)
  terminate_config_primitive = __builtin__.property(_get_terminate_config_primitive, _set_terminate_config_primitive)
  metrics = __builtin__.property(_get_metrics, _set_metrics)
  relation = __builtin__.property(_get_relation, _set_relation)
  config_access = __builtin__.property(_get_config_access, _set_config_access)

  __choices__ = {u'config-method': {u'juju': [u'juju'], u'execution-environment-list': [u'execution_environment_list'], u'script': [u'script']}}
  _pyangbind_elements = OrderedDict([('script', script), ('juju', juju), ('execution_environment_list', execution_environment_list), ('config_primitive', config_primitive), ('initial_config_primitive', initial_config_primitive), ('terminate_config_primitive', terminate_config_primitive), ('metrics', metrics), ('relation', relation), ('config_access', config_access), ])


class yc_dashboard_params_vnfd__vnfd_catalog_vnfd_mgmt_interface_dashboard_params(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/mgmt-interface/dashboard-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the VNF dashboard
  """
  __slots__ = ('_path_helper', '_extmethods', '__path','__https','__port',)

  _yang_name = 'dashboard-params'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)
    self.__https = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="https", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'mgmt-interface', u'dashboard-params']

  def _get_path(self):
    """
    Getter method for path, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/path (string)

    YANG Description: The HTTP path for the dashboard
    """
    return self.__path
      
  def _set_path(self, v, load=False):
    """
    Setter method for path, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path() directly.

    YANG Description: The HTTP path for the dashboard
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path(self):
    self.__path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_https(self):
    """
    Getter method for https, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/https (boolean)

    YANG Description: Pick HTTPS instead of HTTP , Default is false
    """
    return self.__https
      
  def _set_https(self, v, load=False):
    """
    Setter method for https, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/https (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_https is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_https() directly.

    YANG Description: Pick HTTPS instead of HTTP , Default is false
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="https", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """https must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="https", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__https = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_https(self):
    self.__https = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="https", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/port (inet:port-number)

    YANG Description: The HTTP port for the dashboard
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: The HTTP port for the dashboard
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)

  path = __builtin__.property(_get_path, _set_path)
  https = __builtin__.property(_get_https, _set_https)
  port = __builtin__.property(_get_port, _set_port)


  _pyangbind_elements = OrderedDict([('path', path), ('https', https), ('port', port), ])


class yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_mgmt_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/mgmt-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface over which the VNF is managed.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_address','__vdu_id','__cp','__port','__dashboard_params',)

  _yang_name = 'mgmt-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dashboard_params = YANGDynClass(base=yc_dashboard_params_vnfd__vnfd_catalog_vnfd_mgmt_interface_dashboard_params, is_container='container', yang_name="dashboard-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__cp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp", parent=self, choice=(u'endpoint-type', u'cp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, choice=(u'endpoint-type', u'ip'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)
    self.__vdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self, choice=(u'endpoint-type', u'vdu-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'mgmt-interface']

  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/ip_address (inet:ip-address)
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, choice=(u'endpoint-type', u'ip'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, choice=(u'endpoint-type', u'ip'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, choice=(u'endpoint-type', u'ip'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)


  def _get_vdu_id(self):
    """
    Getter method for vdu_id, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/vdu_id (leafref)
    """
    return self.__vdu_id
      
  def _set_vdu_id(self, v, load=False):
    """
    Setter method for vdu_id, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/vdu_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self, choice=(u'endpoint-type', u'vdu-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self, choice=(u'endpoint-type', u'vdu-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vdu_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_id(self):
    self.__vdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self, choice=(u'endpoint-type', u'vdu-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_cp(self):
    """
    Getter method for cp, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/cp (leafref)
    """
    return self.__cp
      
  def _set_cp(self, v, load=False):
    """
    Setter method for cp, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/cp (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cp", parent=self, choice=(u'endpoint-type', u'cp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp", parent=self, choice=(u'endpoint-type', u'cp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__cp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp(self):
    self.__cp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp", parent=self, choice=(u'endpoint-type', u'cp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/port (inet:port-number)

    YANG Description: Port for the management interface.
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: Port for the management interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)


  def _get_dashboard_params(self):
    """
    Getter method for dashboard_params, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params (container)

    YANG Description: Parameters for the VNF dashboard
    """
    return self.__dashboard_params
      
  def _set_dashboard_params(self, v, load=False):
    """
    Setter method for dashboard_params, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dashboard_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dashboard_params() directly.

    YANG Description: Parameters for the VNF dashboard
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dashboard_params_vnfd__vnfd_catalog_vnfd_mgmt_interface_dashboard_params, is_container='container', yang_name="dashboard-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dashboard_params must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dashboard_params_vnfd__vnfd_catalog_vnfd_mgmt_interface_dashboard_params, is_container='container', yang_name="dashboard-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__dashboard_params = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dashboard_params(self):
    self.__dashboard_params = YANGDynClass(base=yc_dashboard_params_vnfd__vnfd_catalog_vnfd_mgmt_interface_dashboard_params, is_container='container', yang_name="dashboard-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
  vdu_id = __builtin__.property(_get_vdu_id, _set_vdu_id)
  cp = __builtin__.property(_get_cp, _set_cp)
  port = __builtin__.property(_get_port, _set_port)
  dashboard_params = __builtin__.property(_get_dashboard_params, _set_dashboard_params)

  __choices__ = {u'endpoint-type': {u'ip': [u'ip_address'], u'cp': [u'cp'], u'vdu-id': [u'vdu_id']}}
  _pyangbind_elements = OrderedDict([('ip_address', ip_address), ('vdu_id', vdu_id), ('cp', cp), ('port', port), ('dashboard_params', dashboard_params), ])


class yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_internal_vld_internal_connection_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/internal-vld/internal-connection-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of internal connection points in this VLD
  """
  __slots__ = ('_path_helper', '_extmethods', '__id_ref','__ip_address',)

  _yang_name = 'internal-connection-point'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'internal-vld', u'internal-connection-point']

  def _get_id_ref(self):
    """
    Getter method for id_ref, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point/id_ref (leafref)

    YANG Description: Reference to the internal connection point id
    """
    return self.__id_ref
      
  def _set_id_ref(self, v, load=False):
    """
    Setter method for id_ref, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point/id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id_ref() directly.

    YANG Description: Reference to the internal connection point id
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id_ref(self):
    self.__id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point/ip_address (inet:ip-address)

    YANG Description: IP address of the internal connection point
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address of the internal connection point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)

  id_ref = __builtin__.property(_get_id_ref, _set_id_ref)
  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)


  _pyangbind_elements = OrderedDict([('id_ref', id_ref), ('ip_address', ip_address), ])


class yc_provider_network_vnfd__vnfd_catalog_vnfd_internal_vld_provider_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/internal-vld/provider-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the provider network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__physical_network','__segmentation_id',)

  _yang_name = 'provider-network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__segmentation_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    self.__physical_network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'internal-vld', u'provider-network']

  def _get_physical_network(self):
    """
    Getter method for physical_network, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network/physical_network (string)

    YANG Description: Name of the physical network on which the provider
network is built.
    """
    return self.__physical_network
      
  def _set_physical_network(self, v, load=False):
    """
    Setter method for physical_network, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network/physical_network (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_network() directly.

    YANG Description: Name of the physical network on which the provider
network is built.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_network must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__physical_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_network(self):
    self.__physical_network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_segmentation_id(self):
    """
    Getter method for segmentation_id, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network/segmentation_id (uint32)

    YANG Description: ID of segregated virtual networks
    """
    return self.__segmentation_id
      
  def _set_segmentation_id(self, v, load=False):
    """
    Setter method for segmentation_id, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network/segmentation_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segmentation_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segmentation_id() directly.

    YANG Description: ID of segregated virtual networks
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """segmentation_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""",
        })

    self.__segmentation_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_segmentation_id(self):
    self.__segmentation_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)

  physical_network = __builtin__.property(_get_physical_network, _set_physical_network)
  segmentation_id = __builtin__.property(_get_segmentation_id, _set_segmentation_id)


  _pyangbind_elements = OrderedDict([('physical_network', physical_network), ('segmentation_id', segmentation_id), ])


class yc_internal_vld_vnfd__vnfd_catalog_vnfd_internal_vld(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/internal-vld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Internal Virtual Link Descriptors (VLD).
The internal VLD describes the basic topology of
the connectivity such as E-LAN, E-Line, E-Tree.
between internal VNF components of the system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__short_name','__description','__type','__root_bandwidth','__leaf_bandwidth','__internal_connection_point','__provider_network','__vim_network_name','__ip_profile_ref',)

  _yang_name = 'internal-vld'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__internal_connection_point = YANGDynClass(base=YANGListType("id_ref",yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_internal_vld_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id-ref', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__provider_network = YANGDynClass(base=yc_provider_network_vnfd__vnfd_catalog_vnfd_internal_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__ip_profile_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-profile-ref", parent=self, choice=(u'init-params', u'vim-network-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__vim_network_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, choice=(u'init-params', u'vim-network-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:virtual-link-type', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'internal-vld']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/id (string)

    YANG Description: Identifier for the VLD
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the VLD
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/name (string)

    YANG Description: Name of the internal VLD
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the internal VLD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/description (string)
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/type (manotypes:virtual-link-type)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/type (manotypes:virtual-link-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:virtual-link-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with manotypes:virtual-link-type""",
          'defined-type': "manotypes:virtual-link-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:virtual-link-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}, u'L3': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:virtual-link-type', is_config=True)


  def _get_root_bandwidth(self):
    """
    Getter method for root_bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/root_bandwidth (uint64)

    YANG Description: For ELAN this is the aggregate bandwidth.
    """
    return self.__root_bandwidth
      
  def _set_root_bandwidth(self, v, load=False):
    """
    Setter method for root_bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/root_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_bandwidth() directly.

    YANG Description: For ELAN this is the aggregate bandwidth.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """root_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__root_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_root_bandwidth(self):
    self.__root_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_leaf_bandwidth(self):
    """
    Getter method for leaf_bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/leaf_bandwidth (uint64)

    YANG Description: For ELAN this is the bandwidth of branches.
    """
    return self.__leaf_bandwidth
      
  def _set_leaf_bandwidth(self, v, load=False):
    """
    Setter method for leaf_bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/leaf_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf_bandwidth() directly.

    YANG Description: For ELAN this is the bandwidth of branches.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leaf_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__leaf_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leaf_bandwidth(self):
    self.__leaf_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_internal_connection_point(self):
    """
    Getter method for internal_connection_point, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point (list)

    YANG Description: List of internal connection points in this VLD
    """
    return self.__internal_connection_point
      
  def _set_internal_connection_point(self, v, load=False):
    """
    Setter method for internal_connection_point, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_connection_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_connection_point() directly.

    YANG Description: List of internal connection points in this VLD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id_ref",yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_internal_vld_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id-ref', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """internal_connection_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id_ref",yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_internal_vld_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id-ref', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__internal_connection_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_internal_connection_point(self):
    self.__internal_connection_point = YANGDynClass(base=YANGListType("id_ref",yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_internal_vld_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id-ref', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_provider_network(self):
    """
    Getter method for provider_network, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network (container)

    YANG Description: Container for the provider network.
    """
    return self.__provider_network
      
  def _set_provider_network(self, v, load=False):
    """
    Setter method for provider_network, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_network() directly.

    YANG Description: Container for the provider network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_provider_network_vnfd__vnfd_catalog_vnfd_internal_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provider_network must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_provider_network_vnfd__vnfd_catalog_vnfd_internal_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__provider_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provider_network(self):
    self.__provider_network = YANGDynClass(base=yc_provider_network_vnfd__vnfd_catalog_vnfd_internal_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_vim_network_name(self):
    """
    Getter method for vim_network_name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/vim_network_name (string)

    YANG Description: Name of network in VIM account. This is used to indicate
 pre-provisioned network name in cloud account.
    """
    return self.__vim_network_name
      
  def _set_vim_network_name(self, v, load=False):
    """
    Setter method for vim_network_name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/vim_network_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_network_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_network_name() directly.

    YANG Description: Name of network in VIM account. This is used to indicate
 pre-provisioned network name in cloud account.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, choice=(u'init-params', u'vim-network-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vim_network_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, choice=(u'init-params', u'vim-network-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__vim_network_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vim_network_name(self):
    self.__vim_network_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, choice=(u'init-params', u'vim-network-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_ip_profile_ref(self):
    """
    Getter method for ip_profile_ref, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/ip_profile_ref (string)

    YANG Description: Named reference to IP-profile object
    """
    return self.__ip_profile_ref
      
  def _set_ip_profile_ref(self, v, load=False):
    """
    Setter method for ip_profile_ref, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/ip_profile_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profile_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profile_ref() directly.

    YANG Description: Named reference to IP-profile object
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip-profile-ref", parent=self, choice=(u'init-params', u'vim-network-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_profile_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-profile-ref", parent=self, choice=(u'init-params', u'vim-network-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__ip_profile_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_profile_ref(self):
    self.__ip_profile_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-profile-ref", parent=self, choice=(u'init-params', u'vim-network-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  root_bandwidth = __builtin__.property(_get_root_bandwidth, _set_root_bandwidth)
  leaf_bandwidth = __builtin__.property(_get_leaf_bandwidth, _set_leaf_bandwidth)
  internal_connection_point = __builtin__.property(_get_internal_connection_point, _set_internal_connection_point)
  provider_network = __builtin__.property(_get_provider_network, _set_provider_network)
  vim_network_name = __builtin__.property(_get_vim_network_name, _set_vim_network_name)
  ip_profile_ref = __builtin__.property(_get_ip_profile_ref, _set_ip_profile_ref)

  __choices__ = {u'init-params': {u'vim-network-profile': [u'ip_profile_ref'], u'vim-network-ref': [u'vim_network_name']}}
  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('short_name', short_name), ('description', description), ('type', type), ('root_bandwidth', root_bandwidth), ('leaf_bandwidth', leaf_bandwidth), ('internal_connection_point', internal_connection_point), ('provider_network', provider_network), ('vim_network_name', vim_network_name), ('ip_profile_ref', ip_profile_ref), ])


class yc_dns_server_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dns_server(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/ip-profiles/ip-profile-params/dns-server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'dns-server'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'ip-profiles', u'ip-profile-params', u'dns-server']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dns_server/address (inet:ip-address)

    YANG Description: List of DNS Servers associated with IP Profile
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dns_server/address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: List of DNS Servers associated with IP Profile
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_dhcp_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dhcp_params(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/ip-profiles/ip-profile-params/dhcp-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__start_address','__count',)

  _yang_name = 'dhcp-params'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'ip-profiles', u'ip-profile-params', u'dhcp-params']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/enabled (boolean)

    YANG Description: This flag indicates if DHCP is enabled or not
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This flag indicates if DHCP is enabled or not
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_start_address(self):
    """
    Getter method for start_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/start_address (inet:ip-address)

    YANG Description: Start IP address of the IP-Address range associated with DHCP domain
    """
    return self.__start_address
      
  def _set_start_address(self, v, load=False):
    """
    Setter method for start_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/start_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_address() directly.

    YANG Description: Start IP address of the IP-Address range associated with DHCP domain
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__start_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_address(self):
    self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/count (uint32)

    YANG Description: Size of the DHCP pool associated with DHCP domain
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Size of the DHCP pool associated with DHCP domain
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  start_address = __builtin__.property(_get_start_address, _set_start_address)
  count = __builtin__.property(_get_count, _set_count)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('start_address', start_address), ('count', count), ])


class yc_ip_profile_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/ip-profiles/ip-profile-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_version','__subnet_address','__gateway_address','__security_group','__dns_server','__dhcp_params','__subnet_prefix_pool',)

  _yang_name = 'ip-profile-params'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dhcp_params = YANGDynClass(base=yc_dhcp_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__dns_server = YANGDynClass(base=YANGListType("address",yc_dns_server_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)
    self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-prefix', is_config=True)
    self.__subnet_prefix_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet-prefix-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__security_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-version', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'ip-profiles', u'ip-profile-params']

  def _get_ip_version(self):
    """
    Getter method for ip_version, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/ip_version (inet:ip-version)
    """
    return self.__ip_version
      
  def _set_ip_version(self, v, load=False):
    """
    Setter method for ip_version, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/ip_version (inet:ip-version)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-version', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_version must be of a type compatible with inet:ip-version""",
          'defined-type': "inet:ip-version",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-version', is_config=True)""",
        })

    self.__ip_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_version(self):
    self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {u'value': 0}, u'ipv4': {u'value': 1}, u'ipv6': {u'value': 2}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-version', is_config=True)


  def _get_subnet_address(self):
    """
    Getter method for subnet_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/subnet_address (inet:ip-prefix)

    YANG Description: Subnet IP prefix associated with IP Profile
    """
    return self.__subnet_address
      
  def _set_subnet_address(self, v, load=False):
    """
    Setter method for subnet_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/subnet_address (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_address() directly.

    YANG Description: Subnet IP prefix associated with IP Profile
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnet_address must be of a type compatible with inet:ip-prefix""",
          'defined-type': "inet:ip-prefix",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-prefix', is_config=True)""",
        })

    self.__subnet_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnet_address(self):
    self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-prefix', is_config=True)


  def _get_gateway_address(self):
    """
    Getter method for gateway_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/gateway_address (inet:ip-address)

    YANG Description: IP Address of the default gateway associated with IP Profile
    """
    return self.__gateway_address
      
  def _set_gateway_address(self, v, load=False):
    """
    Setter method for gateway_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/gateway_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway_address() directly.

    YANG Description: IP Address of the default gateway associated with IP Profile
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__gateway_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway_address(self):
    self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)


  def _get_security_group(self):
    """
    Getter method for security_group, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/security_group (string)

    YANG Description: Name of the security group
    """
    return self.__security_group
      
  def _set_security_group(self, v, load=False):
    """
    Setter method for security_group, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/security_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group() directly.

    YANG Description: Name of the security group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security_group must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__security_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security_group(self):
    self.__security_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_dns_server(self):
    """
    Getter method for dns_server, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dns_server (list)
    """
    return self.__dns_server
      
  def _set_dns_server(self, v, load=False):
    """
    Setter method for dns_server, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dns_server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_server() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address",yc_dns_server_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_server must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address",yc_dns_server_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__dns_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_server(self):
    self.__dns_server = YANGDynClass(base=YANGListType("address",yc_dns_server_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_dhcp_params(self):
    """
    Getter method for dhcp_params, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params (container)
    """
    return self.__dhcp_params
      
  def _set_dhcp_params(self, v, load=False):
    """
    Setter method for dhcp_params, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_params() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dhcp_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_params must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dhcp_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__dhcp_params = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_params(self):
    self.__dhcp_params = YANGDynClass(base=yc_dhcp_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_subnet_prefix_pool(self):
    """
    Getter method for subnet_prefix_pool, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/subnet_prefix_pool (string)

    YANG Description: VIM Specific reference to pre-created subnet prefix
    """
    return self.__subnet_prefix_pool
      
  def _set_subnet_prefix_pool(self, v, load=False):
    """
    Setter method for subnet_prefix_pool, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/subnet_prefix_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_prefix_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_prefix_pool() directly.

    YANG Description: VIM Specific reference to pre-created subnet prefix
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subnet-prefix-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnet_prefix_pool must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet-prefix-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__subnet_prefix_pool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnet_prefix_pool(self):
    self.__subnet_prefix_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subnet-prefix-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  ip_version = __builtin__.property(_get_ip_version, _set_ip_version)
  subnet_address = __builtin__.property(_get_subnet_address, _set_subnet_address)
  gateway_address = __builtin__.property(_get_gateway_address, _set_gateway_address)
  security_group = __builtin__.property(_get_security_group, _set_security_group)
  dns_server = __builtin__.property(_get_dns_server, _set_dns_server)
  dhcp_params = __builtin__.property(_get_dhcp_params, _set_dhcp_params)
  subnet_prefix_pool = __builtin__.property(_get_subnet_prefix_pool, _set_subnet_prefix_pool)


  _pyangbind_elements = OrderedDict([('ip_version', ip_version), ('subnet_address', subnet_address), ('gateway_address', gateway_address), ('security_group', security_group), ('dns_server', dns_server), ('dhcp_params', dhcp_params), ('subnet_prefix_pool', subnet_prefix_pool), ])


class yc_ip_profiles_vnfd__vnfd_catalog_vnfd_ip_profiles(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/ip-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__ip_profile_params',)

  _yang_name = 'ip-profiles'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_profile_params = YANGDynClass(base=yc_ip_profile_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params, is_container='container', yang_name="ip-profile-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'ip-profiles']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/name (string)

    YANG Description: Name of the IP-Profile
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the IP-Profile
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/description (string)

    YANG Description: Description for IP profile
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description for IP profile
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_ip_profile_params(self):
    """
    Getter method for ip_profile_params, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params (container)
    """
    return self.__ip_profile_params
      
  def _set_ip_profile_params(self, v, load=False):
    """
    Setter method for ip_profile_params, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profile_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profile_params() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ip_profile_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params, is_container='container', yang_name="ip-profile-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_profile_params must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ip_profile_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params, is_container='container', yang_name="ip-profile-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__ip_profile_params = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_profile_params(self):
    self.__ip_profile_params = YANGDynClass(base=yc_ip_profile_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params, is_container='container', yang_name="ip-profile-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  ip_profile_params = __builtin__.property(_get_ip_profile_params, _set_ip_profile_params)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('ip_profile_params', ip_profile_params), ])


class yc_connection_point_vnfd__vnfd_catalog_vnfd_connection_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/connection-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for external connection points. Each VNF has one
or more external connection points that connect the VNF
to other VNFs or to external networks. Each VNF exposes
connection points to the orchestrator, which can construct
network services by connecting the connection points
between different VNFs. The NFVO will use VLDs and VNFFGs
at the network service level to construct network services.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__id','__short_name','__type','__port_security_enabled','__internal_vld_ref',)

  _yang_name = 'connection-point'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__internal_vld_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="internal-vld-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__port_security_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:connection-point-type', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'connection-point']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/name (string)

    YANG Description: Name of the connection point
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the connection point
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/id (string)

    YANG Description: Identifier for the internal connection points
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the internal connection points
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/type (manotypes:connection-point-type)

    YANG Description: Type of the connection point.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/type (manotypes:connection-point-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the connection point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:connection-point-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with manotypes:connection-point-type""",
          'defined-type': "manotypes:connection-point-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:connection-point-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:connection-point-type', is_config=True)


  def _get_port_security_enabled(self):
    """
    Getter method for port_security_enabled, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/port_security_enabled (boolean)

    YANG Description: Enables the port security for the port.
    """
    return self.__port_security_enabled
      
  def _set_port_security_enabled(self, v, load=False):
    """
    Setter method for port_security_enabled, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/port_security_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_enabled() directly.

    YANG Description: Enables the port security for the port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_security_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__port_security_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_security_enabled(self):
    self.__port_security_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_internal_vld_ref(self):
    """
    Getter method for internal_vld_ref, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/internal_vld_ref (leafref)

    YANG Description: Reference to an internal VLD of the VNF. This field is
optional. It allows exposing an internal VLD through a
connection point. When building a NS, this VNF CP might be
connected to a NS VLD, then both VLDs (the i-VLD of the VNF and the
VLD of the NS) will become the same network and the IP profile will
be the one configured at NS level.
    """
    return self.__internal_vld_ref
      
  def _set_internal_vld_ref(self, v, load=False):
    """
    Setter method for internal_vld_ref, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/internal_vld_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_vld_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_vld_ref() directly.

    YANG Description: Reference to an internal VLD of the VNF. This field is
optional. It allows exposing an internal VLD through a
connection point. When building a NS, this VNF CP might be
connected to a NS VLD, then both VLDs (the i-VLD of the VNF and the
VLD of the NS) will become the same network and the IP profile will
be the one configured at NS level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="internal-vld-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """internal_vld_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="internal-vld-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__internal_vld_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_internal_vld_ref(self):
    self.__internal_vld_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="internal-vld-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  id = __builtin__.property(_get_id, _set_id)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  type = __builtin__.property(_get_type, _set_type)
  port_security_enabled = __builtin__.property(_get_port_security_enabled, _set_port_security_enabled)
  internal_vld_ref = __builtin__.property(_get_internal_vld_ref, _set_internal_vld_ref)


  _pyangbind_elements = OrderedDict([('name', name), ('id', id), ('short_name', short_name), ('type', type), ('port_security_enabled', port_security_enabled), ('internal_vld_ref', internal_vld_ref), ])


class yc_vm_flavor_vnfd__vnfd_catalog_vnfd_vdu_vm_flavor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vm-flavor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vcpu_count','__memory_mb','__storage_gb',)

  _yang_name = 'vm-flavor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__memory_mb = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__vcpu_count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="vcpu-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)
    self.__storage_gb = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="storage-gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vm-flavor']

  def _get_vcpu_count(self):
    """
    Getter method for vcpu_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/vcpu_count (uint16)

    YANG Description: Number of VCPUs for the VM.
    """
    return self.__vcpu_count
      
  def _set_vcpu_count(self, v, load=False):
    """
    Setter method for vcpu_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/vcpu_count (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcpu_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcpu_count() directly.

    YANG Description: Number of VCPUs for the VM.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="vcpu-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcpu_count must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="vcpu-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)""",
        })

    self.__vcpu_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcpu_count(self):
    self.__vcpu_count = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="vcpu-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)


  def _get_memory_mb(self):
    """
    Getter method for memory_mb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/memory_mb (uint64)

    YANG Description: Amount of memory in MB.
    """
    return self.__memory_mb
      
  def _set_memory_mb(self, v, load=False):
    """
    Setter method for memory_mb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/memory_mb (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_mb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_mb() directly.

    YANG Description: Amount of memory in MB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_mb must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__memory_mb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_mb(self):
    self.__memory_mb = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_storage_gb(self):
    """
    Getter method for storage_gb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/storage_gb (uint64)

    YANG Description: Amount of disk space in GB.
    """
    return self.__storage_gb
      
  def _set_storage_gb(self, v, load=False):
    """
    Setter method for storage_gb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/storage_gb (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage_gb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage_gb() directly.

    YANG Description: Amount of disk space in GB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="storage-gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage_gb must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="storage-gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__storage_gb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage_gb(self):
    self.__storage_gb = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="storage-gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

  vcpu_count = __builtin__.property(_get_vcpu_count, _set_vcpu_count)
  memory_mb = __builtin__.property(_get_memory_mb, _set_memory_mb)
  storage_gb = __builtin__.property(_get_storage_gb, _set_storage_gb)


  _pyangbind_elements = OrderedDict([('vcpu_count', vcpu_count), ('memory_mb', memory_mb), ('storage_gb', storage_gb), ])


class yc_cpu_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_cpu_quota(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/cpu-quota. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: CPU quota describes the CPU resource allocation policy.
Limit and Reserve values are defined in MHz
  """
  __slots__ = ('_path_helper', '_extmethods', '__limit','__reserve','__shares',)

  _yang_name = 'cpu-quota'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__shares = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__reserve = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa', u'cpu-quota']

  def _get_limit(self):
    """
    Getter method for limit, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_quota/limit (uint64)

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
    return self.__limit
      
  def _set_limit(self, v, load=False):
    """
    Setter method for limit, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_quota/limit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_limit() directly.

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """limit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_limit(self):
    self.__limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_reserve(self):
    """
    Getter method for reserve, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_quota/reserve (uint64)

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
    return self.__reserve
      
  def _set_reserve(self, v, load=False):
    """
    Setter method for reserve, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_quota/reserve (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserve is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserve() directly.

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reserve must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__reserve = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reserve(self):
    self.__reserve = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_shares(self):
    """
    Getter method for shares, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_quota/shares (uint64)

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
    return self.__shares
      
  def _set_shares(self, v, load=False):
    """
    Setter method for shares, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_quota/shares (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shares is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shares() directly.

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shares must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__shares = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shares(self):
    self.__shares = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

  limit = __builtin__.property(_get_limit, _set_limit)
  reserve = __builtin__.property(_get_reserve, _set_reserve)
  shares = __builtin__.property(_get_shares, _set_shares)

  __choices__ = {u'cpu-policy': {u'cpu-quota': [u'limit', u'reserve', u'shares']}}
  _pyangbind_elements = OrderedDict([('limit', limit), ('reserve', reserve), ('shares', shares), ])


class yc_mem_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_mem_quota(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/mem-quota. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Memory quota describes the memory resource allocation policy.
Limit and Reserve values are defined in MB
  """
  __slots__ = ('_path_helper', '_extmethods', '__limit','__reserve','__shares',)

  _yang_name = 'mem-quota'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__shares = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__reserve = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa', u'mem-quota']

  def _get_limit(self):
    """
    Getter method for limit, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mem_quota/limit (uint64)

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
    return self.__limit
      
  def _set_limit(self, v, load=False):
    """
    Setter method for limit, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mem_quota/limit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_limit() directly.

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """limit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_limit(self):
    self.__limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_reserve(self):
    """
    Getter method for reserve, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mem_quota/reserve (uint64)

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
    return self.__reserve
      
  def _set_reserve(self, v, load=False):
    """
    Setter method for reserve, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mem_quota/reserve (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserve is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserve() directly.

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reserve must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__reserve = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reserve(self):
    self.__reserve = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_shares(self):
    """
    Getter method for shares, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mem_quota/shares (uint64)

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
    return self.__shares
      
  def _set_shares(self, v, load=False):
    """
    Setter method for shares, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mem_quota/shares (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shares is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shares() directly.

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shares must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__shares = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shares(self):
    self.__shares = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

  limit = __builtin__.property(_get_limit, _set_limit)
  reserve = __builtin__.property(_get_reserve, _set_reserve)
  shares = __builtin__.property(_get_shares, _set_shares)


  _pyangbind_elements = OrderedDict([('limit', limit), ('reserve', reserve), ('shares', shares), ])


class yc_disk_io_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_disk_io_quota(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/disk-io-quota. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Disk IO quota describes the disk IO operations resource allocation policy.
Limit and Reserve values are defined in IOPS
  """
  __slots__ = ('_path_helper', '_extmethods', '__limit','__reserve','__shares',)

  _yang_name = 'disk-io-quota'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__shares = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__reserve = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa', u'disk-io-quota']

  def _get_limit(self):
    """
    Getter method for limit, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/disk_io_quota/limit (uint64)

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
    return self.__limit
      
  def _set_limit(self, v, load=False):
    """
    Setter method for limit, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/disk_io_quota/limit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_limit() directly.

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """limit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_limit(self):
    self.__limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_reserve(self):
    """
    Getter method for reserve, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/disk_io_quota/reserve (uint64)

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
    return self.__reserve
      
  def _set_reserve(self, v, load=False):
    """
    Setter method for reserve, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/disk_io_quota/reserve (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserve is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserve() directly.

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reserve must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__reserve = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reserve(self):
    self.__reserve = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_shares(self):
    """
    Getter method for shares, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/disk_io_quota/shares (uint64)

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
    return self.__shares
      
  def _set_shares(self, v, load=False):
    """
    Setter method for shares, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/disk_io_quota/shares (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shares is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shares() directly.

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shares must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__shares = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shares(self):
    self.__shares = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

  limit = __builtin__.property(_get_limit, _set_limit)
  reserve = __builtin__.property(_get_reserve, _set_reserve)
  shares = __builtin__.property(_get_shares, _set_shares)


  _pyangbind_elements = OrderedDict([('limit', limit), ('reserve', reserve), ('shares', shares), ])


class yc_vif_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_vif_quota(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/vif-quota. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Virtual interfaces quota describes the virtual interface bandwidth resource allocation policy.
Limit and Reserve values are defined in Mbps
  """
  __slots__ = ('_path_helper', '_extmethods', '__limit','__reserve','__shares',)

  _yang_name = 'vif-quota'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__shares = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__reserve = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa', u'vif-quota']

  def _get_limit(self):
    """
    Getter method for limit, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/vif_quota/limit (uint64)

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
    return self.__limit
      
  def _set_limit(self, v, load=False):
    """
    Setter method for limit, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/vif_quota/limit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_limit() directly.

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """limit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_limit(self):
    self.__limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_reserve(self):
    """
    Getter method for reserve, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/vif_quota/reserve (uint64)

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
    return self.__reserve
      
  def _set_reserve(self, v, load=False):
    """
    Setter method for reserve, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/vif_quota/reserve (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserve is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserve() directly.

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reserve must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__reserve = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reserve(self):
    self.__reserve = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_shares(self):
    """
    Getter method for shares, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/vif_quota/shares (uint64)

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
    return self.__shares
      
  def _set_shares(self, v, load=False):
    """
    Setter method for shares, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/vif_quota/shares (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shares is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shares() directly.

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shares must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__shares = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shares(self):
    self.__shares = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

  limit = __builtin__.property(_get_limit, _set_limit)
  reserve = __builtin__.property(_get_reserve, _set_reserve)
  shares = __builtin__.property(_get_shares, _set_shares)


  _pyangbind_elements = OrderedDict([('limit', limit), ('reserve', reserve), ('shares', shares), ])


class yc_pcie_device_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_pcie_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/pcie-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of pcie passthrough devices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__device_id','__count',)

  _yang_name = 'pcie-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__device_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa', u'pcie-device']

  def _get_device_id(self):
    """
    Getter method for device_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device/device_id (string)

    YANG Description: Device identifier.
    """
    return self.__device_id
      
  def _set_device_id(self, v, load=False):
    """
    Setter method for device_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device/device_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_id() directly.

    YANG Description: Device identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__device_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_id(self):
    self.__device_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device/count (uint64)

    YANG Description: Number of devices to attach to the VM.
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device/count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Number of devices to attach to the VM.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

  device_id = __builtin__.property(_get_device_id, _set_device_id)
  count = __builtin__.property(_get_count, _set_count)


  _pyangbind_elements = OrderedDict([('device_id', device_id), ('count', count), ])


class yc_vcpu_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_vcpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/numa-node-policy/node/vcpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VCPUs to allocate on
this NUMA node.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'vcpu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa', u'numa-node-policy', u'node', u'vcpu']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/vcpu/id (uint64)

    YANG Description: List of VCPUs ids to allocate on
this NUMA node
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/vcpu/id (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: List of VCPUs ids to allocate on
this NUMA node
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

  id = __builtin__.property(_get_id, _set_id)

  __choices__ = {u'numa-policy': {u'numa-aware': [u'id']}}
  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_paired_thread_ids_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads_paired_thread_ids(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/numa-node-policy/node/paired-threads/paired-thread-ids. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of thread pairs to use in case of paired-thread NUMA
  """
  __slots__ = ('_path_helper', '_extmethods', '__thread_a','__thread_b',)

  _yang_name = 'paired-thread-ids'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__thread_a = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-a", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    self.__thread_b = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-b", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa', u'numa-node-policy', u'node', u'paired-threads', u'paired-thread-ids']

  def _get_thread_a(self):
    """
    Getter method for thread_a, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids/thread_a (uint8)
    """
    return self.__thread_a
      
  def _set_thread_a(self, v, load=False):
    """
    Setter method for thread_a, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids/thread_a (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_thread_a is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_thread_a() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-a", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """thread_a must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-a", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""",
        })

    self.__thread_a = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_thread_a(self):
    self.__thread_a = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-a", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)


  def _get_thread_b(self):
    """
    Getter method for thread_b, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids/thread_b (uint8)
    """
    return self.__thread_b
      
  def _set_thread_b(self, v, load=False):
    """
    Setter method for thread_b, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids/thread_b (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_thread_b is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_thread_b() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-b", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """thread_b must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-b", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""",
        })

    self.__thread_b = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_thread_b(self):
    self.__thread_b = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-b", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)

  thread_a = __builtin__.property(_get_thread_a, _set_thread_a)
  thread_b = __builtin__.property(_get_thread_b, _set_thread_b)

  __choices__ = {u'om-numa-type': {u'paired-threads': [u'thread_a', u'thread_b']}}
  _pyangbind_elements = OrderedDict([('thread_a', thread_a), ('thread_b', thread_b), ])


class yc_paired_threads_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/numa-node-policy/node/paired-threads. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__num_paired_threads','__paired_thread_ids',)

  _yang_name = 'paired-threads'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__num_paired_threads = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-paired-threads", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    self.__paired_thread_ids = YANGDynClass(base=YANGListType("thread_a",yc_paired_thread_ids_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads_paired_thread_ids, yang_name="paired-thread-ids", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='thread-a', extensions=None, choice=(u'om-numa-type', u'paired-threads')), is_container='list', yang_name="paired-thread-ids", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa', u'numa-node-policy', u'node', u'paired-threads']

  def _get_num_paired_threads(self):
    """
    Getter method for num_paired_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/num_paired_threads (uint8)
    """
    return self.__num_paired_threads
      
  def _set_num_paired_threads(self, v, load=False):
    """
    Setter method for num_paired_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/num_paired_threads (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_paired_threads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_paired_threads() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-paired-threads", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_paired_threads must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-paired-threads", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""",
        })

    self.__num_paired_threads = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_paired_threads(self):
    self.__num_paired_threads = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-paired-threads", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)


  def _get_paired_thread_ids(self):
    """
    Getter method for paired_thread_ids, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids (list)

    YANG Description: List of thread pairs to use in case of paired-thread NUMA
    """
    return self.__paired_thread_ids
      
  def _set_paired_thread_ids(self, v, load=False):
    """
    Setter method for paired_thread_ids, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paired_thread_ids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paired_thread_ids() directly.

    YANG Description: List of thread pairs to use in case of paired-thread NUMA
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("thread_a",yc_paired_thread_ids_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads_paired_thread_ids, yang_name="paired-thread-ids", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='thread-a', extensions=None, choice=(u'om-numa-type', u'paired-threads')), is_container='list', yang_name="paired-thread-ids", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """paired_thread_ids must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("thread_a",yc_paired_thread_ids_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads_paired_thread_ids, yang_name="paired-thread-ids", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='thread-a', extensions=None, choice=(u'om-numa-type', u'paired-threads')), is_container='list', yang_name="paired-thread-ids", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__paired_thread_ids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_paired_thread_ids(self):
    self.__paired_thread_ids = YANGDynClass(base=YANGListType("thread_a",yc_paired_thread_ids_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads_paired_thread_ids, yang_name="paired-thread-ids", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='thread-a', extensions=None, choice=(u'om-numa-type', u'paired-threads')), is_container='list', yang_name="paired-thread-ids", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  num_paired_threads = __builtin__.property(_get_num_paired_threads, _set_num_paired_threads)
  paired_thread_ids = __builtin__.property(_get_paired_thread_ids, _set_paired_thread_ids)

  __choices__ = {u'om-numa-type': {u'paired-threads': [u'num_paired_threads', u'paired_thread_ids']}}
  _pyangbind_elements = OrderedDict([('num_paired_threads', num_paired_threads), ('paired_thread_ids', paired_thread_ids), ])


class yc_node_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/numa-node-policy/node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__vcpu','__memory_mb','__num_cores','__paired_threads','__num_threads',)

  _yang_name = 'node'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__num_threads = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-threads", parent=self, choice=(u'om-numa-type', u'threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    self.__vcpu = YANGDynClass(base=YANGListType("id",yc_vcpu_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_vcpu, yang_name="vcpu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=(u'numa-policy', u'numa-aware')), is_container='list', yang_name="vcpu", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__num_cores = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-cores", parent=self, choice=(u'om-numa-type', u'cores'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    self.__memory_mb = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__paired_threads = YANGDynClass(base=yc_paired_threads_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads, is_container='container', yang_name="paired-threads", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa', u'numa-node-policy', u'node']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/id (uint64)

    YANG Description: NUMA node identification. Typically
it's 0 or 1
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/id (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: NUMA node identification. Typically
it's 0 or 1
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_vcpu(self):
    """
    Getter method for vcpu, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/vcpu (list)

    YANG Description: List of VCPUs to allocate on
this NUMA node.
    """
    return self.__vcpu
      
  def _set_vcpu(self, v, load=False):
    """
    Setter method for vcpu, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/vcpu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcpu() directly.

    YANG Description: List of VCPUs to allocate on
this NUMA node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_vcpu_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_vcpu, yang_name="vcpu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=(u'numa-policy', u'numa-aware')), is_container='list', yang_name="vcpu", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcpu must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_vcpu_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_vcpu, yang_name="vcpu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=(u'numa-policy', u'numa-aware')), is_container='list', yang_name="vcpu", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__vcpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcpu(self):
    self.__vcpu = YANGDynClass(base=YANGListType("id",yc_vcpu_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_vcpu, yang_name="vcpu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=(u'numa-policy', u'numa-aware')), is_container='list', yang_name="vcpu", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_memory_mb(self):
    """
    Getter method for memory_mb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/memory_mb (uint64)

    YANG Description: Memory size expressed in MB
for this NUMA node.
    """
    return self.__memory_mb
      
  def _set_memory_mb(self, v, load=False):
    """
    Setter method for memory_mb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/memory_mb (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_mb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_mb() directly.

    YANG Description: Memory size expressed in MB
for this NUMA node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory_mb must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__memory_mb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory_mb(self):
    self.__memory_mb = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_num_cores(self):
    """
    Getter method for num_cores, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/num_cores (uint8)
    """
    return self.__num_cores
      
  def _set_num_cores(self, v, load=False):
    """
    Setter method for num_cores, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/num_cores (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_cores is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_cores() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-cores", parent=self, choice=(u'om-numa-type', u'cores'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_cores must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-cores", parent=self, choice=(u'om-numa-type', u'cores'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""",
        })

    self.__num_cores = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_cores(self):
    self.__num_cores = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-cores", parent=self, choice=(u'om-numa-type', u'cores'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)


  def _get_paired_threads(self):
    """
    Getter method for paired_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads (container)
    """
    return self.__paired_threads
      
  def _set_paired_threads(self, v, load=False):
    """
    Setter method for paired_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paired_threads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paired_threads() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_paired_threads_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads, is_container='container', yang_name="paired-threads", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """paired_threads must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_paired_threads_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads, is_container='container', yang_name="paired-threads", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__paired_threads = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_paired_threads(self):
    self.__paired_threads = YANGDynClass(base=yc_paired_threads_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads, is_container='container', yang_name="paired-threads", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_num_threads(self):
    """
    Getter method for num_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/num_threads (uint8)
    """
    return self.__num_threads
      
  def _set_num_threads(self, v, load=False):
    """
    Setter method for num_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/num_threads (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_threads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_threads() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-threads", parent=self, choice=(u'om-numa-type', u'threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_threads must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-threads", parent=self, choice=(u'om-numa-type', u'threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""",
        })

    self.__num_threads = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_threads(self):
    self.__num_threads = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-threads", parent=self, choice=(u'om-numa-type', u'threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  vcpu = __builtin__.property(_get_vcpu, _set_vcpu)
  memory_mb = __builtin__.property(_get_memory_mb, _set_memory_mb)
  num_cores = __builtin__.property(_get_num_cores, _set_num_cores)
  paired_threads = __builtin__.property(_get_paired_threads, _set_paired_threads)
  num_threads = __builtin__.property(_get_num_threads, _set_num_threads)

  __choices__ = {u'om-numa-type': {u'cores': [u'num_cores'], u'threads': [u'num_threads'], u'paired-threads': [u'paired_threads']}, u'numa-policy': {u'numa-aware': [u'id', u'vcpu', u'memory_mb']}}
  _pyangbind_elements = OrderedDict([('id', id), ('vcpu', vcpu), ('memory_mb', memory_mb), ('num_cores', num_cores), ('paired_threads', paired_threads), ('num_threads', num_threads), ])


class yc_numa_node_policy_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/numa-node-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This policy defines NUMA topology of the
guest. Specifically identifies if the guest
should be run on a host with one NUMA
node or multiple NUMA nodes. As an example
a guest might need 8 VCPUs and 4 GB of
memory. However, it might need the VCPUs
and memory distributed across multiple
NUMA nodes. In this scenario, NUMA node
1 could run with 6 VCPUs and 3GB, and
NUMA node 2 could run with 2 VCPUs and
1GB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__node_cnt','__mem_policy','__node',)

  _yang_name = 'numa-node-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__node = YANGDynClass(base=YANGListType("id",yc_node_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=(u'numa-policy', u'numa-aware')), is_container='list', yang_name="node", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__node_cnt = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="node-cnt", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)
    self.__mem_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'STRICT': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="mem-policy", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa', u'numa-node-policy']

  def _get_node_cnt(self):
    """
    Getter method for node_cnt, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node_cnt (uint16)

    YANG Description: The number of NUMA nodes to expose to the VM.
    """
    return self.__node_cnt
      
  def _set_node_cnt(self, v, load=False):
    """
    Setter method for node_cnt, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node_cnt (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_cnt() directly.

    YANG Description: The number of NUMA nodes to expose to the VM.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="node-cnt", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_cnt must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="node-cnt", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)""",
        })

    self.__node_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_cnt(self):
    self.__node_cnt = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="node-cnt", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)


  def _get_mem_policy(self):
    """
    Getter method for mem_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/mem_policy (enumeration)

    YANG Description: This policy specifies how the memory should
be allocated in a multi-node scenario.
STRICT    : The memory must be allocated
            strictly from the memory attached
            to the NUMA node.
PREFERRED : The memory should be allocated
            preferentially from the memory
            attached to the NUMA node
    """
    return self.__mem_policy
      
  def _set_mem_policy(self, v, load=False):
    """
    Setter method for mem_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/mem_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mem_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mem_policy() directly.

    YANG Description: This policy specifies how the memory should
be allocated in a multi-node scenario.
STRICT    : The memory must be allocated
            strictly from the memory attached
            to the NUMA node.
PREFERRED : The memory should be allocated
            preferentially from the memory
            attached to the NUMA node
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'STRICT': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="mem-policy", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mem_policy must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'STRICT': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="mem-policy", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__mem_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mem_policy(self):
    self.__mem_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'STRICT': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="mem-policy", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_node(self):
    """
    Getter method for node, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node (list)
    """
    return self.__node
      
  def _set_node(self, v, load=False):
    """
    Setter method for node, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_node_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=(u'numa-policy', u'numa-aware')), is_container='list', yang_name="node", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_node_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=(u'numa-policy', u'numa-aware')), is_container='list', yang_name="node", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node(self):
    self.__node = YANGDynClass(base=YANGListType("id",yc_node_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=(u'numa-policy', u'numa-aware')), is_container='list', yang_name="node", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  node_cnt = __builtin__.property(_get_node_cnt, _set_node_cnt)
  mem_policy = __builtin__.property(_get_mem_policy, _set_mem_policy)
  node = __builtin__.property(_get_node, _set_node)

  __choices__ = {u'numa-policy': {u'numa-aware': [u'node_cnt', u'mem_policy', u'node']}}
  _pyangbind_elements = OrderedDict([('node_cnt', node_cnt), ('mem_policy', mem_policy), ('node', node), ])


class yc_guest_epa_vnfd__vnfd_catalog_vnfd_vdu_guest_epa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__trusted_execution','__mempage_size','__cpu_pinning_policy','__cpu_thread_pinning_policy','__cpu_quota','__mem_quota','__disk_io_quota','__vif_quota','__pcie_device','__numa_unaware','__numa_node_policy',)

  _yang_name = 'guest-epa'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__disk_io_quota = YANGDynClass(base=yc_disk_io_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_disk_io_quota, is_container='container', yang_name="disk-io-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__cpu_thread_pinning_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER': {}, u'AVOID': {}, u'ISOLATE': {}, u'SEPARATE': {}},), is_leaf=True, yang_name="cpu-thread-pinning-policy", parent=self, choice=(u'cpu-policy', u'cpu-pinning'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__vif_quota = YANGDynClass(base=yc_vif_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_vif_quota, is_container='container', yang_name="vif-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__mem_quota = YANGDynClass(base=yc_mem_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_mem_quota, is_container='container', yang_name="mem-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__numa_unaware = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-unaware", parent=self, choice=(u'numa-policy', u'numa-unaware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='empty', is_config=True)
    self.__pcie_device = YANGDynClass(base=YANGListType("device_id",yc_pcie_device_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_pcie_device, yang_name="pcie-device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='device-id', extensions=None), is_container='list', yang_name="pcie-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__mempage_size = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LARGE': {}, u'SMALL': {}, u'SIZE_1GB': {}, u'SIZE_2MB': {}, u'PREFER_LARGE': {}},), is_leaf=True, yang_name="mempage-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__trusted_execution = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trusted-execution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__numa_node_policy = YANGDynClass(base=yc_numa_node_policy_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy, is_container='container', yang_name="numa-node-policy", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__cpu_quota = YANGDynClass(base=yc_cpu_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_cpu_quota, is_container='container', yang_name="cpu-quota", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__cpu_pinning_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'SHARED': {}, u'DEDICATED': {}, u'ANY': {}},), default=six.text_type("ANY"), is_leaf=True, yang_name="cpu-pinning-policy", parent=self, choice=(u'cpu-policy', u'cpu-pinning'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'guest-epa']

  def _get_trusted_execution(self):
    """
    Getter method for trusted_execution, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/trusted_execution (boolean)

    YANG Description: This VM should be allocated from trusted pool
    """
    return self.__trusted_execution
      
  def _set_trusted_execution(self, v, load=False):
    """
    Setter method for trusted_execution, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/trusted_execution (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trusted_execution is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trusted_execution() directly.

    YANG Description: This VM should be allocated from trusted pool
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="trusted-execution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trusted_execution must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trusted-execution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__trusted_execution = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trusted_execution(self):
    self.__trusted_execution = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trusted-execution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_mempage_size(self):
    """
    Getter method for mempage_size, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mempage_size (enumeration)

    YANG Description: Memory page allocation size. If a VM requires
hugepages, it should choose LARGE or SIZE_2MB
or SIZE_1GB. If the VM prefers hugepages it
should choose PREFER_LARGE.
LARGE        : Require hugepages (either 2MB or 1GB)
SMALL        : Doesn't require hugepages
SIZE_2MB     : Requires 2MB hugepages
SIZE_1GB     : Requires 1GB hugepages
PREFER_LARGE : Application prefers hugepages
    """
    return self.__mempage_size
      
  def _set_mempage_size(self, v, load=False):
    """
    Setter method for mempage_size, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mempage_size (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mempage_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mempage_size() directly.

    YANG Description: Memory page allocation size. If a VM requires
hugepages, it should choose LARGE or SIZE_2MB
or SIZE_1GB. If the VM prefers hugepages it
should choose PREFER_LARGE.
LARGE        : Require hugepages (either 2MB or 1GB)
SMALL        : Doesn't require hugepages
SIZE_2MB     : Requires 2MB hugepages
SIZE_1GB     : Requires 1GB hugepages
PREFER_LARGE : Application prefers hugepages
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LARGE': {}, u'SMALL': {}, u'SIZE_1GB': {}, u'SIZE_2MB': {}, u'PREFER_LARGE': {}},), is_leaf=True, yang_name="mempage-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mempage_size must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LARGE': {}, u'SMALL': {}, u'SIZE_1GB': {}, u'SIZE_2MB': {}, u'PREFER_LARGE': {}},), is_leaf=True, yang_name="mempage-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__mempage_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mempage_size(self):
    self.__mempage_size = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LARGE': {}, u'SMALL': {}, u'SIZE_1GB': {}, u'SIZE_2MB': {}, u'PREFER_LARGE': {}},), is_leaf=True, yang_name="mempage-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_cpu_pinning_policy(self):
    """
    Getter method for cpu_pinning_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_pinning_policy (enumeration)

    YANG Description: CPU pinning policy describes association
between virtual CPUs in guest and the
physical CPUs in the host.
DEDICATED : Virtual CPUs are pinned to
            physical CPUs
SHARED    : Multiple VMs may share the
            same physical CPUs.
ANY       : Any policy is acceptable for the VM
    """
    return self.__cpu_pinning_policy
      
  def _set_cpu_pinning_policy(self, v, load=False):
    """
    Setter method for cpu_pinning_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_pinning_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_pinning_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_pinning_policy() directly.

    YANG Description: CPU pinning policy describes association
between virtual CPUs in guest and the
physical CPUs in the host.
DEDICATED : Virtual CPUs are pinned to
            physical CPUs
SHARED    : Multiple VMs may share the
            same physical CPUs.
ANY       : Any policy is acceptable for the VM
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'SHARED': {}, u'DEDICATED': {}, u'ANY': {}},), default=six.text_type("ANY"), is_leaf=True, yang_name="cpu-pinning-policy", parent=self, choice=(u'cpu-policy', u'cpu-pinning'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_pinning_policy must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'SHARED': {}, u'DEDICATED': {}, u'ANY': {}},), default=six.text_type("ANY"), is_leaf=True, yang_name="cpu-pinning-policy", parent=self, choice=(u'cpu-policy', u'cpu-pinning'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cpu_pinning_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_pinning_policy(self):
    self.__cpu_pinning_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'SHARED': {}, u'DEDICATED': {}, u'ANY': {}},), default=six.text_type("ANY"), is_leaf=True, yang_name="cpu-pinning-policy", parent=self, choice=(u'cpu-policy', u'cpu-pinning'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_cpu_thread_pinning_policy(self):
    """
    Getter method for cpu_thread_pinning_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_thread_pinning_policy (enumeration)

    YANG Description: CPU thread pinning policy describes how to
place the guest CPUs when the host supports
hyper threads:
AVOID   : Avoids placing a guest on a host
          with threads.
SEPARATE: Places vCPUs on separate cores,
          and avoids placing two vCPUs on
          two threads of same core.
ISOLATE : Places each vCPU on a different core,
          and places no vCPUs from a different
          guest on the same core.
PREFER  : Attempts to place vCPUs on threads
          of the same core.
    """
    return self.__cpu_thread_pinning_policy
      
  def _set_cpu_thread_pinning_policy(self, v, load=False):
    """
    Setter method for cpu_thread_pinning_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_thread_pinning_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_thread_pinning_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_thread_pinning_policy() directly.

    YANG Description: CPU thread pinning policy describes how to
place the guest CPUs when the host supports
hyper threads:
AVOID   : Avoids placing a guest on a host
          with threads.
SEPARATE: Places vCPUs on separate cores,
          and avoids placing two vCPUs on
          two threads of same core.
ISOLATE : Places each vCPU on a different core,
          and places no vCPUs from a different
          guest on the same core.
PREFER  : Attempts to place vCPUs on threads
          of the same core.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER': {}, u'AVOID': {}, u'ISOLATE': {}, u'SEPARATE': {}},), is_leaf=True, yang_name="cpu-thread-pinning-policy", parent=self, choice=(u'cpu-policy', u'cpu-pinning'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_thread_pinning_policy must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER': {}, u'AVOID': {}, u'ISOLATE': {}, u'SEPARATE': {}},), is_leaf=True, yang_name="cpu-thread-pinning-policy", parent=self, choice=(u'cpu-policy', u'cpu-pinning'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cpu_thread_pinning_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_thread_pinning_policy(self):
    self.__cpu_thread_pinning_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER': {}, u'AVOID': {}, u'ISOLATE': {}, u'SEPARATE': {}},), is_leaf=True, yang_name="cpu-thread-pinning-policy", parent=self, choice=(u'cpu-policy', u'cpu-pinning'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_cpu_quota(self):
    """
    Getter method for cpu_quota, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_quota (container)

    YANG Description: CPU quota describes the CPU resource allocation policy.
Limit and Reserve values are defined in MHz
    """
    return self.__cpu_quota
      
  def _set_cpu_quota(self, v, load=False):
    """
    Setter method for cpu_quota, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_quota (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_quota is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_quota() directly.

    YANG Description: CPU quota describes the CPU resource allocation policy.
Limit and Reserve values are defined in MHz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cpu_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_cpu_quota, is_container='container', yang_name="cpu-quota", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_quota must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cpu_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_cpu_quota, is_container='container', yang_name="cpu-quota", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__cpu_quota = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_quota(self):
    self.__cpu_quota = YANGDynClass(base=yc_cpu_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_cpu_quota, is_container='container', yang_name="cpu-quota", parent=self, choice=(u'cpu-policy', u'cpu-quota'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_mem_quota(self):
    """
    Getter method for mem_quota, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mem_quota (container)

    YANG Description: Memory quota describes the memory resource allocation policy.
Limit and Reserve values are defined in MB
    """
    return self.__mem_quota
      
  def _set_mem_quota(self, v, load=False):
    """
    Setter method for mem_quota, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mem_quota (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mem_quota is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mem_quota() directly.

    YANG Description: Memory quota describes the memory resource allocation policy.
Limit and Reserve values are defined in MB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mem_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_mem_quota, is_container='container', yang_name="mem-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mem_quota must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mem_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_mem_quota, is_container='container', yang_name="mem-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__mem_quota = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mem_quota(self):
    self.__mem_quota = YANGDynClass(base=yc_mem_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_mem_quota, is_container='container', yang_name="mem-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_disk_io_quota(self):
    """
    Getter method for disk_io_quota, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/disk_io_quota (container)

    YANG Description: Disk IO quota describes the disk IO operations resource allocation policy.
Limit and Reserve values are defined in IOPS
    """
    return self.__disk_io_quota
      
  def _set_disk_io_quota(self, v, load=False):
    """
    Setter method for disk_io_quota, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/disk_io_quota (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disk_io_quota is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disk_io_quota() directly.

    YANG Description: Disk IO quota describes the disk IO operations resource allocation policy.
Limit and Reserve values are defined in IOPS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_disk_io_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_disk_io_quota, is_container='container', yang_name="disk-io-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disk_io_quota must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_disk_io_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_disk_io_quota, is_container='container', yang_name="disk-io-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__disk_io_quota = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disk_io_quota(self):
    self.__disk_io_quota = YANGDynClass(base=yc_disk_io_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_disk_io_quota, is_container='container', yang_name="disk-io-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_vif_quota(self):
    """
    Getter method for vif_quota, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/vif_quota (container)

    YANG Description: Virtual interfaces quota describes the virtual interface bandwidth resource allocation policy.
Limit and Reserve values are defined in Mbps
    """
    return self.__vif_quota
      
  def _set_vif_quota(self, v, load=False):
    """
    Setter method for vif_quota, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/vif_quota (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vif_quota is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vif_quota() directly.

    YANG Description: Virtual interfaces quota describes the virtual interface bandwidth resource allocation policy.
Limit and Reserve values are defined in Mbps
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vif_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_vif_quota, is_container='container', yang_name="vif-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vif_quota must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vif_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_vif_quota, is_container='container', yang_name="vif-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__vif_quota = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vif_quota(self):
    self.__vif_quota = YANGDynClass(base=yc_vif_quota_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_vif_quota, is_container='container', yang_name="vif-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_pcie_device(self):
    """
    Getter method for pcie_device, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device (list)

    YANG Description: List of pcie passthrough devices.
    """
    return self.__pcie_device
      
  def _set_pcie_device(self, v, load=False):
    """
    Setter method for pcie_device, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pcie_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pcie_device() directly.

    YANG Description: List of pcie passthrough devices.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("device_id",yc_pcie_device_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_pcie_device, yang_name="pcie-device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='device-id', extensions=None), is_container='list', yang_name="pcie-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pcie_device must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("device_id",yc_pcie_device_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_pcie_device, yang_name="pcie-device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='device-id', extensions=None), is_container='list', yang_name="pcie-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__pcie_device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pcie_device(self):
    self.__pcie_device = YANGDynClass(base=YANGListType("device_id",yc_pcie_device_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_pcie_device, yang_name="pcie-device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='device-id', extensions=None), is_container='list', yang_name="pcie-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_numa_unaware(self):
    """
    Getter method for numa_unaware, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_unaware (empty)
    """
    return self.__numa_unaware
      
  def _set_numa_unaware(self, v, load=False):
    """
    Setter method for numa_unaware, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_unaware (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numa_unaware is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numa_unaware() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="numa-unaware", parent=self, choice=(u'numa-policy', u'numa-unaware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numa_unaware must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-unaware", parent=self, choice=(u'numa-policy', u'numa-unaware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='empty', is_config=True)""",
        })

    self.__numa_unaware = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numa_unaware(self):
    self.__numa_unaware = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-unaware", parent=self, choice=(u'numa-policy', u'numa-unaware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='empty', is_config=True)


  def _get_numa_node_policy(self):
    """
    Getter method for numa_node_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy (container)

    YANG Description: This policy defines NUMA topology of the
guest. Specifically identifies if the guest
should be run on a host with one NUMA
node or multiple NUMA nodes. As an example
a guest might need 8 VCPUs and 4 GB of
memory. However, it might need the VCPUs
and memory distributed across multiple
NUMA nodes. In this scenario, NUMA node
1 could run with 6 VCPUs and 3GB, and
NUMA node 2 could run with 2 VCPUs and
1GB.
    """
    return self.__numa_node_policy
      
  def _set_numa_node_policy(self, v, load=False):
    """
    Setter method for numa_node_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numa_node_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numa_node_policy() directly.

    YANG Description: This policy defines NUMA topology of the
guest. Specifically identifies if the guest
should be run on a host with one NUMA
node or multiple NUMA nodes. As an example
a guest might need 8 VCPUs and 4 GB of
memory. However, it might need the VCPUs
and memory distributed across multiple
NUMA nodes. In this scenario, NUMA node
1 could run with 6 VCPUs and 3GB, and
NUMA node 2 could run with 2 VCPUs and
1GB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_numa_node_policy_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy, is_container='container', yang_name="numa-node-policy", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numa_node_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_numa_node_policy_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy, is_container='container', yang_name="numa-node-policy", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__numa_node_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numa_node_policy(self):
    self.__numa_node_policy = YANGDynClass(base=yc_numa_node_policy_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy, is_container='container', yang_name="numa-node-policy", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  trusted_execution = __builtin__.property(_get_trusted_execution, _set_trusted_execution)
  mempage_size = __builtin__.property(_get_mempage_size, _set_mempage_size)
  cpu_pinning_policy = __builtin__.property(_get_cpu_pinning_policy, _set_cpu_pinning_policy)
  cpu_thread_pinning_policy = __builtin__.property(_get_cpu_thread_pinning_policy, _set_cpu_thread_pinning_policy)
  cpu_quota = __builtin__.property(_get_cpu_quota, _set_cpu_quota)
  mem_quota = __builtin__.property(_get_mem_quota, _set_mem_quota)
  disk_io_quota = __builtin__.property(_get_disk_io_quota, _set_disk_io_quota)
  vif_quota = __builtin__.property(_get_vif_quota, _set_vif_quota)
  pcie_device = __builtin__.property(_get_pcie_device, _set_pcie_device)
  numa_unaware = __builtin__.property(_get_numa_unaware, _set_numa_unaware)
  numa_node_policy = __builtin__.property(_get_numa_node_policy, _set_numa_node_policy)

  __choices__ = {u'numa-policy': {u'numa-unaware': [u'numa_unaware'], u'numa-aware': [u'numa_node_policy']}, u'cpu-policy': {u'cpu-quota': [u'cpu_quota'], u'cpu-pinning': [u'cpu_pinning_policy', u'cpu_thread_pinning_policy']}}
  _pyangbind_elements = OrderedDict([('trusted_execution', trusted_execution), ('mempage_size', mempage_size), ('cpu_pinning_policy', cpu_pinning_policy), ('cpu_thread_pinning_policy', cpu_thread_pinning_policy), ('cpu_quota', cpu_quota), ('mem_quota', mem_quota), ('disk_io_quota', disk_io_quota), ('vif_quota', vif_quota), ('pcie_device', pcie_device), ('numa_unaware', numa_unaware), ('numa_node_policy', numa_node_policy), ])


class yc_vswitch_epa_vnfd__vnfd_catalog_vnfd_vdu_vswitch_epa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vswitch-epa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ovs_acceleration','__ovs_offload',)

  _yang_name = 'vswitch-epa'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ovs_acceleration = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MANDATORY': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="ovs-acceleration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__ovs_offload = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MANDATORY': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="ovs-offload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vswitch-epa']

  def _get_ovs_acceleration(self):
    """
    Getter method for ovs_acceleration, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa/ovs_acceleration (enumeration)

    YANG Description: Specifies Open vSwitch acceleration mode.
MANDATORY: OVS acceleration is required
PREFERRED: OVS acceleration is preferred
    """
    return self.__ovs_acceleration
      
  def _set_ovs_acceleration(self, v, load=False):
    """
    Setter method for ovs_acceleration, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa/ovs_acceleration (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ovs_acceleration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ovs_acceleration() directly.

    YANG Description: Specifies Open vSwitch acceleration mode.
MANDATORY: OVS acceleration is required
PREFERRED: OVS acceleration is preferred
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MANDATORY': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="ovs-acceleration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ovs_acceleration must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MANDATORY': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="ovs-acceleration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__ovs_acceleration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ovs_acceleration(self):
    self.__ovs_acceleration = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MANDATORY': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="ovs-acceleration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_ovs_offload(self):
    """
    Getter method for ovs_offload, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa/ovs_offload (enumeration)

    YANG Description: Specifies Open vSwitch hardware offload mode.
MANDATORY: OVS offload is required
PREFERRED: OVS offload is preferred
    """
    return self.__ovs_offload
      
  def _set_ovs_offload(self, v, load=False):
    """
    Setter method for ovs_offload, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa/ovs_offload (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ovs_offload is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ovs_offload() directly.

    YANG Description: Specifies Open vSwitch hardware offload mode.
MANDATORY: OVS offload is required
PREFERRED: OVS offload is preferred
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MANDATORY': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="ovs-offload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ovs_offload must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MANDATORY': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="ovs-offload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__ovs_offload = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ovs_offload(self):
    self.__ovs_offload = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MANDATORY': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="ovs-offload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  ovs_acceleration = __builtin__.property(_get_ovs_acceleration, _set_ovs_acceleration)
  ovs_offload = __builtin__.property(_get_ovs_offload, _set_ovs_offload)


  _pyangbind_elements = OrderedDict([('ovs_acceleration', ovs_acceleration), ('ovs_offload', ovs_offload), ])


class yc_hypervisor_epa_vnfd__vnfd_catalog_vnfd_vdu_hypervisor_epa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/hypervisor-epa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__version',)

  _yang_name = 'hypervisor-epa'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_KVM': {}, u'PREFER_KVM': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'hypervisor-epa']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa/type (enumeration)

    YANG Description: Specifies the type of hypervisor.
KVM: KVM
XEN: XEN
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the type of hypervisor.
KVM: KVM
XEN: XEN
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_KVM': {}, u'PREFER_KVM': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_KVM': {}, u'PREFER_KVM': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_KVM': {}, u'PREFER_KVM': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa/version (string)
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('type', type), ('version', version), ])


class yc_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_cpu_feature(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/host-epa/cpu-feature. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of CPU features.
  """
  __slots__ = ('_path_helper', '_extmethods', '__feature',)

  _yang_name = 'cpu-feature'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__feature = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER_SEP': {}, u'REQUIRE_SEP': {}, u'REQUIRE_ERMS': {}, u'PREFER_TSC': {}, u'PREFER_FMA': {}, u'PREFER_MONITOR': {}, u'PREFER_PDCM': {}, u'PREFER_FXSR': {}, u'PREFER_SSE4_2': {}, u'REQUIRE_PNI': {}, u'REQUIRE_SSE4_2': {}, u'PREFER_SMX': {}, u'REQUIRE_SMX': {}, u'PREFER_DDIO': {}, u'REQUIRE_MPX': {}, u'REQUIRE_FXSR': {}, u'PREFER_MOVBE': {}, u'REQUIRE_TM': {}, u'PREFER_PGE': {}, u'REQUIRE_PSE': {}, u'REQUIRE_DE': {}, u'PREFER_HLE': {}, u'REQUIRE_XTPR': {}, u'REQUIRE_DTES64': {}, u'REQUIRE_BMI1': {}, u'REQUIRE_BMI2': {}, u'REQUIRE_PCID': {}, u'REQUIRE_PDCM': {}, u'REQUIRE_CLFLUSH': {}, u'REQUIRE_SSE2': {}, u'PREFER_MTRR': {}, u'PREFER_AVX': {}, u'REQUIRE_SS': {}, u'PREFER_F16C': {}, u'REQUIRE_DTS': {}, u'REQUIRE_PCLMULQDQ': {}, u'REQUIRE_MTRR': {}, u'PREFER_SMAP': {}, u'PREFER_MPX': {}, u'REQUIRE_TSC': {}, u'PREFER_VMX': {}, u'REQUIRE_SMEP': {}, u'PREFER_AES': {}, u'PREFER_RDTSCP': {}, u'PREFER_CID': {}, u'REQUIRE_CID': {}, u'PREFER_VME': {}, u'REQUIRE_SSSE3': {}, u'PREFER_CAT': {}, u'REQUIRE_CAT': {}, u'PREFER_TM2': {}, u'PREFER_CMOV': {}, u'PREFER_PAE': {}, u'PREFER_CLFLUSH': {}, u'PREFER_RTM': {}, u'REQUIRE_MMX': {}, u'PREFER_PAT': {}, u'PREFER_INVPCID': {}, u'REQUIRE_RTM': {}, u'PREFER_TSC_DEADLINE_TIMER': {}, u'PREFER_POPCNT': {}, u'REQUIRE_TM2': {}, u'REQUIRE_CX16': {}, u'REQUIRE_TSC_DEADLINE_TIMER': {}, u'REQUIRE_APIC': {}, u'PREFER_PNI': {}, u'REQUIRE_DS_CPL': {}, u'REQUIRE_SSE4_1': {}, u'PREFER_FSGSBASE': {}, u'PREFER_SSSE3': {}, u'REQUIRE_PSE36': {}, u'PREFER_ADX': {}, u'PREFER_CX8': {}, u'PREFER_ERMS': {}, u'PREFER_HT': {}, u'PREFER_SSE2': {}, u'PREFER_AVX2': {}, u'REQUIRE_PGE': {}, u'REQUIRE_HLE': {}, u'PREFER_BMI2': {}, u'PREFER_BMI1': {}, u'PREFER_PCLMULQDQ': {}, u'PREFER_CX16': {}, u'REQUIRE_POPCNT': {}, u'PREFER_EST': {}, u'REQUIRE_FMA': {}, u'REQUIRE_EST': {}, u'PREFER_DTES64': {}, u'PREFER_APIC': {}, u'REQUIRE_ADX': {}, u'REQUIRE_FSGSBASE': {}, u'PREFER_XSAVE': {}, u'REQUIRE_IA64': {}, u'PREFER_DCA': {}, u'PREFER_SMEP': {}, u'PREFER_SSE4_1': {}, u'REQUIRE_RDTSCP': {}, u'REQUIRE_DDIO': {}, u'PREFER_ACPI': {}, u'REQUIRE_AES': {}, u'REQUIRE_HT': {}, u'PREFER_MMX': {}, u'REQUIRE_MOVBE': {}, u'REQUIRE_INVPCID': {}, u'PREFER_PSE': {}, u'PREFER_DS_CPL': {}, u'REQUIRE_CX8': {}, u'REQUIRE_AVX': {}, u'PREFER_PCID': {}, u'PREFER_IA64': {}, u'REQUIRE_X2APIC': {}, u'PREFER_TM': {}, u'REQUIRE_SMAP': {}, u'REQUIRE_MONITOR': {}, u'PREFER_RDSEED': {}, u'REQUIRE_CMOV': {}, u'PREFER_X2APIC': {}, u'REQUIRE_DCA': {}, u'REQUIRE_XSAVE': {}, u'REQUIRE_AVX2': {}, u'PREFER_SS': {}, u'REQUIRE_VME': {}, u'REQUIRE_ACPI': {}, u'REQUIRE_PBE': {}, u'PREFER_MSR': {}, u'REQUIRE_VMX': {}, u'PREFER_CMT': {}, u'REQUIRE_CMT': {}, u'PREFER_PSE36': {}, u'REQUIRE_RDSEED': {}, u'PREFER_XTPR': {}, u'REQUIRE_RDRAND': {}, u'REQUIRE_MCE': {}, u'REQUIRE_MCA': {}, u'REQUIRE_F16C': {}, u'PREFER_DE': {}, u'PREFER_DTS': {}, u'REQUIRE_PAT': {}, u'PREFER_SSE': {}, u'REQUIRE_SSE': {}, u'REQUIRE_MSR': {}, u'PREFER_RDRAND': {}, u'PREFER_MCA': {}, u'PREFER_MCE': {}, u'REQUIRE_PAE': {}, u'PREFER_PBE': {}},), is_leaf=True, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='cpu-feature-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'host-epa', u'cpu-feature']

  def _get_feature(self):
    """
    Getter method for feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_feature/feature (cpu-feature-type)

    YANG Description: CPU feature.
    """
    return self.__feature
      
  def _set_feature(self, v, load=False):
    """
    Setter method for feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_feature/feature (cpu-feature-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature() directly.

    YANG Description: CPU feature.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER_SEP': {}, u'REQUIRE_SEP': {}, u'REQUIRE_ERMS': {}, u'PREFER_TSC': {}, u'PREFER_FMA': {}, u'PREFER_MONITOR': {}, u'PREFER_PDCM': {}, u'PREFER_FXSR': {}, u'PREFER_SSE4_2': {}, u'REQUIRE_PNI': {}, u'REQUIRE_SSE4_2': {}, u'PREFER_SMX': {}, u'REQUIRE_SMX': {}, u'PREFER_DDIO': {}, u'REQUIRE_MPX': {}, u'REQUIRE_FXSR': {}, u'PREFER_MOVBE': {}, u'REQUIRE_TM': {}, u'PREFER_PGE': {}, u'REQUIRE_PSE': {}, u'REQUIRE_DE': {}, u'PREFER_HLE': {}, u'REQUIRE_XTPR': {}, u'REQUIRE_DTES64': {}, u'REQUIRE_BMI1': {}, u'REQUIRE_BMI2': {}, u'REQUIRE_PCID': {}, u'REQUIRE_PDCM': {}, u'REQUIRE_CLFLUSH': {}, u'REQUIRE_SSE2': {}, u'PREFER_MTRR': {}, u'PREFER_AVX': {}, u'REQUIRE_SS': {}, u'PREFER_F16C': {}, u'REQUIRE_DTS': {}, u'REQUIRE_PCLMULQDQ': {}, u'REQUIRE_MTRR': {}, u'PREFER_SMAP': {}, u'PREFER_MPX': {}, u'REQUIRE_TSC': {}, u'PREFER_VMX': {}, u'REQUIRE_SMEP': {}, u'PREFER_AES': {}, u'PREFER_RDTSCP': {}, u'PREFER_CID': {}, u'REQUIRE_CID': {}, u'PREFER_VME': {}, u'REQUIRE_SSSE3': {}, u'PREFER_CAT': {}, u'REQUIRE_CAT': {}, u'PREFER_TM2': {}, u'PREFER_CMOV': {}, u'PREFER_PAE': {}, u'PREFER_CLFLUSH': {}, u'PREFER_RTM': {}, u'REQUIRE_MMX': {}, u'PREFER_PAT': {}, u'PREFER_INVPCID': {}, u'REQUIRE_RTM': {}, u'PREFER_TSC_DEADLINE_TIMER': {}, u'PREFER_POPCNT': {}, u'REQUIRE_TM2': {}, u'REQUIRE_CX16': {}, u'REQUIRE_TSC_DEADLINE_TIMER': {}, u'REQUIRE_APIC': {}, u'PREFER_PNI': {}, u'REQUIRE_DS_CPL': {}, u'REQUIRE_SSE4_1': {}, u'PREFER_FSGSBASE': {}, u'PREFER_SSSE3': {}, u'REQUIRE_PSE36': {}, u'PREFER_ADX': {}, u'PREFER_CX8': {}, u'PREFER_ERMS': {}, u'PREFER_HT': {}, u'PREFER_SSE2': {}, u'PREFER_AVX2': {}, u'REQUIRE_PGE': {}, u'REQUIRE_HLE': {}, u'PREFER_BMI2': {}, u'PREFER_BMI1': {}, u'PREFER_PCLMULQDQ': {}, u'PREFER_CX16': {}, u'REQUIRE_POPCNT': {}, u'PREFER_EST': {}, u'REQUIRE_FMA': {}, u'REQUIRE_EST': {}, u'PREFER_DTES64': {}, u'PREFER_APIC': {}, u'REQUIRE_ADX': {}, u'REQUIRE_FSGSBASE': {}, u'PREFER_XSAVE': {}, u'REQUIRE_IA64': {}, u'PREFER_DCA': {}, u'PREFER_SMEP': {}, u'PREFER_SSE4_1': {}, u'REQUIRE_RDTSCP': {}, u'REQUIRE_DDIO': {}, u'PREFER_ACPI': {}, u'REQUIRE_AES': {}, u'REQUIRE_HT': {}, u'PREFER_MMX': {}, u'REQUIRE_MOVBE': {}, u'REQUIRE_INVPCID': {}, u'PREFER_PSE': {}, u'PREFER_DS_CPL': {}, u'REQUIRE_CX8': {}, u'REQUIRE_AVX': {}, u'PREFER_PCID': {}, u'PREFER_IA64': {}, u'REQUIRE_X2APIC': {}, u'PREFER_TM': {}, u'REQUIRE_SMAP': {}, u'REQUIRE_MONITOR': {}, u'PREFER_RDSEED': {}, u'REQUIRE_CMOV': {}, u'PREFER_X2APIC': {}, u'REQUIRE_DCA': {}, u'REQUIRE_XSAVE': {}, u'REQUIRE_AVX2': {}, u'PREFER_SS': {}, u'REQUIRE_VME': {}, u'REQUIRE_ACPI': {}, u'REQUIRE_PBE': {}, u'PREFER_MSR': {}, u'REQUIRE_VMX': {}, u'PREFER_CMT': {}, u'REQUIRE_CMT': {}, u'PREFER_PSE36': {}, u'REQUIRE_RDSEED': {}, u'PREFER_XTPR': {}, u'REQUIRE_RDRAND': {}, u'REQUIRE_MCE': {}, u'REQUIRE_MCA': {}, u'REQUIRE_F16C': {}, u'PREFER_DE': {}, u'PREFER_DTS': {}, u'REQUIRE_PAT': {}, u'PREFER_SSE': {}, u'REQUIRE_SSE': {}, u'REQUIRE_MSR': {}, u'PREFER_RDRAND': {}, u'PREFER_MCA': {}, u'PREFER_MCE': {}, u'REQUIRE_PAE': {}, u'PREFER_PBE': {}},), is_leaf=True, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='cpu-feature-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature must be of a type compatible with cpu-feature-type""",
          'defined-type': "vnfd:cpu-feature-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER_SEP': {}, u'REQUIRE_SEP': {}, u'REQUIRE_ERMS': {}, u'PREFER_TSC': {}, u'PREFER_FMA': {}, u'PREFER_MONITOR': {}, u'PREFER_PDCM': {}, u'PREFER_FXSR': {}, u'PREFER_SSE4_2': {}, u'REQUIRE_PNI': {}, u'REQUIRE_SSE4_2': {}, u'PREFER_SMX': {}, u'REQUIRE_SMX': {}, u'PREFER_DDIO': {}, u'REQUIRE_MPX': {}, u'REQUIRE_FXSR': {}, u'PREFER_MOVBE': {}, u'REQUIRE_TM': {}, u'PREFER_PGE': {}, u'REQUIRE_PSE': {}, u'REQUIRE_DE': {}, u'PREFER_HLE': {}, u'REQUIRE_XTPR': {}, u'REQUIRE_DTES64': {}, u'REQUIRE_BMI1': {}, u'REQUIRE_BMI2': {}, u'REQUIRE_PCID': {}, u'REQUIRE_PDCM': {}, u'REQUIRE_CLFLUSH': {}, u'REQUIRE_SSE2': {}, u'PREFER_MTRR': {}, u'PREFER_AVX': {}, u'REQUIRE_SS': {}, u'PREFER_F16C': {}, u'REQUIRE_DTS': {}, u'REQUIRE_PCLMULQDQ': {}, u'REQUIRE_MTRR': {}, u'PREFER_SMAP': {}, u'PREFER_MPX': {}, u'REQUIRE_TSC': {}, u'PREFER_VMX': {}, u'REQUIRE_SMEP': {}, u'PREFER_AES': {}, u'PREFER_RDTSCP': {}, u'PREFER_CID': {}, u'REQUIRE_CID': {}, u'PREFER_VME': {}, u'REQUIRE_SSSE3': {}, u'PREFER_CAT': {}, u'REQUIRE_CAT': {}, u'PREFER_TM2': {}, u'PREFER_CMOV': {}, u'PREFER_PAE': {}, u'PREFER_CLFLUSH': {}, u'PREFER_RTM': {}, u'REQUIRE_MMX': {}, u'PREFER_PAT': {}, u'PREFER_INVPCID': {}, u'REQUIRE_RTM': {}, u'PREFER_TSC_DEADLINE_TIMER': {}, u'PREFER_POPCNT': {}, u'REQUIRE_TM2': {}, u'REQUIRE_CX16': {}, u'REQUIRE_TSC_DEADLINE_TIMER': {}, u'REQUIRE_APIC': {}, u'PREFER_PNI': {}, u'REQUIRE_DS_CPL': {}, u'REQUIRE_SSE4_1': {}, u'PREFER_FSGSBASE': {}, u'PREFER_SSSE3': {}, u'REQUIRE_PSE36': {}, u'PREFER_ADX': {}, u'PREFER_CX8': {}, u'PREFER_ERMS': {}, u'PREFER_HT': {}, u'PREFER_SSE2': {}, u'PREFER_AVX2': {}, u'REQUIRE_PGE': {}, u'REQUIRE_HLE': {}, u'PREFER_BMI2': {}, u'PREFER_BMI1': {}, u'PREFER_PCLMULQDQ': {}, u'PREFER_CX16': {}, u'REQUIRE_POPCNT': {}, u'PREFER_EST': {}, u'REQUIRE_FMA': {}, u'REQUIRE_EST': {}, u'PREFER_DTES64': {}, u'PREFER_APIC': {}, u'REQUIRE_ADX': {}, u'REQUIRE_FSGSBASE': {}, u'PREFER_XSAVE': {}, u'REQUIRE_IA64': {}, u'PREFER_DCA': {}, u'PREFER_SMEP': {}, u'PREFER_SSE4_1': {}, u'REQUIRE_RDTSCP': {}, u'REQUIRE_DDIO': {}, u'PREFER_ACPI': {}, u'REQUIRE_AES': {}, u'REQUIRE_HT': {}, u'PREFER_MMX': {}, u'REQUIRE_MOVBE': {}, u'REQUIRE_INVPCID': {}, u'PREFER_PSE': {}, u'PREFER_DS_CPL': {}, u'REQUIRE_CX8': {}, u'REQUIRE_AVX': {}, u'PREFER_PCID': {}, u'PREFER_IA64': {}, u'REQUIRE_X2APIC': {}, u'PREFER_TM': {}, u'REQUIRE_SMAP': {}, u'REQUIRE_MONITOR': {}, u'PREFER_RDSEED': {}, u'REQUIRE_CMOV': {}, u'PREFER_X2APIC': {}, u'REQUIRE_DCA': {}, u'REQUIRE_XSAVE': {}, u'REQUIRE_AVX2': {}, u'PREFER_SS': {}, u'REQUIRE_VME': {}, u'REQUIRE_ACPI': {}, u'REQUIRE_PBE': {}, u'PREFER_MSR': {}, u'REQUIRE_VMX': {}, u'PREFER_CMT': {}, u'REQUIRE_CMT': {}, u'PREFER_PSE36': {}, u'REQUIRE_RDSEED': {}, u'PREFER_XTPR': {}, u'REQUIRE_RDRAND': {}, u'REQUIRE_MCE': {}, u'REQUIRE_MCA': {}, u'REQUIRE_F16C': {}, u'PREFER_DE': {}, u'PREFER_DTS': {}, u'REQUIRE_PAT': {}, u'PREFER_SSE': {}, u'REQUIRE_SSE': {}, u'REQUIRE_MSR': {}, u'PREFER_RDRAND': {}, u'PREFER_MCA': {}, u'PREFER_MCE': {}, u'REQUIRE_PAE': {}, u'PREFER_PBE': {}},), is_leaf=True, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='cpu-feature-type', is_config=True)""",
        })

    self.__feature = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature(self):
    self.__feature = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER_SEP': {}, u'REQUIRE_SEP': {}, u'REQUIRE_ERMS': {}, u'PREFER_TSC': {}, u'PREFER_FMA': {}, u'PREFER_MONITOR': {}, u'PREFER_PDCM': {}, u'PREFER_FXSR': {}, u'PREFER_SSE4_2': {}, u'REQUIRE_PNI': {}, u'REQUIRE_SSE4_2': {}, u'PREFER_SMX': {}, u'REQUIRE_SMX': {}, u'PREFER_DDIO': {}, u'REQUIRE_MPX': {}, u'REQUIRE_FXSR': {}, u'PREFER_MOVBE': {}, u'REQUIRE_TM': {}, u'PREFER_PGE': {}, u'REQUIRE_PSE': {}, u'REQUIRE_DE': {}, u'PREFER_HLE': {}, u'REQUIRE_XTPR': {}, u'REQUIRE_DTES64': {}, u'REQUIRE_BMI1': {}, u'REQUIRE_BMI2': {}, u'REQUIRE_PCID': {}, u'REQUIRE_PDCM': {}, u'REQUIRE_CLFLUSH': {}, u'REQUIRE_SSE2': {}, u'PREFER_MTRR': {}, u'PREFER_AVX': {}, u'REQUIRE_SS': {}, u'PREFER_F16C': {}, u'REQUIRE_DTS': {}, u'REQUIRE_PCLMULQDQ': {}, u'REQUIRE_MTRR': {}, u'PREFER_SMAP': {}, u'PREFER_MPX': {}, u'REQUIRE_TSC': {}, u'PREFER_VMX': {}, u'REQUIRE_SMEP': {}, u'PREFER_AES': {}, u'PREFER_RDTSCP': {}, u'PREFER_CID': {}, u'REQUIRE_CID': {}, u'PREFER_VME': {}, u'REQUIRE_SSSE3': {}, u'PREFER_CAT': {}, u'REQUIRE_CAT': {}, u'PREFER_TM2': {}, u'PREFER_CMOV': {}, u'PREFER_PAE': {}, u'PREFER_CLFLUSH': {}, u'PREFER_RTM': {}, u'REQUIRE_MMX': {}, u'PREFER_PAT': {}, u'PREFER_INVPCID': {}, u'REQUIRE_RTM': {}, u'PREFER_TSC_DEADLINE_TIMER': {}, u'PREFER_POPCNT': {}, u'REQUIRE_TM2': {}, u'REQUIRE_CX16': {}, u'REQUIRE_TSC_DEADLINE_TIMER': {}, u'REQUIRE_APIC': {}, u'PREFER_PNI': {}, u'REQUIRE_DS_CPL': {}, u'REQUIRE_SSE4_1': {}, u'PREFER_FSGSBASE': {}, u'PREFER_SSSE3': {}, u'REQUIRE_PSE36': {}, u'PREFER_ADX': {}, u'PREFER_CX8': {}, u'PREFER_ERMS': {}, u'PREFER_HT': {}, u'PREFER_SSE2': {}, u'PREFER_AVX2': {}, u'REQUIRE_PGE': {}, u'REQUIRE_HLE': {}, u'PREFER_BMI2': {}, u'PREFER_BMI1': {}, u'PREFER_PCLMULQDQ': {}, u'PREFER_CX16': {}, u'REQUIRE_POPCNT': {}, u'PREFER_EST': {}, u'REQUIRE_FMA': {}, u'REQUIRE_EST': {}, u'PREFER_DTES64': {}, u'PREFER_APIC': {}, u'REQUIRE_ADX': {}, u'REQUIRE_FSGSBASE': {}, u'PREFER_XSAVE': {}, u'REQUIRE_IA64': {}, u'PREFER_DCA': {}, u'PREFER_SMEP': {}, u'PREFER_SSE4_1': {}, u'REQUIRE_RDTSCP': {}, u'REQUIRE_DDIO': {}, u'PREFER_ACPI': {}, u'REQUIRE_AES': {}, u'REQUIRE_HT': {}, u'PREFER_MMX': {}, u'REQUIRE_MOVBE': {}, u'REQUIRE_INVPCID': {}, u'PREFER_PSE': {}, u'PREFER_DS_CPL': {}, u'REQUIRE_CX8': {}, u'REQUIRE_AVX': {}, u'PREFER_PCID': {}, u'PREFER_IA64': {}, u'REQUIRE_X2APIC': {}, u'PREFER_TM': {}, u'REQUIRE_SMAP': {}, u'REQUIRE_MONITOR': {}, u'PREFER_RDSEED': {}, u'REQUIRE_CMOV': {}, u'PREFER_X2APIC': {}, u'REQUIRE_DCA': {}, u'REQUIRE_XSAVE': {}, u'REQUIRE_AVX2': {}, u'PREFER_SS': {}, u'REQUIRE_VME': {}, u'REQUIRE_ACPI': {}, u'REQUIRE_PBE': {}, u'PREFER_MSR': {}, u'REQUIRE_VMX': {}, u'PREFER_CMT': {}, u'REQUIRE_CMT': {}, u'PREFER_PSE36': {}, u'REQUIRE_RDSEED': {}, u'PREFER_XTPR': {}, u'REQUIRE_RDRAND': {}, u'REQUIRE_MCE': {}, u'REQUIRE_MCA': {}, u'REQUIRE_F16C': {}, u'PREFER_DE': {}, u'PREFER_DTS': {}, u'REQUIRE_PAT': {}, u'PREFER_SSE': {}, u'REQUIRE_SSE': {}, u'REQUIRE_MSR': {}, u'PREFER_RDRAND': {}, u'PREFER_MCA': {}, u'PREFER_MCE': {}, u'REQUIRE_PAE': {}, u'PREFER_PBE': {}},), is_leaf=True, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='cpu-feature-type', is_config=True)

  feature = __builtin__.property(_get_feature, _set_feature)


  _pyangbind_elements = OrderedDict([('feature', feature), ])


class yc_om_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_om_cpu_feature(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/host-epa/om-cpu-feature. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of OpenMANO CPU features
  """
  __slots__ = ('_path_helper', '_extmethods', '__feature',)

  _yang_name = 'om-cpu-feature'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__feature = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'host-epa', u'om-cpu-feature']

  def _get_feature(self):
    """
    Getter method for feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_feature/feature (string)

    YANG Description: CPU feature
    """
    return self.__feature
      
  def _set_feature(self, v, load=False):
    """
    Setter method for feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_feature/feature (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature() directly.

    YANG Description: CPU feature
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__feature = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature(self):
    self.__feature = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  feature = __builtin__.property(_get_feature, _set_feature)


  _pyangbind_elements = OrderedDict([('feature', feature), ])


class yc_host_epa_vnfd__vnfd_catalog_vnfd_vdu_host_epa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/host-epa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the host level EPA attributes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cpu_model','__cpu_arch','__cpu_vendor','__cpu_socket_count','__cpu_core_count','__cpu_core_thread_count','__cpu_feature','__om_cpu_model_string','__om_cpu_feature',)

  _yang_name = 'host-epa'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cpu_arch = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_X86_64': {}, u'PREFER_X86_64': {}, u'REQUIRE_X86': {}, u'REQUIRE_ARMV7': {}, u'PREFER_X86': {}, u'REQUIRE_IA64': {}, u'REQUIRE_ARMV8': {}, u'REQUIRE_I686': {}, u'PREFER_ARMV7': {}, u'PREFER_ARMV8': {}, u'PREFER_I686': {}, u'PREFER_IA64': {}},), is_leaf=True, yang_name="cpu-arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__om_cpu_feature = YANGDynClass(base=YANGListType("feature",yc_om_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_om_cpu_feature, yang_name="om-cpu-feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='feature', extensions=None), is_container='list', yang_name="om-cpu-feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__om_cpu_model_string = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="om-cpu-model-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__cpu_core_thread_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-core-thread-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__cpu_model = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_IVYBRIDGE': {}, u'PREFER_HASWELL': {}, u'PREFER_WESTMERE': {}, u'REQUIRE_WESTMERE': {}, u'PREFER_NEHALEM': {}, u'REQUIRE_PENRYN': {}, u'REQUIRE_SANDYBRIDGE': {}, u'PREFER_BROADWELL': {}, u'REQUIRE_BROADWELL': {}, u'PREFER_CORE2DUO': {}, u'PREFER_CONROE': {}, u'REQUIRE_CORE2DUO': {}, u'REQUIRE_CONROE': {}, u'PREFER_SANDYBRIDGE': {}, u'REQUIRE_HASWELL': {}, u'PREFER_PENRYN': {}, u'PREFER_IVYBRIDGE': {}, u'REQUIRE_NEHALEM': {}},), is_leaf=True, yang_name="cpu-model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__cpu_core_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-core-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__cpu_feature = YANGDynClass(base=YANGListType("feature",yc_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_cpu_feature, yang_name="cpu-feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='feature', extensions=None), is_container='list', yang_name="cpu-feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__cpu_vendor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER_INTEL': {}, u'REQUIRE_INTEL': {}, u'REQUIRE_AMD': {}, u'PREFER_AMD': {}},), is_leaf=True, yang_name="cpu-vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__cpu_socket_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-socket-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'host-epa']

  def _get_cpu_model(self):
    """
    Getter method for cpu_model, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_model (enumeration)

    YANG Description: Host CPU model. Examples include: SandyBridge,
IvyBridge
    """
    return self.__cpu_model
      
  def _set_cpu_model(self, v, load=False):
    """
    Setter method for cpu_model, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_model (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_model is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_model() directly.

    YANG Description: Host CPU model. Examples include: SandyBridge,
IvyBridge
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_IVYBRIDGE': {}, u'PREFER_HASWELL': {}, u'PREFER_WESTMERE': {}, u'REQUIRE_WESTMERE': {}, u'PREFER_NEHALEM': {}, u'REQUIRE_PENRYN': {}, u'REQUIRE_SANDYBRIDGE': {}, u'PREFER_BROADWELL': {}, u'REQUIRE_BROADWELL': {}, u'PREFER_CORE2DUO': {}, u'PREFER_CONROE': {}, u'REQUIRE_CORE2DUO': {}, u'REQUIRE_CONROE': {}, u'PREFER_SANDYBRIDGE': {}, u'REQUIRE_HASWELL': {}, u'PREFER_PENRYN': {}, u'PREFER_IVYBRIDGE': {}, u'REQUIRE_NEHALEM': {}},), is_leaf=True, yang_name="cpu-model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_model must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_IVYBRIDGE': {}, u'PREFER_HASWELL': {}, u'PREFER_WESTMERE': {}, u'REQUIRE_WESTMERE': {}, u'PREFER_NEHALEM': {}, u'REQUIRE_PENRYN': {}, u'REQUIRE_SANDYBRIDGE': {}, u'PREFER_BROADWELL': {}, u'REQUIRE_BROADWELL': {}, u'PREFER_CORE2DUO': {}, u'PREFER_CONROE': {}, u'REQUIRE_CORE2DUO': {}, u'REQUIRE_CONROE': {}, u'PREFER_SANDYBRIDGE': {}, u'REQUIRE_HASWELL': {}, u'PREFER_PENRYN': {}, u'PREFER_IVYBRIDGE': {}, u'REQUIRE_NEHALEM': {}},), is_leaf=True, yang_name="cpu-model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cpu_model = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_model(self):
    self.__cpu_model = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_IVYBRIDGE': {}, u'PREFER_HASWELL': {}, u'PREFER_WESTMERE': {}, u'REQUIRE_WESTMERE': {}, u'PREFER_NEHALEM': {}, u'REQUIRE_PENRYN': {}, u'REQUIRE_SANDYBRIDGE': {}, u'PREFER_BROADWELL': {}, u'REQUIRE_BROADWELL': {}, u'PREFER_CORE2DUO': {}, u'PREFER_CONROE': {}, u'REQUIRE_CORE2DUO': {}, u'REQUIRE_CONROE': {}, u'PREFER_SANDYBRIDGE': {}, u'REQUIRE_HASWELL': {}, u'PREFER_PENRYN': {}, u'PREFER_IVYBRIDGE': {}, u'REQUIRE_NEHALEM': {}},), is_leaf=True, yang_name="cpu-model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_cpu_arch(self):
    """
    Getter method for cpu_arch, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_arch (enumeration)

    YANG Description: Host CPU architecture.
    """
    return self.__cpu_arch
      
  def _set_cpu_arch(self, v, load=False):
    """
    Setter method for cpu_arch, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_arch (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_arch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_arch() directly.

    YANG Description: Host CPU architecture.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_X86_64': {}, u'PREFER_X86_64': {}, u'REQUIRE_X86': {}, u'REQUIRE_ARMV7': {}, u'PREFER_X86': {}, u'REQUIRE_IA64': {}, u'REQUIRE_ARMV8': {}, u'REQUIRE_I686': {}, u'PREFER_ARMV7': {}, u'PREFER_ARMV8': {}, u'PREFER_I686': {}, u'PREFER_IA64': {}},), is_leaf=True, yang_name="cpu-arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_arch must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_X86_64': {}, u'PREFER_X86_64': {}, u'REQUIRE_X86': {}, u'REQUIRE_ARMV7': {}, u'PREFER_X86': {}, u'REQUIRE_IA64': {}, u'REQUIRE_ARMV8': {}, u'REQUIRE_I686': {}, u'PREFER_ARMV7': {}, u'PREFER_ARMV8': {}, u'PREFER_I686': {}, u'PREFER_IA64': {}},), is_leaf=True, yang_name="cpu-arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cpu_arch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_arch(self):
    self.__cpu_arch = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_X86_64': {}, u'PREFER_X86_64': {}, u'REQUIRE_X86': {}, u'REQUIRE_ARMV7': {}, u'PREFER_X86': {}, u'REQUIRE_IA64': {}, u'REQUIRE_ARMV8': {}, u'REQUIRE_I686': {}, u'PREFER_ARMV7': {}, u'PREFER_ARMV8': {}, u'PREFER_I686': {}, u'PREFER_IA64': {}},), is_leaf=True, yang_name="cpu-arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_cpu_vendor(self):
    """
    Getter method for cpu_vendor, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_vendor (enumeration)

    YANG Description: Host CPU Vendor.
    """
    return self.__cpu_vendor
      
  def _set_cpu_vendor(self, v, load=False):
    """
    Setter method for cpu_vendor, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_vendor (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_vendor() directly.

    YANG Description: Host CPU Vendor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER_INTEL': {}, u'REQUIRE_INTEL': {}, u'REQUIRE_AMD': {}, u'PREFER_AMD': {}},), is_leaf=True, yang_name="cpu-vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_vendor must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER_INTEL': {}, u'REQUIRE_INTEL': {}, u'REQUIRE_AMD': {}, u'PREFER_AMD': {}},), is_leaf=True, yang_name="cpu-vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cpu_vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_vendor(self):
    self.__cpu_vendor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER_INTEL': {}, u'REQUIRE_INTEL': {}, u'REQUIRE_AMD': {}, u'PREFER_AMD': {}},), is_leaf=True, yang_name="cpu-vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_cpu_socket_count(self):
    """
    Getter method for cpu_socket_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_socket_count (uint64)

    YANG Description: Number of sockets on the host.
    """
    return self.__cpu_socket_count
      
  def _set_cpu_socket_count(self, v, load=False):
    """
    Setter method for cpu_socket_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_socket_count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_socket_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_socket_count() directly.

    YANG Description: Number of sockets on the host.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-socket-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_socket_count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-socket-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__cpu_socket_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_socket_count(self):
    self.__cpu_socket_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-socket-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_cpu_core_count(self):
    """
    Getter method for cpu_core_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_core_count (uint64)

    YANG Description: Number of cores on the host.
    """
    return self.__cpu_core_count
      
  def _set_cpu_core_count(self, v, load=False):
    """
    Setter method for cpu_core_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_core_count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_core_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_core_count() directly.

    YANG Description: Number of cores on the host.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-core-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_core_count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-core-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__cpu_core_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_core_count(self):
    self.__cpu_core_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-core-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_cpu_core_thread_count(self):
    """
    Getter method for cpu_core_thread_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_core_thread_count (uint64)

    YANG Description: Number of threads per cores on the host.
    """
    return self.__cpu_core_thread_count
      
  def _set_cpu_core_thread_count(self, v, load=False):
    """
    Setter method for cpu_core_thread_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_core_thread_count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_core_thread_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_core_thread_count() directly.

    YANG Description: Number of threads per cores on the host.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-core-thread-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_core_thread_count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-core-thread-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__cpu_core_thread_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_core_thread_count(self):
    self.__cpu_core_thread_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-core-thread-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_cpu_feature(self):
    """
    Getter method for cpu_feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_feature (list)

    YANG Description: List of CPU features.
    """
    return self.__cpu_feature
      
  def _set_cpu_feature(self, v, load=False):
    """
    Setter method for cpu_feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_feature (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_feature() directly.

    YANG Description: List of CPU features.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("feature",yc_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_cpu_feature, yang_name="cpu-feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='feature', extensions=None), is_container='list', yang_name="cpu-feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_feature must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("feature",yc_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_cpu_feature, yang_name="cpu-feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='feature', extensions=None), is_container='list', yang_name="cpu-feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__cpu_feature = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_feature(self):
    self.__cpu_feature = YANGDynClass(base=YANGListType("feature",yc_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_cpu_feature, yang_name="cpu-feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='feature', extensions=None), is_container='list', yang_name="cpu-feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_om_cpu_model_string(self):
    """
    Getter method for om_cpu_model_string, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_model_string (string)

    YANG Description: OpenMANO CPU model string
    """
    return self.__om_cpu_model_string
      
  def _set_om_cpu_model_string(self, v, load=False):
    """
    Setter method for om_cpu_model_string, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_model_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_om_cpu_model_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_om_cpu_model_string() directly.

    YANG Description: OpenMANO CPU model string
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="om-cpu-model-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """om_cpu_model_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="om-cpu-model-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__om_cpu_model_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_om_cpu_model_string(self):
    self.__om_cpu_model_string = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="om-cpu-model-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_om_cpu_feature(self):
    """
    Getter method for om_cpu_feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_feature (list)

    YANG Description: List of OpenMANO CPU features
    """
    return self.__om_cpu_feature
      
  def _set_om_cpu_feature(self, v, load=False):
    """
    Setter method for om_cpu_feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_feature (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_om_cpu_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_om_cpu_feature() directly.

    YANG Description: List of OpenMANO CPU features
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("feature",yc_om_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_om_cpu_feature, yang_name="om-cpu-feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='feature', extensions=None), is_container='list', yang_name="om-cpu-feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """om_cpu_feature must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("feature",yc_om_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_om_cpu_feature, yang_name="om-cpu-feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='feature', extensions=None), is_container='list', yang_name="om-cpu-feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__om_cpu_feature = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_om_cpu_feature(self):
    self.__om_cpu_feature = YANGDynClass(base=YANGListType("feature",yc_om_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_om_cpu_feature, yang_name="om-cpu-feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='feature', extensions=None), is_container='list', yang_name="om-cpu-feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  cpu_model = __builtin__.property(_get_cpu_model, _set_cpu_model)
  cpu_arch = __builtin__.property(_get_cpu_arch, _set_cpu_arch)
  cpu_vendor = __builtin__.property(_get_cpu_vendor, _set_cpu_vendor)
  cpu_socket_count = __builtin__.property(_get_cpu_socket_count, _set_cpu_socket_count)
  cpu_core_count = __builtin__.property(_get_cpu_core_count, _set_cpu_core_count)
  cpu_core_thread_count = __builtin__.property(_get_cpu_core_thread_count, _set_cpu_core_thread_count)
  cpu_feature = __builtin__.property(_get_cpu_feature, _set_cpu_feature)
  om_cpu_model_string = __builtin__.property(_get_om_cpu_model_string, _set_om_cpu_model_string)
  om_cpu_feature = __builtin__.property(_get_om_cpu_feature, _set_om_cpu_feature)


  _pyangbind_elements = OrderedDict([('cpu_model', cpu_model), ('cpu_arch', cpu_arch), ('cpu_vendor', cpu_vendor), ('cpu_socket_count', cpu_socket_count), ('cpu_core_count', cpu_core_count), ('cpu_core_thread_count', cpu_core_thread_count), ('cpu_feature', cpu_feature), ('om_cpu_model_string', om_cpu_model_string), ('om_cpu_feature', om_cpu_feature), ])


class yc_ok_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_ok(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alarm/actions/ok. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__url',)

  _yang_name = 'ok'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'alarm', u'actions', u'ok']

  def _get_url(self):
    """
    Getter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/ok/url (string)
    """
    return self.__url
      
  def _set_url(self, v, load=False):
    """
    Setter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/ok/url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """url must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__url = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_url(self):
    self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  url = __builtin__.property(_get_url, _set_url)


  _pyangbind_elements = OrderedDict([('url', url), ])


class yc_insufficient_data_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_insufficient_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alarm/actions/insufficient-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__url',)

  _yang_name = 'insufficient-data'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'alarm', u'actions', u'insufficient-data']

  def _get_url(self):
    """
    Getter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/insufficient_data/url (string)
    """
    return self.__url
      
  def _set_url(self, v, load=False):
    """
    Setter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/insufficient_data/url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """url must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__url = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_url(self):
    self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  url = __builtin__.property(_get_url, _set_url)


  _pyangbind_elements = OrderedDict([('url', url), ])


class yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_alarm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alarm/actions/alarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__url',)

  _yang_name = 'alarm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'alarm', u'actions', u'alarm']

  def _get_url(self):
    """
    Getter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/alarm/url (string)
    """
    return self.__url
      
  def _set_url(self, v, load=False):
    """
    Setter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/alarm/url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """url must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__url = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_url(self):
    self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  url = __builtin__.property(_get_url, _set_url)


  _pyangbind_elements = OrderedDict([('url', url), ])


class yc_actions_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alarm/actions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ok','__insufficient_data','__alarm',)

  _yang_name = 'actions'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__insufficient_data = YANGDynClass(base=YANGListType("url",yc_insufficient_data_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_insufficient_data, yang_name="insufficient-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="insufficient-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__alarm = YANGDynClass(base=YANGListType("url",yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__ok = YANGDynClass(base=YANGListType("url",yc_ok_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_ok, yang_name="ok", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'alarm', u'actions']

  def _get_ok(self):
    """
    Getter method for ok, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/ok (list)
    """
    return self.__ok
      
  def _set_ok(self, v, load=False):
    """
    Setter method for ok, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/ok (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ok is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ok() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("url",yc_ok_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_ok, yang_name="ok", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ok must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("url",yc_ok_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_ok, yang_name="ok", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__ok = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ok(self):
    self.__ok = YANGDynClass(base=YANGListType("url",yc_ok_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_ok, yang_name="ok", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_insufficient_data(self):
    """
    Getter method for insufficient_data, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/insufficient_data (list)
    """
    return self.__insufficient_data
      
  def _set_insufficient_data(self, v, load=False):
    """
    Setter method for insufficient_data, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/insufficient_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_insufficient_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_insufficient_data() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("url",yc_insufficient_data_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_insufficient_data, yang_name="insufficient-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="insufficient-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """insufficient_data must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("url",yc_insufficient_data_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_insufficient_data, yang_name="insufficient-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="insufficient-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__insufficient_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_insufficient_data(self):
    self.__insufficient_data = YANGDynClass(base=YANGListType("url",yc_insufficient_data_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_insufficient_data, yang_name="insufficient-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="insufficient-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_alarm(self):
    """
    Getter method for alarm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/alarm (list)
    """
    return self.__alarm
      
  def _set_alarm(self, v, load=False):
    """
    Setter method for alarm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/alarm (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("url",yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("url",yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__alarm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm(self):
    self.__alarm = YANGDynClass(base=YANGListType("url",yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  ok = __builtin__.property(_get_ok, _set_ok)
  insufficient_data = __builtin__.property(_get_insufficient_data, _set_insufficient_data)
  alarm = __builtin__.property(_get_alarm, _set_alarm)


  _pyangbind_elements = OrderedDict([('ok', ok), ('insufficient_data', insufficient_data), ('alarm', alarm), ])


class yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__alarm_id','__vnf_monitoring_param_ref','__name','__description','__vdur_id','__actions','__repeat','__enabled','__severity','__statistic','__operation','__value','__period','__evaluations',)

  _yang_name = 'alarm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__repeat = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__vdur_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdur-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'CRITICAL': {}, u'MODERATE': {}, u'LOW': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='alarm-severity-type', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__period = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    self.__actions = YANGDynClass(base=yc_actions_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions, is_container='container', yang_name="actions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__vnf_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__alarm_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="alarm-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)
    self.__statistic = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='alarm-statistic-type', is_config=True)
    self.__operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), is_leaf=True, yang_name="operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='relational-operation-type', is_config=True)
    self.__evaluations = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'alarm']

  def _get_alarm_id(self):
    """
    Getter method for alarm_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/alarm_id (string)

    YANG Description: This field is reserved for the identifier assigned by the VIM provider
    """
    return self.__alarm_id
      
  def _set_alarm_id(self, v, load=False):
    """
    Setter method for alarm_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/alarm_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_id() directly.

    YANG Description: This field is reserved for the identifier assigned by the VIM provider
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="alarm-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="alarm-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__alarm_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_id(self):
    self.__alarm_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="alarm-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_vnf_monitoring_param_ref(self):
    """
    Getter method for vnf_monitoring_param_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/vnf_monitoring_param_ref (leafref)

    YANG Description: Reference to the VNF level monitoring parameter
that is aggregated
    """
    return self.__vnf_monitoring_param_ref
      
  def _set_vnf_monitoring_param_ref(self, v, load=False):
    """
    Setter method for vnf_monitoring_param_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/vnf_monitoring_param_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_monitoring_param_ref() directly.

    YANG Description: Reference to the VNF level monitoring parameter
that is aggregated
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_monitoring_param_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vnf_monitoring_param_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_monitoring_param_ref(self):
    self.__vnf_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/name (string)

    YANG Description: A human readable string to identify the alarm
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: A human readable string to identify the alarm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/description (string)

    YANG Description: A description of this alarm
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A description of this alarm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_vdur_id(self):
    """
    Getter method for vdur_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/vdur_id (string)

    YANG Description: The identifier of the VDUR that the alarm is associated with
    """
    return self.__vdur_id
      
  def _set_vdur_id(self, v, load=False):
    """
    Setter method for vdur_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/vdur_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdur_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdur_id() directly.

    YANG Description: The identifier of the VDUR that the alarm is associated with
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vdur-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdur_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdur-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__vdur_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdur_id(self):
    self.__vdur_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdur-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_actions(self):
    """
    Getter method for actions, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions (container)
    """
    return self.__actions
      
  def _set_actions(self, v, load=False):
    """
    Setter method for actions, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_actions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_actions() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_actions_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions, is_container='container', yang_name="actions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """actions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_actions_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions, is_container='container', yang_name="actions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__actions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_actions(self):
    self.__actions = YANGDynClass(base=yc_actions_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions, is_container='container', yang_name="actions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_repeat(self):
    """
    Getter method for repeat, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/repeat (boolean)

    YANG Description: This flag indicates whether the alarm should be repeatedly emitted
while the associated threshold has been crossed.
    """
    return self.__repeat
      
  def _set_repeat(self, v, load=False):
    """
    Setter method for repeat, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/repeat (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repeat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repeat() directly.

    YANG Description: This flag indicates whether the alarm should be repeatedly emitted
while the associated threshold has been crossed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repeat must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__repeat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repeat(self):
    self.__repeat = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/enabled (boolean)

    YANG Description: This flag indicates whether the alarm has been enabled or
disabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This flag indicates whether the alarm has been enabled or
disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_severity(self):
    """
    Getter method for severity, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/severity (alarm-severity-type)

    YANG Description: A measure of the importance or urgency of the alarm
    """
    return self.__severity
      
  def _set_severity(self, v, load=False):
    """
    Setter method for severity, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/severity (alarm-severity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severity() directly.

    YANG Description: A measure of the importance or urgency of the alarm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'CRITICAL': {}, u'MODERATE': {}, u'LOW': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='alarm-severity-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severity must be of a type compatible with alarm-severity-type""",
          'defined-type': "vnfd:alarm-severity-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'CRITICAL': {}, u'MODERATE': {}, u'LOW': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='alarm-severity-type', is_config=True)""",
        })

    self.__severity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severity(self):
    self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'CRITICAL': {}, u'MODERATE': {}, u'LOW': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='alarm-severity-type', is_config=True)


  def _get_statistic(self):
    """
    Getter method for statistic, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/statistic (alarm-statistic-type)

    YANG Description: The type of metric statistic that is tracked by this alarm
    """
    return self.__statistic
      
  def _set_statistic(self, v, load=False):
    """
    Setter method for statistic, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/statistic (alarm-statistic-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic() directly.

    YANG Description: The type of metric statistic that is tracked by this alarm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='alarm-statistic-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistic must be of a type compatible with alarm-statistic-type""",
          'defined-type': "vnfd:alarm-statistic-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='alarm-statistic-type', is_config=True)""",
        })

    self.__statistic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistic(self):
    self.__statistic = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='alarm-statistic-type', is_config=True)


  def _get_operation(self):
    """
    Getter method for operation, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/operation (relational-operation-type)

    YANG Description: The relational operator used to define whether an alarm should be
triggered in certain scenarios, such as if the metric statistic
goes above or below a specified value.
    """
    return self.__operation
      
  def _set_operation(self, v, load=False):
    """
    Setter method for operation, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/operation (relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operation() directly.

    YANG Description: The relational operator used to define whether an alarm should be
triggered in certain scenarios, such as if the metric statistic
goes above or below a specified value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), is_leaf=True, yang_name="operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='relational-operation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operation must be of a type compatible with relational-operation-type""",
          'defined-type': "vnfd:relational-operation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), is_leaf=True, yang_name="operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='relational-operation-type', is_config=True)""",
        })

    self.__operation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operation(self):
    self.__operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), is_leaf=True, yang_name="operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='relational-operation-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/value (decimal64)

    YANG Description: This value defines the threshold that, if crossed, will trigger
the alarm.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/value (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: This value defines the threshold that, if crossed, will trigger
the alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)


  def _get_period(self):
    """
    Getter method for period, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/period (uint32)

    YANG Description: The period defines the length of time (seconds) that the metric
data are collected over in oreder to evaluate the chosen
statistic.
    """
    return self.__period
      
  def _set_period(self, v, load=False):
    """
    Setter method for period, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/period (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_period() directly.

    YANG Description: The period defines the length of time (seconds) that the metric
data are collected over in oreder to evaluate the chosen
statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """period must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""",
        })

    self.__period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_period(self):
    self.__period = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)


  def _get_evaluations(self):
    """
    Getter method for evaluations, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/evaluations (uint32)

    YANG Description: Defines the length of time (seconds) in which metric data are
collected in order to evaluate the chosen statistic.
    """
    return self.__evaluations
      
  def _set_evaluations(self, v, load=False):
    """
    Setter method for evaluations, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/evaluations (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evaluations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evaluations() directly.

    YANG Description: Defines the length of time (seconds) in which metric data are
collected in order to evaluate the chosen statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """evaluations must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""",
        })

    self.__evaluations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_evaluations(self):
    self.__evaluations = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)

  alarm_id = __builtin__.property(_get_alarm_id, _set_alarm_id)
  vnf_monitoring_param_ref = __builtin__.property(_get_vnf_monitoring_param_ref, _set_vnf_monitoring_param_ref)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  vdur_id = __builtin__.property(_get_vdur_id, _set_vdur_id)
  actions = __builtin__.property(_get_actions, _set_actions)
  repeat = __builtin__.property(_get_repeat, _set_repeat)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  severity = __builtin__.property(_get_severity, _set_severity)
  statistic = __builtin__.property(_get_statistic, _set_statistic)
  operation = __builtin__.property(_get_operation, _set_operation)
  value = __builtin__.property(_get_value, _set_value)
  period = __builtin__.property(_get_period, _set_period)
  evaluations = __builtin__.property(_get_evaluations, _set_evaluations)


  _pyangbind_elements = OrderedDict([('alarm_id', alarm_id), ('vnf_monitoring_param_ref', vnf_monitoring_param_ref), ('name', name), ('description', description), ('vdur_id', vdur_id), ('actions', actions), ('repeat', repeat), ('enabled', enabled), ('severity', severity), ('statistic', statistic), ('operation', operation), ('value', value), ('period', period), ('evaluations', evaluations), ])


class yc_alternative_images_vnfd__vnfd_catalog_vnfd_vdu_alternative_images(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alternative-images. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of alternative images per VIM type.
Different images can be used for specific types of VIMs instead
of the default image. This allows deployments in sites where the
image identifier in the VIM is given by the VIM provider and
cannot be modified.
If an alternative image is specified for a VIM type, it will prevail
over the default image
  """
  __slots__ = ('_path_helper', '_extmethods', '__vim_type','__image','__image_checksum',)

  _yang_name = 'alternative-images'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__vim_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__image_checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'alternative-images']

  def _get_vim_type(self):
    """
    Getter method for vim_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/vim_type (string)

    YANG Description: VIM type: openvim, openstack, vmware, aws, etc.
    """
    return self.__vim_type
      
  def _set_vim_type(self, v, load=False):
    """
    Setter method for vim_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/vim_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_type() directly.

    YANG Description: VIM type: openvim, openstack, vmware, aws, etc.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vim-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vim_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__vim_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vim_type(self):
    self.__vim_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_image(self):
    """
    Getter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/image (string)

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
    return self.__image
      
  def _set_image(self, v, load=False):
    """
    Setter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """image must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_image(self):
    self.__image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_image_checksum(self):
    """
    Getter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/image_checksum (string)

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
    return self.__image_checksum
      
  def _set_image_checksum(self, v, load=False):
    """
    Setter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/image_checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image_checksum() directly.

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """image_checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__image_checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_image_checksum(self):
    self.__image_checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  vim_type = __builtin__.property(_get_vim_type, _set_vim_type)
  image = __builtin__.property(_get_image, _set_image)
  image_checksum = __builtin__.property(_get_image_checksum, _set_image_checksum)


  _pyangbind_elements = OrderedDict([('vim_type', vim_type), ('image', image), ('image_checksum', image_checksum), ])


class yc_script_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_script(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__script_type',)

  _yang_name = 'script'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'script']

  def _get_script_type(self):
    """
    Getter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/script/script_type (enumeration)

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
    return self.__script_type
      
  def _set_script_type(self, v, load=False):
    """
    Setter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/script/script_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_type() directly.

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script_type must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__script_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script_type(self):
    self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  script_type = __builtin__.property(_get_script_type, _set_script_type)

  __choices__ = {u'config-method': {u'script': [u'script_type']}}
  _pyangbind_elements = OrderedDict([('script_type', script_type), ])


class yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__charm','__proxy','__cloud',)

  _yang_name = 'juju'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'juju']

  def _get_charm(self):
    """
    Getter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    return self.__charm
      
  def _set_charm(self, v, load=False):
    """
    Setter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """charm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__charm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_charm(self):
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_cloud(self):
    """
    Getter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    return self.__cloud
      
  def _set_cloud(self, v, load=False):
    """
    Setter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud(self):
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  charm = __builtin__.property(_get_charm, _set_charm)
  proxy = __builtin__.property(_get_proxy, _set_proxy)
  cloud = __builtin__.property(_get_cloud, _set_cloud)

  __choices__ = {u'config-method': {u'juju': [u'charm', u'proxy', u'cloud']}}
  _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_execution_environment_list_juju(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/execution-environment-list/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__charm','__proxy','__cloud',)

  _yang_name = 'juju'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'execution-environment-list', u'juju']

  def _get_charm(self):
    """
    Getter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    return self.__charm
      
  def _set_charm(self, v, load=False):
    """
    Setter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """charm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__charm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_charm(self):
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_cloud(self):
    """
    Getter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    return self.__cloud
      
  def _set_cloud(self, v, load=False):
    """
    Setter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud(self):
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  charm = __builtin__.property(_get_charm, _set_charm)
  proxy = __builtin__.property(_get_proxy, _set_proxy)
  cloud = __builtin__.property(_get_cloud, _set_cloud)

  __choices__ = {u'execution-environment-model': {u'juju': [u'charm', u'proxy', u'cloud']}}
  _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_execution_environment_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/execution-environment-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__juju','__helm_chart','__metric_service','__connection_point_ref',)

  _yang_name = 'execution-environment-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'execution-environment-list']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/id (string)

    YANG Description: Execution environment identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Execution environment identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_juju(self):
    """
    Getter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/juju (container)
    """
    return self.__juju
      
  def _set_juju(self, v, load=False):
    """
    Setter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__juju = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju(self):
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_helm_chart(self):
    """
    Getter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/helm_chart (string)

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
    return self.__helm_chart
      
  def _set_helm_chart(self, v, load=False):
    """
    Setter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/helm_chart (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_chart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_chart() directly.

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helm_chart must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__helm_chart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helm_chart(self):
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_metric_service(self):
    """
    Getter method for metric_service, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/metric_service (string)

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
    return self.__metric_service
      
  def _set_metric_service(self, v, load=False):
    """
    Setter method for metric_service, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/metric_service (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_service() directly.

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_service must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__metric_service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_service(self):
    self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_connection_point_ref(self):
    """
    Getter method for connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/connection_point_ref (string)

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
    return self.__connection_point_ref
      
  def _set_connection_point_ref(self, v, load=False):
    """
    Setter method for connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list/connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_point_ref() directly.

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_point_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_point_ref(self):
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  juju = __builtin__.property(_get_juju, _set_juju)
  helm_chart = __builtin__.property(_get_helm_chart, _set_helm_chart)
  metric_service = __builtin__.property(_get_metric_service, _set_metric_service)
  connection_point_ref = __builtin__.property(_get_connection_point_ref, _set_connection_point_ref)

  __choices__ = {u'config-method': {u'execution-environment-list': [u'id', u'metric_service', u'connection_point_ref']}, u'execution-environment-model': {u'juju': [u'juju'], u'helm-chart': [u'helm_chart']}}
  _pyangbind_elements = OrderedDict([('id', id), ('juju', juju), ('helm_chart', helm_chart), ('metric_service', metric_service), ('connection_point_ref', connection_point_ref), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the config primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__mandatory','__default_value','__parameter_pool','__read_only','__hidden',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_mandatory(self):
    """
    Getter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
    return self.__mandatory
      
  def _set_mandatory(self, v, load=False):
    """
    Setter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mandatory must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__mandatory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mandatory(self):
    self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_default_value(self):
    """
    Getter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/default_value (string)

    YANG Description: The default value for this field
    """
    return self.__default_value
      
  def _set_default_value(self, v, load=False):
    """
    Setter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__default_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_value(self):
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_parameter_pool(self):
    """
    Getter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
    return self.__parameter_pool
      
  def _set_parameter_pool(self, v, load=False):
    """
    Setter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter_pool must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__parameter_pool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter_pool(self):
    self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_read_only(self):
    """
    Getter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
    return self.__read_only
      
  def _set_read_only(self, v, load=False):
    """
    Setter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """read_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__read_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_read_only(self):
    self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_hidden(self):
    """
    Getter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
    return self.__hidden
      
  def _set_hidden(self, v, load=False):
    """
    Setter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hidden must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hidden(self):
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  mandatory = __builtin__.property(_get_mandatory, _set_mandatory)
  default_value = __builtin__.property(_get_default_value, _set_default_value)
  parameter_pool = __builtin__.property(_get_parameter_pool, _set_parameter_pool)
  read_only = __builtin__.property(_get_read_only, _set_read_only)
  hidden = __builtin__.property(_get_hidden, _set_hidden)


  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('mandatory', mandatory), ('default_value', default_value), ('parameter_pool', parameter_pool), ('read_only', read_only), ('hidden', hidden), ])


class yc_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__execution_environment_ref','__execution_environment_primitive','__parameter','__user_defined_script',)

  _yang_name = 'config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'config-primitive']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/name (string)

    YANG Description: Name of the config primitive.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the config primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_execution_environment_primitive(self):
    """
    Getter method for execution_environment_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/execution_environment_primitive (string)

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
    return self.__execution_environment_primitive
      
  def _set_execution_environment_primitive(self, v, load=False):
    """
    Setter method for execution_environment_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/execution_environment_primitive (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_primitive() directly.

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_primitive must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__execution_environment_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_primitive(self):
    self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter (list)

    YANG Description: List of parameters to the config primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the config primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/user_defined_script (string)

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  execution_environment_primitive = __builtin__.property(_get_execution_environment_primitive, _set_execution_environment_primitive)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)


  _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref), ('execution_environment_primitive', execution_environment_primitive), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/initial-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__value',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'initial-config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  value = __builtin__.property(_get_value, _set_value)

  __choices__ = {u'primitive-type': {u'primitive-definition': [u'name', u'data_type', u'value']}}
  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/initial-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Initial set of configuration primitives.
  """
  __slots__ = ('_path_helper', '_extmethods', '__seq','__name','__execution_environment_ref','__parameter','__user_defined_script',)

  _yang_name = 'initial-config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'initial-config-primitive']

  def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq
      
  def _set_seq(self, v, load=False):
    """
    Setter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__seq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq(self):
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/name (string)

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  seq = __builtin__.property(_get_seq, _set_seq)
  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

  __choices__ = {u'primitive-type': {u'primitive-definition': [u'name', u'execution_environment_ref', u'parameter', u'user_defined_script']}}
  _pyangbind_elements = OrderedDict([('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_terminate_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/terminate-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__value',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'terminate-config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_terminate_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/terminate-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Terminate set of configuration primitives.
  """
  __slots__ = ('_path_helper', '_extmethods', '__seq','__name','__execution_environment_ref','__parameter','__user_defined_script',)

  _yang_name = 'terminate-config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'terminate-config-primitive']

  def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq
      
  def _set_seq(self, v, load=False):
    """
    Setter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__seq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq(self):
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/name (string)

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  seq = __builtin__.property(_get_seq, _set_seq)
  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)


  _pyangbind_elements = OrderedDict([('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_metrics_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_metrics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VCA related metrics
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__execution_environment_ref','__execution_environment_metric',)

  _yang_name = 'metrics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__execution_environment_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'metrics']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics/name (string)

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment getting that metric
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment getting that metric
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_execution_environment_metric(self):
    """
    Getter method for execution_environment_metric, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics/execution_environment_metric (string)

    YANG Description: Metric in the execution environment referenced by execution-environment-ref
    """
    return self.__execution_environment_metric
      
  def _set_execution_environment_metric(self, v, load=False):
    """
    Setter method for execution_environment_metric, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics/execution_environment_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_metric() directly.

    YANG Description: Metric in the execution environment referenced by execution-environment-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_metric must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__execution_environment_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_metric(self):
    self.__execution_environment_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  execution_environment_metric = __builtin__.property(_get_execution_environment_metric, _set_execution_environment_metric)


  _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref), ('execution_environment_metric', execution_environment_metric), ])


class yc_ssh_access_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_access_ssh_access(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/config-access/ssh-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
  """
  __slots__ = ('_path_helper', '_extmethods', '__required','__default_user',)

  _yang_name = 'ssh-access'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__required = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__default_user = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'config-access', u'ssh-access']

  def _get_required(self):
    """
    Getter method for required, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_access/ssh_access/required (boolean)

    YANG Description: whether ssh access is needed or not
    """
    return self.__required
      
  def _set_required(self, v, load=False):
    """
    Setter method for required, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_access/ssh_access/required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required() directly.

    YANG Description: whether ssh access is needed or not
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required(self):
    self.__required = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_default_user(self):
    """
    Getter method for default_user, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_access/ssh_access/default_user (string)

    YANG Description: Default user for ssh
    """
    return self.__default_user
      
  def _set_default_user(self, v, load=False):
    """
    Setter method for default_user, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_access/ssh_access/default_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_user() directly.

    YANG Description: Default user for ssh
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_user must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__default_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_user(self):
    self.__default_user = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  required = __builtin__.property(_get_required, _set_required)
  default_user = __builtin__.property(_get_default_user, _set_default_user)


  _pyangbind_elements = OrderedDict([('required', required), ('default_user', default_user), ])


class yc_config_access_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_access(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/config-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
  """
  __slots__ = ('_path_helper', '_extmethods', '__ssh_access',)

  _yang_name = 'config-access'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ssh_access = YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration', u'config-access']

  def _get_ssh_access(self):
    """
    Getter method for ssh_access, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_access/ssh_access (container)

    YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
    """
    return self.__ssh_access
      
  def _set_ssh_access(self, v, load=False):
    """
    Setter method for ssh_access, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_access/ssh_access (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_access() directly.

    YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_access must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__ssh_access = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_access(self):
    self.__ssh_access = YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  ssh_access = __builtin__.property(_get_ssh_access, _set_ssh_access)


  _pyangbind_elements = OrderedDict([('ssh_access', ssh_access), ])


class yc_vdu_configuration_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__script','__juju','__execution_environment_list','__config_primitive','__initial_config_primitive','__terminate_config_primitive','__metrics','__config_access',)

  _yang_name = 'vdu-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config_primitive = YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__execution_environment_list = YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__config_access = YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'vdu-configuration']

  def _get_script(self):
    """
    Getter method for script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/script (container)
    """
    return self.__script
      
  def _set_script(self, v, load=False):
    """
    Setter method for script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/script (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_script_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script(self):
    self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_juju(self):
    """
    Getter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju (container)
    """
    return self.__juju
      
  def _set_juju(self, v, load=False):
    """
    Setter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__juju = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju(self):
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_execution_environment_list(self):
    """
    Getter method for execution_environment_list, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list (list)
    """
    return self.__execution_environment_list
      
  def _set_execution_environment_list(self, v, load=False):
    """
    Setter method for execution_environment_list, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/execution_environment_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__execution_environment_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_list(self):
    self.__execution_environment_list = YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_config_primitive(self):
    """
    Getter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive (list)

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
    return self.__config_primitive
      
  def _set_config_primitive(self, v, load=False):
    """
    Setter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_primitive() directly.

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_primitive(self):
    self.__config_primitive = YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_initial_config_primitive(self):
    """
    Getter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive (list)

    YANG Description: Initial set of configuration primitives.
    """
    return self.__initial_config_primitive
      
  def _set_initial_config_primitive(self, v, load=False):
    """
    Setter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_initial_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_initial_config_primitive() directly.

    YANG Description: Initial set of configuration primitives.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """initial_config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__initial_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_initial_config_primitive(self):
    self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_terminate_config_primitive(self):
    """
    Getter method for terminate_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive (list)

    YANG Description: Terminate set of configuration primitives.
    """
    return self.__terminate_config_primitive
      
  def _set_terminate_config_primitive(self, v, load=False):
    """
    Setter method for terminate_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/terminate_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_config_primitive() directly.

    YANG Description: Terminate set of configuration primitives.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminate_config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__terminate_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminate_config_primitive(self):
    self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_metrics(self):
    """
    Getter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics (list)

    YANG Description: List of VCA related metrics
    """
    return self.__metrics
      
  def _set_metrics(self, v, load=False):
    """
    Setter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: List of VCA related metrics
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metrics must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__metrics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metrics(self):
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_config_access(self):
    """
    Getter method for config_access, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_access (container)

    YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
    """
    return self.__config_access
      
  def _set_config_access(self, v, load=False):
    """
    Setter method for config_access, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_access (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_access() directly.

    YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_access_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_access must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__config_access = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_access(self):
    self.__config_access = YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  script = __builtin__.property(_get_script, _set_script)
  juju = __builtin__.property(_get_juju, _set_juju)
  execution_environment_list = __builtin__.property(_get_execution_environment_list, _set_execution_environment_list)
  config_primitive = __builtin__.property(_get_config_primitive, _set_config_primitive)
  initial_config_primitive = __builtin__.property(_get_initial_config_primitive, _set_initial_config_primitive)
  terminate_config_primitive = __builtin__.property(_get_terminate_config_primitive, _set_terminate_config_primitive)
  metrics = __builtin__.property(_get_metrics, _set_metrics)
  config_access = __builtin__.property(_get_config_access, _set_config_access)

  __choices__ = {u'config-method': {u'juju': [u'juju'], u'execution-environment-list': [u'execution_environment_list'], u'script': [u'script']}}
  _pyangbind_elements = OrderedDict([('script', script), ('juju', juju), ('execution_environment_list', execution_environment_list), ('config_primitive', config_primitive), ('initial_config_primitive', initial_config_primitive), ('terminate_config_primitive', terminate_config_primitive), ('metrics', metrics), ('config_access', config_access), ])


class yc_monitoring_param_vnfd__vnfd_catalog_vnfd_vdu_monitoring_param(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/monitoring-param. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VDU-related monitoring parameters at NFVI level
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__nfvi_metric','__interface_name_ref',)

  _yang_name = 'monitoring-param'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface_name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__nfvi_metric = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'disk_write_ops': {}, u'disk_write_bytes': {}, u'cpu_utilization': {}, u'packets_out_dropped': {}, u'packets_received': {}, u'disk_read_ops': {}, u'disk_read_bytes': {}, u'average_memory_utilization': {}, u'packets_sent': {}, u'packets_in_dropped': {}},), is_leaf=True, yang_name="nfvi-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:nfvi-metric-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'monitoring-param']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/id (string)

    YANG Description: The unique id of the monitoring param at VDU level
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique id of the monitoring param at VDU level
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_nfvi_metric(self):
    """
    Getter method for nfvi_metric, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/nfvi_metric (manotypes:nfvi-metric-type)

    YANG Description: The associated NFVI metric to be monitored
    """
    return self.__nfvi_metric
      
  def _set_nfvi_metric(self, v, load=False):
    """
    Setter method for nfvi_metric, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/nfvi_metric (manotypes:nfvi-metric-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nfvi_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nfvi_metric() directly.

    YANG Description: The associated NFVI metric to be monitored
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'disk_write_ops': {}, u'disk_write_bytes': {}, u'cpu_utilization': {}, u'packets_out_dropped': {}, u'packets_received': {}, u'disk_read_ops': {}, u'disk_read_bytes': {}, u'average_memory_utilization': {}, u'packets_sent': {}, u'packets_in_dropped': {}},), is_leaf=True, yang_name="nfvi-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:nfvi-metric-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nfvi_metric must be of a type compatible with manotypes:nfvi-metric-type""",
          'defined-type': "manotypes:nfvi-metric-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'disk_write_ops': {}, u'disk_write_bytes': {}, u'cpu_utilization': {}, u'packets_out_dropped': {}, u'packets_received': {}, u'disk_read_ops': {}, u'disk_read_bytes': {}, u'average_memory_utilization': {}, u'packets_sent': {}, u'packets_in_dropped': {}},), is_leaf=True, yang_name="nfvi-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:nfvi-metric-type', is_config=True)""",
        })

    self.__nfvi_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nfvi_metric(self):
    self.__nfvi_metric = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'disk_write_ops': {}, u'disk_write_bytes': {}, u'cpu_utilization': {}, u'packets_out_dropped': {}, u'packets_received': {}, u'disk_read_ops': {}, u'disk_read_bytes': {}, u'average_memory_utilization': {}, u'packets_sent': {}, u'packets_in_dropped': {}},), is_leaf=True, yang_name="nfvi-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:nfvi-metric-type', is_config=True)


  def _get_interface_name_ref(self):
    """
    Getter method for interface_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/interface_name_ref (leafref)

    YANG Description: Reference to a VDU interface name. Applicable only when the nfvi-metric
refers to an interface and not to the VM
    """
    return self.__interface_name_ref
      
  def _set_interface_name_ref(self, v, load=False):
    """
    Setter method for interface_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/interface_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_name_ref() directly.

    YANG Description: Reference to a VDU interface name. Applicable only when the nfvi-metric
refers to an interface and not to the VM
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_name_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__interface_name_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_name_ref(self):
    self.__interface_name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  nfvi_metric = __builtin__.property(_get_nfvi_metric, _set_nfvi_metric)
  interface_name_ref = __builtin__.property(_get_interface_name_ref, _set_interface_name_ref)


  _pyangbind_elements = OrderedDict([('id', id), ('nfvi_metric', nfvi_metric), ('interface_name_ref', interface_name_ref), ])


class yc_supplemental_boot_data_vnfd__vnfd_catalog_vnfd_vdu_supplemental_boot_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/supplemental-boot-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__boot_data_drive',)

  _yang_name = 'supplemental-boot-data'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__boot_data_drive = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="boot-data-drive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'supplemental-boot-data']

  def _get_boot_data_drive(self):
    """
    Getter method for boot_data_drive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/supplemental_boot_data/boot_data_drive (boolean)

    YANG Description: Some VIMs implement additional drives to host config-files or meta-data
    """
    return self.__boot_data_drive
      
  def _set_boot_data_drive(self, v, load=False):
    """
    Setter method for boot_data_drive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/supplemental_boot_data/boot_data_drive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_boot_data_drive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_boot_data_drive() directly.

    YANG Description: Some VIMs implement additional drives to host config-files or meta-data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="boot-data-drive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """boot_data_drive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="boot-data-drive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__boot_data_drive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_boot_data_drive(self):
    self.__boot_data_drive = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="boot-data-drive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

  boot_data_drive = __builtin__.property(_get_boot_data_drive, _set_boot_data_drive)


  _pyangbind_elements = OrderedDict([('boot_data_drive', boot_data_drive), ])


class yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_vdu_internal_connection_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/internal-connection-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for internal connection points. Each VNFC
has zero or more internal connection points.
Internal connection points are used for connecting
the VNF with components internal to the VNF. If a VNF
has only one VNFC, it may not have any internal
connection points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__id','__short_name','__type','__port_security_enabled','__internal_vld_ref',)

  _yang_name = 'internal-connection-point'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__internal_vld_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="internal-vld-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__port_security_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:connection-point-type', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'internal-connection-point']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/name (string)

    YANG Description: Name of the connection point
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the connection point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/id (string)

    YANG Description: Identifier for the internal connection points
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the internal connection points
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/type (manotypes:connection-point-type)

    YANG Description: Type of the connection point.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/type (manotypes:connection-point-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the connection point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:connection-point-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with manotypes:connection-point-type""",
          'defined-type': "manotypes:connection-point-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:connection-point-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:connection-point-type', is_config=True)


  def _get_port_security_enabled(self):
    """
    Getter method for port_security_enabled, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/port_security_enabled (boolean)

    YANG Description: Enables the port security for the port.
    """
    return self.__port_security_enabled
      
  def _set_port_security_enabled(self, v, load=False):
    """
    Setter method for port_security_enabled, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/port_security_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_enabled() directly.

    YANG Description: Enables the port security for the port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_security_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__port_security_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_security_enabled(self):
    self.__port_security_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_internal_vld_ref(self):
    """
    Getter method for internal_vld_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/internal_vld_ref (leafref)
    """
    return self.__internal_vld_ref
      
  def _set_internal_vld_ref(self, v, load=False):
    """
    Setter method for internal_vld_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/internal_vld_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_vld_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_vld_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="internal-vld-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """internal_vld_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="internal-vld-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__internal_vld_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_internal_vld_ref(self):
    self.__internal_vld_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="internal-vld-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  id = __builtin__.property(_get_id, _set_id)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  type = __builtin__.property(_get_type, _set_type)
  port_security_enabled = __builtin__.property(_get_port_security_enabled, _set_port_security_enabled)
  internal_vld_ref = __builtin__.property(_get_internal_vld_ref, _set_internal_vld_ref)


  _pyangbind_elements = OrderedDict([('name', name), ('id', id), ('short_name', short_name), ('type', type), ('port_security_enabled', port_security_enabled), ('internal_vld_ref', internal_vld_ref), ])


class yc_virtual_interface_vnfd__vnfd_catalog_vnfd_vdu_interface_virtual_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/interface/virtual-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the virtual interface properties
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__vpci','__bandwidth',)

  _yang_name = 'virtual-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vpci = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'OM-MGMT': {}, u'VIRTIO': {}, u'SR-IOV': {}, u'PCI-PASSTHROUGH': {}, u'RTL8139': {}, u'PCNET': {}, u'PARAVIRT': {}, u'E1000': {}},), default=six.text_type("PARAVIRT"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'interface', u'virtual-interface']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/type (enumeration)

    YANG Description: Specifies the type of virtual interface
between VM and host.
PARAVIRT        : Use the default paravirtualized interface for the VIM (virtio, vmxnet3, etc.).
VIRTIO          : Deprecated! Use the traditional VIRTIO interface.
PCI-PASSTHROUGH : Use PCI-PASSTHROUGH interface.
SR-IOV          : Use SR-IOV interface.
E1000           : Emulate E1000 interface.
RTL8139         : Emulate RTL8139 interface.
PCNET           : Emulate PCNET interface.
OM-MGMT         : Deprecated! Use PARAVIRT instead and set the VNF management interface at vnfd:mgmt-interface:cp
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the type of virtual interface
between VM and host.
PARAVIRT        : Use the default paravirtualized interface for the VIM (virtio, vmxnet3, etc.).
VIRTIO          : Deprecated! Use the traditional VIRTIO interface.
PCI-PASSTHROUGH : Use PCI-PASSTHROUGH interface.
SR-IOV          : Use SR-IOV interface.
E1000           : Emulate E1000 interface.
RTL8139         : Emulate RTL8139 interface.
PCNET           : Emulate PCNET interface.
OM-MGMT         : Deprecated! Use PARAVIRT instead and set the VNF management interface at vnfd:mgmt-interface:cp
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'OM-MGMT': {}, u'VIRTIO': {}, u'SR-IOV': {}, u'PCI-PASSTHROUGH': {}, u'RTL8139': {}, u'PCNET': {}, u'PARAVIRT': {}, u'E1000': {}},), default=six.text_type("PARAVIRT"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'OM-MGMT': {}, u'VIRTIO': {}, u'SR-IOV': {}, u'PCI-PASSTHROUGH': {}, u'RTL8139': {}, u'PCNET': {}, u'PARAVIRT': {}, u'E1000': {}},), default=six.text_type("PARAVIRT"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'OM-MGMT': {}, u'VIRTIO': {}, u'SR-IOV': {}, u'PCI-PASSTHROUGH': {}, u'RTL8139': {}, u'PCNET': {}, u'PARAVIRT': {}, u'E1000': {}},), default=six.text_type("PARAVIRT"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_vpci(self):
    """
    Getter method for vpci, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/vpci (string)

    YANG Description: Specifies the virtual PCI address. Expressed in
the following format dddd:dd:dd.d. For example
0000:00:12.0. This information can be used to
pass as metadata during the VM creation.
    """
    return self.__vpci
      
  def _set_vpci(self, v, load=False):
    """
    Setter method for vpci, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/vpci (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpci is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpci() directly.

    YANG Description: Specifies the virtual PCI address. Expressed in
the following format dddd:dd:dd.d. For example
0000:00:12.0. This information can be used to
pass as metadata during the VM creation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpci must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__vpci = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpci(self):
    self.__vpci = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/bandwidth (uint64)

    YANG Description: Aggregate bandwidth of the NIC.
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Aggregate bandwidth of the NIC.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  vpci = __builtin__.property(_get_vpci, _set_vpci)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)


  _pyangbind_elements = OrderedDict([('type', type), ('vpci', vpci), ('bandwidth', bandwidth), ])


class yc_interface_vnfd__vnfd_catalog_vnfd_vdu_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Interfaces (external and internal) for the VNF
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__position','__mgmt_interface','__type','__mac_address','__internal_connection_point_ref','__external_connection_point_ref','__virtual_interface',)

  _yang_name = 'interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, choice=(u'connection-point-type', u'external'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__internal_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="internal-connection-point-ref", parent=self, choice=(u'connection-point-type', u'internal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__mac_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__position = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    self.__virtual_interface = YANGDynClass(base=yc_virtual_interface_vnfd__vnfd_catalog_vnfd_vdu_interface_virtual_interface, is_container='container', yang_name="virtual-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTERNAL': {}, u'EXTERNAL': {}},), default=six.text_type("EXTERNAL"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='interface-type', is_config=True)
    self.__mgmt_interface = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/name (string)

    YANG Description: Name of the interface. Note that this
name has only local significance to the VDU.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the interface. Note that this
name has only local significance to the VDU.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_position(self):
    """
    Getter method for position, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/position (uint32)

    YANG Description: Explicit Position of the interface within the list
    """
    return self.__position
      
  def _set_position(self, v, load=False):
    """
    Setter method for position, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/position (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_position is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_position() directly.

    YANG Description: Explicit Position of the interface within the list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """position must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""",
        })

    self.__position = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_position(self):
    self.__position = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)


  def _get_mgmt_interface(self):
    """
    Getter method for mgmt_interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/mgmt_interface (boolean)

    YANG Description: Flag to indicate that this is the mgmt interface
to be used for VDU configuration
    """
    return self.__mgmt_interface
      
  def _set_mgmt_interface(self, v, load=False):
    """
    Setter method for mgmt_interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/mgmt_interface (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_interface() directly.

    YANG Description: Flag to indicate that this is the mgmt interface
to be used for VDU configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_interface must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__mgmt_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_interface(self):
    self.__mgmt_interface = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/type (interface-type)

    YANG Description: Type of the Interface
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/type (interface-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the Interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTERNAL': {}, u'EXTERNAL': {}},), default=six.text_type("EXTERNAL"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='interface-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with interface-type""",
          'defined-type': "vnfd:interface-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTERNAL': {}, u'EXTERNAL': {}},), default=six.text_type("EXTERNAL"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='interface-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTERNAL': {}, u'EXTERNAL': {}},), default=six.text_type("EXTERNAL"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='interface-type', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/mac_address (string)

    YANG Description: MAC address of the interface.
Some VNFs require a specific MAC address to be configured
in the interface. While this is not recommended at all in
NFV environments, this parameter exists to allow those
scenarios.
This parameter will be likely deprecated in the future.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/mac_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: MAC address of the interface.
Some VNFs require a specific MAC address to be configured
in the interface. While this is not recommended at all in
NFV environments, this parameter exists to allow those
scenarios.
This parameter will be likely deprecated in the future.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_internal_connection_point_ref(self):
    """
    Getter method for internal_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/internal_connection_point_ref (leafref)

    YANG Description: Leaf Ref to the particular internal connection point
    """
    return self.__internal_connection_point_ref
      
  def _set_internal_connection_point_ref(self, v, load=False):
    """
    Setter method for internal_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/internal_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_connection_point_ref() directly.

    YANG Description: Leaf Ref to the particular internal connection point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="internal-connection-point-ref", parent=self, choice=(u'connection-point-type', u'internal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """internal_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="internal-connection-point-ref", parent=self, choice=(u'connection-point-type', u'internal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__internal_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_internal_connection_point_ref(self):
    self.__internal_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="internal-connection-point-ref", parent=self, choice=(u'connection-point-type', u'internal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_external_connection_point_ref(self):
    """
    Getter method for external_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/external_connection_point_ref (leafref)

    YANG Description: Leaf Ref to the particular external connection point
    """
    return self.__external_connection_point_ref
      
  def _set_external_connection_point_ref(self, v, load=False):
    """
    Setter method for external_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/external_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_connection_point_ref() directly.

    YANG Description: Leaf Ref to the particular external connection point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, choice=(u'connection-point-type', u'external'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, choice=(u'connection-point-type', u'external'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__external_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external_connection_point_ref(self):
    self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, choice=(u'connection-point-type', u'external'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_virtual_interface(self):
    """
    Getter method for virtual_interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface (container)

    YANG Description: Container for the virtual interface properties
    """
    return self.__virtual_interface
      
  def _set_virtual_interface(self, v, load=False):
    """
    Setter method for virtual_interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_interface() directly.

    YANG Description: Container for the virtual interface properties
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_virtual_interface_vnfd__vnfd_catalog_vnfd_vdu_interface_virtual_interface, is_container='container', yang_name="virtual-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_virtual_interface_vnfd__vnfd_catalog_vnfd_vdu_interface_virtual_interface, is_container='container', yang_name="virtual-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__virtual_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_interface(self):
    self.__virtual_interface = YANGDynClass(base=yc_virtual_interface_vnfd__vnfd_catalog_vnfd_vdu_interface_virtual_interface, is_container='container', yang_name="virtual-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  position = __builtin__.property(_get_position, _set_position)
  mgmt_interface = __builtin__.property(_get_mgmt_interface, _set_mgmt_interface)
  type = __builtin__.property(_get_type, _set_type)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  internal_connection_point_ref = __builtin__.property(_get_internal_connection_point_ref, _set_internal_connection_point_ref)
  external_connection_point_ref = __builtin__.property(_get_external_connection_point_ref, _set_external_connection_point_ref)
  virtual_interface = __builtin__.property(_get_virtual_interface, _set_virtual_interface)

  __choices__ = {u'connection-point-type': {u'internal': [u'internal_connection_point_ref'], u'external': [u'external_connection_point_ref']}}
  _pyangbind_elements = OrderedDict([('name', name), ('position', position), ('mgmt_interface', mgmt_interface), ('type', type), ('mac_address', mac_address), ('internal_connection_point_ref', internal_connection_point_ref), ('external_connection_point_ref', external_connection_point_ref), ('virtual_interface', virtual_interface), ])


class yc_volumes_vnfd__vnfd_catalog_vnfd_vdu_volumes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/volumes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__size','__ephemeral','__image','__image_checksum','__device_bus','__device_type',)

  _yang_name = 'volumes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, choice=(u'volume-source', u'image'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__ephemeral = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ephemeral", parent=self, choice=(u'volume-source', u'ephemeral'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='empty', is_config=True)
    self.__device_bus = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'scsi': {}, u'virtio': {}, u'ide': {}, u'usb': {}},), is_leaf=True, yang_name="device-bus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'cdrom': {}, u'floppy': {}, u'disk': {}, u'lun': {}},), is_leaf=True, yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__image_checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, choice=(u'volume-source', u'image'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu', u'volumes']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/name (string)

    YANG Description: Name of the disk-volumes, e.g. vda, vdb etc
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the disk-volumes, e.g. vda, vdb etc
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/description (string)

    YANG Description: Description for Volume
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description for Volume
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_size(self):
    """
    Getter method for size, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/size (uint64)

    YANG Description: Size of disk in GB
    """
    return self.__size
      
  def _set_size(self, v, load=False):
    """
    Setter method for size, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/size (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: Size of disk in GB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size(self):
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_ephemeral(self):
    """
    Getter method for ephemeral, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/ephemeral (empty)
    """
    return self.__ephemeral
      
  def _set_ephemeral(self, v, load=False):
    """
    Setter method for ephemeral, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/ephemeral (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ephemeral is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ephemeral() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ephemeral", parent=self, choice=(u'volume-source', u'ephemeral'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ephemeral must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ephemeral", parent=self, choice=(u'volume-source', u'ephemeral'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='empty', is_config=True)""",
        })

    self.__ephemeral = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ephemeral(self):
    self.__ephemeral = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ephemeral", parent=self, choice=(u'volume-source', u'ephemeral'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='empty', is_config=True)


  def _get_image(self):
    """
    Getter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/image (string)

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
    return self.__image
      
  def _set_image(self, v, load=False):
    """
    Setter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="image", parent=self, choice=(u'volume-source', u'image'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """image must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, choice=(u'volume-source', u'image'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_image(self):
    self.__image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, choice=(u'volume-source', u'image'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_image_checksum(self):
    """
    Getter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/image_checksum (string)

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
    return self.__image_checksum
      
  def _set_image_checksum(self, v, load=False):
    """
    Setter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/image_checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image_checksum() directly.

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, choice=(u'volume-source', u'image'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """image_checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, choice=(u'volume-source', u'image'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__image_checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_image_checksum(self):
    self.__image_checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, choice=(u'volume-source', u'image'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_device_bus(self):
    """
    Getter method for device_bus, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/device_bus (enumeration)

    YANG Description: Type of disk-bus on which this disk is exposed to guest
    """
    return self.__device_bus
      
  def _set_device_bus(self, v, load=False):
    """
    Setter method for device_bus, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/device_bus (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_bus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_bus() directly.

    YANG Description: Type of disk-bus on which this disk is exposed to guest
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'scsi': {}, u'virtio': {}, u'ide': {}, u'usb': {}},), is_leaf=True, yang_name="device-bus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_bus must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'scsi': {}, u'virtio': {}, u'ide': {}, u'usb': {}},), is_leaf=True, yang_name="device-bus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__device_bus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_bus(self):
    self.__device_bus = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'scsi': {}, u'virtio': {}, u'ide': {}, u'usb': {}},), is_leaf=True, yang_name="device-bus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_device_type(self):
    """
    Getter method for device_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/device_type (enumeration)

    YANG Description: The type of device as exposed to guest
    """
    return self.__device_type
      
  def _set_device_type(self, v, load=False):
    """
    Setter method for device_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/device_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.

    YANG Description: The type of device as exposed to guest
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'cdrom': {}, u'floppy': {}, u'disk': {}, u'lun': {}},), is_leaf=True, yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_type must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'cdrom': {}, u'floppy': {}, u'disk': {}, u'lun': {}},), is_leaf=True, yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__device_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_type(self):
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'cdrom': {}, u'floppy': {}, u'disk': {}, u'lun': {}},), is_leaf=True, yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  size = __builtin__.property(_get_size, _set_size)
  ephemeral = __builtin__.property(_get_ephemeral, _set_ephemeral)
  image = __builtin__.property(_get_image, _set_image)
  image_checksum = __builtin__.property(_get_image_checksum, _set_image_checksum)
  device_bus = __builtin__.property(_get_device_bus, _set_device_bus)
  device_type = __builtin__.property(_get_device_type, _set_device_type)

  __choices__ = {u'volume-source': {u'image': [u'image', u'image_checksum'], u'ephemeral': [u'ephemeral']}}
  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('size', size), ('ephemeral', ephemeral), ('image', image), ('image_checksum', image_checksum), ('device_bus', device_bus), ('device_type', device_type), ])


class yc_vdu_vnfd__vnfd_catalog_vnfd_vdu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Virtual Deployment Units
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__description','__pdu_type','__count','__mgmt_vpci','__vm_flavor','__guest_epa','__vswitch_epa','__hypervisor_epa','__host_epa','__alarm','__image','__image_checksum','__alternative_images','__vdu_configuration','__monitoring_param','__cloud_init','__cloud_init_file','__supplemental_boot_data','__internal_connection_point','__interface','__volumes',)

  _yang_name = 'vdu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__internal_connection_point = YANGDynClass(base=YANGListType("id",yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_vdu_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__alternative_images = YANGDynClass(base=YANGListType("vim_type",yc_alternative_images_vnfd__vnfd_catalog_vnfd_vdu_alternative_images, yang_name="alternative-images", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vim-type', extensions=None), is_container='list', yang_name="alternative-images", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__hypervisor_epa = YANGDynClass(base=yc_hypervisor_epa_vnfd__vnfd_catalog_vnfd_vdu_hypervisor_epa, is_container='container', yang_name="hypervisor-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__image_checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__vswitch_epa = YANGDynClass(base=yc_vswitch_epa_vnfd__vnfd_catalog_vnfd_vdu_vswitch_epa, is_container='container', yang_name="vswitch-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__mgmt_vpci = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mgmt-vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__cloud_init_file = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init-file", parent=self, choice=(u'cloud-init-input', u'filename'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__vm_flavor = YANGDynClass(base=yc_vm_flavor_vnfd__vnfd_catalog_vnfd_vdu_vm_flavor, is_container='container', yang_name="vm-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__supplemental_boot_data = YANGDynClass(base=yc_supplemental_boot_data_vnfd__vnfd_catalog_vnfd_vdu_supplemental_boot_data, is_container='container', yang_name="supplemental-boot-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__guest_epa = YANGDynClass(base=yc_guest_epa_vnfd__vnfd_catalog_vnfd_vdu_guest_epa, is_container='container', yang_name="guest-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__pdu_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pdu-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__monitoring_param = YANGDynClass(base=YANGListType("id",yc_monitoring_param_vnfd__vnfd_catalog_vnfd_vdu_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_vnfd__vnfd_catalog_vnfd_vdu_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__host_epa = YANGDynClass(base=yc_host_epa_vnfd__vnfd_catalog_vnfd_vdu_host_epa, is_container='container', yang_name="host-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__vdu_configuration = YANGDynClass(base=yc_vdu_configuration_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration, is_container='container', yang_name="vdu-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__cloud_init = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init", parent=self, choice=(u'cloud-init-input', u'inline'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__volumes = YANGDynClass(base=YANGListType("name",yc_volumes_vnfd__vnfd_catalog_vnfd_vdu_volumes, yang_name="volumes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__alarm = YANGDynClass(base=YANGListType("alarm_id",yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='alarm-id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/id (string)

    YANG Description: Unique id for the VDU
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique id for the VDU
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/name (string)

    YANG Description: Unique name for the VDU
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Unique name for the VDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/description (string)

    YANG Description: Description of the VDU.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_pdu_type(self):
    """
    Getter method for pdu_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/pdu_type (string)

    YANG Description: Type of PDU. If this field exists, the deployment unit must be
understood as a PDU, not as a VDU. This field is used to identify
the category of PDU instances to be used at instantiation time. For
the instantiation to be successful, there must be available
PDU instances of this type in the selected datacenter.
    """
    return self.__pdu_type
      
  def _set_pdu_type(self, v, load=False):
    """
    Setter method for pdu_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/pdu_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pdu_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pdu_type() directly.

    YANG Description: Type of PDU. If this field exists, the deployment unit must be
understood as a PDU, not as a VDU. This field is used to identify
the category of PDU instances to be used at instantiation time. For
the instantiation to be successful, there must be available
PDU instances of this type in the selected datacenter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pdu-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pdu_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pdu-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__pdu_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pdu_type(self):
    self.__pdu_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pdu-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/count (uint64)

    YANG Description: Number of instances of VDU
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Number of instances of VDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_mgmt_vpci(self):
    """
    Getter method for mgmt_vpci, mapped from YANG variable /vnfd_catalog/vnfd/vdu/mgmt_vpci (string)

    YANG Description: Specifies the virtual PCI address. Expressed in
the following format dddd:dd:dd.d. For example
0000:00:12.0. This information can be used to
pass as metadata during the VM creation.
    """
    return self.__mgmt_vpci
      
  def _set_mgmt_vpci(self, v, load=False):
    """
    Setter method for mgmt_vpci, mapped from YANG variable /vnfd_catalog/vnfd/vdu/mgmt_vpci (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_vpci is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_vpci() directly.

    YANG Description: Specifies the virtual PCI address. Expressed in
the following format dddd:dd:dd.d. For example
0000:00:12.0. This information can be used to
pass as metadata during the VM creation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mgmt-vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_vpci must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mgmt-vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__mgmt_vpci = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_vpci(self):
    self.__mgmt_vpci = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mgmt-vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_vm_flavor(self):
    """
    Getter method for vm_flavor, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor (container)
    """
    return self.__vm_flavor
      
  def _set_vm_flavor(self, v, load=False):
    """
    Setter method for vm_flavor, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vm_flavor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vm_flavor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vm_flavor_vnfd__vnfd_catalog_vnfd_vdu_vm_flavor, is_container='container', yang_name="vm-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vm_flavor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vm_flavor_vnfd__vnfd_catalog_vnfd_vdu_vm_flavor, is_container='container', yang_name="vm-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__vm_flavor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vm_flavor(self):
    self.__vm_flavor = YANGDynClass(base=yc_vm_flavor_vnfd__vnfd_catalog_vnfd_vdu_vm_flavor, is_container='container', yang_name="vm-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_guest_epa(self):
    """
    Getter method for guest_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa (container)
    """
    return self.__guest_epa
      
  def _set_guest_epa(self, v, load=False):
    """
    Setter method for guest_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_guest_epa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_guest_epa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_guest_epa_vnfd__vnfd_catalog_vnfd_vdu_guest_epa, is_container='container', yang_name="guest-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """guest_epa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_guest_epa_vnfd__vnfd_catalog_vnfd_vdu_guest_epa, is_container='container', yang_name="guest-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__guest_epa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_guest_epa(self):
    self.__guest_epa = YANGDynClass(base=yc_guest_epa_vnfd__vnfd_catalog_vnfd_vdu_guest_epa, is_container='container', yang_name="guest-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_vswitch_epa(self):
    """
    Getter method for vswitch_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa (container)
    """
    return self.__vswitch_epa
      
  def _set_vswitch_epa(self, v, load=False):
    """
    Setter method for vswitch_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vswitch_epa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vswitch_epa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vswitch_epa_vnfd__vnfd_catalog_vnfd_vdu_vswitch_epa, is_container='container', yang_name="vswitch-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vswitch_epa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vswitch_epa_vnfd__vnfd_catalog_vnfd_vdu_vswitch_epa, is_container='container', yang_name="vswitch-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__vswitch_epa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vswitch_epa(self):
    self.__vswitch_epa = YANGDynClass(base=yc_vswitch_epa_vnfd__vnfd_catalog_vnfd_vdu_vswitch_epa, is_container='container', yang_name="vswitch-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_hypervisor_epa(self):
    """
    Getter method for hypervisor_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa (container)
    """
    return self.__hypervisor_epa
      
  def _set_hypervisor_epa(self, v, load=False):
    """
    Setter method for hypervisor_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hypervisor_epa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hypervisor_epa() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_hypervisor_epa_vnfd__vnfd_catalog_vnfd_vdu_hypervisor_epa, is_container='container', yang_name="hypervisor-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hypervisor_epa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_hypervisor_epa_vnfd__vnfd_catalog_vnfd_vdu_hypervisor_epa, is_container='container', yang_name="hypervisor-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__hypervisor_epa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hypervisor_epa(self):
    self.__hypervisor_epa = YANGDynClass(base=yc_hypervisor_epa_vnfd__vnfd_catalog_vnfd_vdu_hypervisor_epa, is_container='container', yang_name="hypervisor-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_host_epa(self):
    """
    Getter method for host_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa (container)

    YANG Description: Specifies the host level EPA attributes.
    """
    return self.__host_epa
      
  def _set_host_epa(self, v, load=False):
    """
    Setter method for host_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_epa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_epa() directly.

    YANG Description: Specifies the host level EPA attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_host_epa_vnfd__vnfd_catalog_vnfd_vdu_host_epa, is_container='container', yang_name="host-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_epa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_host_epa_vnfd__vnfd_catalog_vnfd_vdu_host_epa, is_container='container', yang_name="host-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__host_epa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_epa(self):
    self.__host_epa = YANGDynClass(base=yc_host_epa_vnfd__vnfd_catalog_vnfd_vdu_host_epa, is_container='container', yang_name="host-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_alarm(self):
    """
    Getter method for alarm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm (list)
    """
    return self.__alarm
      
  def _set_alarm(self, v, load=False):
    """
    Setter method for alarm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("alarm_id",yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='alarm-id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("alarm_id",yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='alarm-id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__alarm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm(self):
    self.__alarm = YANGDynClass(base=YANGListType("alarm_id",yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='alarm-id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_image(self):
    """
    Getter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/image (string)

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
    return self.__image
      
  def _set_image(self, v, load=False):
    """
    Setter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """image must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_image(self):
    self.__image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_image_checksum(self):
    """
    Getter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/image_checksum (string)

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
    return self.__image_checksum
      
  def _set_image_checksum(self, v, load=False):
    """
    Setter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/image_checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image_checksum() directly.

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """image_checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__image_checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_image_checksum(self):
    self.__image_checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image-checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_alternative_images(self):
    """
    Getter method for alternative_images, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images (list)

    YANG Description: List of alternative images per VIM type.
Different images can be used for specific types of VIMs instead
of the default image. This allows deployments in sites where the
image identifier in the VIM is given by the VIM provider and
cannot be modified.
If an alternative image is specified for a VIM type, it will prevail
over the default image
    """
    return self.__alternative_images
      
  def _set_alternative_images(self, v, load=False):
    """
    Setter method for alternative_images, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alternative_images is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alternative_images() directly.

    YANG Description: List of alternative images per VIM type.
Different images can be used for specific types of VIMs instead
of the default image. This allows deployments in sites where the
image identifier in the VIM is given by the VIM provider and
cannot be modified.
If an alternative image is specified for a VIM type, it will prevail
over the default image
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vim_type",yc_alternative_images_vnfd__vnfd_catalog_vnfd_vdu_alternative_images, yang_name="alternative-images", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vim-type', extensions=None), is_container='list', yang_name="alternative-images", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alternative_images must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vim_type",yc_alternative_images_vnfd__vnfd_catalog_vnfd_vdu_alternative_images, yang_name="alternative-images", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vim-type', extensions=None), is_container='list', yang_name="alternative-images", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__alternative_images = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alternative_images(self):
    self.__alternative_images = YANGDynClass(base=YANGListType("vim_type",yc_alternative_images_vnfd__vnfd_catalog_vnfd_vdu_alternative_images, yang_name="alternative-images", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vim-type', extensions=None), is_container='list', yang_name="alternative-images", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_vdu_configuration(self):
    """
    Getter method for vdu_configuration, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration (container)
    """
    return self.__vdu_configuration
      
  def _set_vdu_configuration(self, v, load=False):
    """
    Setter method for vdu_configuration, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_configuration() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vdu_configuration_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration, is_container='container', yang_name="vdu-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vdu_configuration_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration, is_container='container', yang_name="vdu-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__vdu_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_configuration(self):
    self.__vdu_configuration = YANGDynClass(base=yc_vdu_configuration_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration, is_container='container', yang_name="vdu-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_monitoring_param(self):
    """
    Getter method for monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param (list)

    YANG Description: List of VDU-related monitoring parameters at NFVI level
    """
    return self.__monitoring_param
      
  def _set_monitoring_param(self, v, load=False):
    """
    Setter method for monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_param is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_param() directly.

    YANG Description: List of VDU-related monitoring parameters at NFVI level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_monitoring_param_vnfd__vnfd_catalog_vnfd_vdu_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitoring_param must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_param_vnfd__vnfd_catalog_vnfd_vdu_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__monitoring_param = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitoring_param(self):
    self.__monitoring_param = YANGDynClass(base=YANGListType("id",yc_monitoring_param_vnfd__vnfd_catalog_vnfd_vdu_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_cloud_init(self):
    """
    Getter method for cloud_init, mapped from YANG variable /vnfd_catalog/vnfd/vdu/cloud_init (string)

    YANG Description: Contents of cloud-init script, provided inline, in cloud-config format
    """
    return self.__cloud_init
      
  def _set_cloud_init(self, v, load=False):
    """
    Setter method for cloud_init, mapped from YANG variable /vnfd_catalog/vnfd/vdu/cloud_init (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud_init is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud_init() directly.

    YANG Description: Contents of cloud-init script, provided inline, in cloud-config format
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cloud-init", parent=self, choice=(u'cloud-init-input', u'inline'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud_init must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init", parent=self, choice=(u'cloud-init-input', u'inline'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__cloud_init = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud_init(self):
    self.__cloud_init = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init", parent=self, choice=(u'cloud-init-input', u'inline'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_cloud_init_file(self):
    """
    Getter method for cloud_init_file, mapped from YANG variable /vnfd_catalog/vnfd/vdu/cloud_init_file (string)

    YANG Description: Name of file with contents of cloud-init script in cloud-config format
    """
    return self.__cloud_init_file
      
  def _set_cloud_init_file(self, v, load=False):
    """
    Setter method for cloud_init_file, mapped from YANG variable /vnfd_catalog/vnfd/vdu/cloud_init_file (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud_init_file is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud_init_file() directly.

    YANG Description: Name of file with contents of cloud-init script in cloud-config format
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cloud-init-file", parent=self, choice=(u'cloud-init-input', u'filename'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud_init_file must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init-file", parent=self, choice=(u'cloud-init-input', u'filename'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__cloud_init_file = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud_init_file(self):
    self.__cloud_init_file = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init-file", parent=self, choice=(u'cloud-init-input', u'filename'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_supplemental_boot_data(self):
    """
    Getter method for supplemental_boot_data, mapped from YANG variable /vnfd_catalog/vnfd/vdu/supplemental_boot_data (container)
    """
    return self.__supplemental_boot_data
      
  def _set_supplemental_boot_data(self, v, load=False):
    """
    Setter method for supplemental_boot_data, mapped from YANG variable /vnfd_catalog/vnfd/vdu/supplemental_boot_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supplemental_boot_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supplemental_boot_data() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_supplemental_boot_data_vnfd__vnfd_catalog_vnfd_vdu_supplemental_boot_data, is_container='container', yang_name="supplemental-boot-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supplemental_boot_data must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_supplemental_boot_data_vnfd__vnfd_catalog_vnfd_vdu_supplemental_boot_data, is_container='container', yang_name="supplemental-boot-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__supplemental_boot_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supplemental_boot_data(self):
    self.__supplemental_boot_data = YANGDynClass(base=yc_supplemental_boot_data_vnfd__vnfd_catalog_vnfd_vdu_supplemental_boot_data, is_container='container', yang_name="supplemental-boot-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_internal_connection_point(self):
    """
    Getter method for internal_connection_point, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point (list)

    YANG Description: List for internal connection points. Each VNFC
has zero or more internal connection points.
Internal connection points are used for connecting
the VNF with components internal to the VNF. If a VNF
has only one VNFC, it may not have any internal
connection points.
    """
    return self.__internal_connection_point
      
  def _set_internal_connection_point(self, v, load=False):
    """
    Setter method for internal_connection_point, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_connection_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_connection_point() directly.

    YANG Description: List for internal connection points. Each VNFC
has zero or more internal connection points.
Internal connection points are used for connecting
the VNF with components internal to the VNF. If a VNF
has only one VNFC, it may not have any internal
connection points.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_vdu_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """internal_connection_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_vdu_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__internal_connection_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_internal_connection_point(self):
    self.__internal_connection_point = YANGDynClass(base=YANGListType("id",yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_vdu_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface (list)

    YANG Description: List of Interfaces (external and internal) for the VNF
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: List of Interfaces (external and internal) for the VNF
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_vnfd__vnfd_catalog_vnfd_vdu_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_vnfd__vnfd_catalog_vnfd_vdu_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_vnfd__vnfd_catalog_vnfd_vdu_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_volumes(self):
    """
    Getter method for volumes, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes (list)
    """
    return self.__volumes
      
  def _set_volumes(self, v, load=False):
    """
    Setter method for volumes, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_volumes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_volumes() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_volumes_vnfd__vnfd_catalog_vnfd_vdu_volumes, yang_name="volumes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """volumes must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_volumes_vnfd__vnfd_catalog_vnfd_vdu_volumes, yang_name="volumes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__volumes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_volumes(self):
    self.__volumes = YANGDynClass(base=YANGListType("name",yc_volumes_vnfd__vnfd_catalog_vnfd_vdu_volumes, yang_name="volumes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  pdu_type = __builtin__.property(_get_pdu_type, _set_pdu_type)
  count = __builtin__.property(_get_count, _set_count)
  mgmt_vpci = __builtin__.property(_get_mgmt_vpci, _set_mgmt_vpci)
  vm_flavor = __builtin__.property(_get_vm_flavor, _set_vm_flavor)
  guest_epa = __builtin__.property(_get_guest_epa, _set_guest_epa)
  vswitch_epa = __builtin__.property(_get_vswitch_epa, _set_vswitch_epa)
  hypervisor_epa = __builtin__.property(_get_hypervisor_epa, _set_hypervisor_epa)
  host_epa = __builtin__.property(_get_host_epa, _set_host_epa)
  alarm = __builtin__.property(_get_alarm, _set_alarm)
  image = __builtin__.property(_get_image, _set_image)
  image_checksum = __builtin__.property(_get_image_checksum, _set_image_checksum)
  alternative_images = __builtin__.property(_get_alternative_images, _set_alternative_images)
  vdu_configuration = __builtin__.property(_get_vdu_configuration, _set_vdu_configuration)
  monitoring_param = __builtin__.property(_get_monitoring_param, _set_monitoring_param)
  cloud_init = __builtin__.property(_get_cloud_init, _set_cloud_init)
  cloud_init_file = __builtin__.property(_get_cloud_init_file, _set_cloud_init_file)
  supplemental_boot_data = __builtin__.property(_get_supplemental_boot_data, _set_supplemental_boot_data)
  internal_connection_point = __builtin__.property(_get_internal_connection_point, _set_internal_connection_point)
  interface = __builtin__.property(_get_interface, _set_interface)
  volumes = __builtin__.property(_get_volumes, _set_volumes)

  __choices__ = {u'cloud-init-input': {u'inline': [u'cloud_init'], u'filename': [u'cloud_init_file']}}
  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('description', description), ('pdu_type', pdu_type), ('count', count), ('mgmt_vpci', mgmt_vpci), ('vm_flavor', vm_flavor), ('guest_epa', guest_epa), ('vswitch_epa', vswitch_epa), ('hypervisor_epa', hypervisor_epa), ('host_epa', host_epa), ('alarm', alarm), ('image', image), ('image_checksum', image_checksum), ('alternative_images', alternative_images), ('vdu_configuration', vdu_configuration), ('monitoring_param', monitoring_param), ('cloud_init', cloud_init), ('cloud_init_file', cloud_init_file), ('supplemental_boot_data', supplemental_boot_data), ('internal_connection_point', internal_connection_point), ('interface', interface), ('volumes', volumes), ])


class yc_script_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_script(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__script_type',)

  _yang_name = 'script'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'script']

  def _get_script_type(self):
    """
    Getter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/script/script_type (enumeration)

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
    return self.__script_type
      
  def _set_script_type(self, v, load=False):
    """
    Setter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/script/script_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_type() directly.

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script_type must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__script_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script_type(self):
    self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  script_type = __builtin__.property(_get_script_type, _set_script_type)

  __choices__ = {u'config-method': {u'script': [u'script_type']}}
  _pyangbind_elements = OrderedDict([('script_type', script_type), ])


class yc_juju_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_juju(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__charm','__proxy','__cloud',)

  _yang_name = 'juju'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'juju']

  def _get_charm(self):
    """
    Getter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    return self.__charm
      
  def _set_charm(self, v, load=False):
    """
    Setter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """charm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__charm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_charm(self):
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_cloud(self):
    """
    Getter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    return self.__cloud
      
  def _set_cloud(self, v, load=False):
    """
    Setter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud(self):
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  charm = __builtin__.property(_get_charm, _set_charm)
  proxy = __builtin__.property(_get_proxy, _set_proxy)
  cloud = __builtin__.property(_get_cloud, _set_cloud)

  __choices__ = {u'config-method': {u'juju': [u'charm', u'proxy', u'cloud']}}
  _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_juju_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_execution_environment_list_juju(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/execution-environment-list/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__charm','__proxy','__cloud',)

  _yang_name = 'juju'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'execution-environment-list', u'juju']

  def _get_charm(self):
    """
    Getter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    return self.__charm
      
  def _set_charm(self, v, load=False):
    """
    Setter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """charm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__charm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_charm(self):
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_cloud(self):
    """
    Getter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    return self.__cloud
      
  def _set_cloud(self, v, load=False):
    """
    Setter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud(self):
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  charm = __builtin__.property(_get_charm, _set_charm)
  proxy = __builtin__.property(_get_proxy, _set_proxy)
  cloud = __builtin__.property(_get_cloud, _set_cloud)

  __choices__ = {u'execution-environment-model': {u'juju': [u'charm', u'proxy', u'cloud']}}
  _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_execution_environment_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/execution-environment-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__juju','__helm_chart','__metric_service','__connection_point_ref',)

  _yang_name = 'execution-environment-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'execution-environment-list']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/id (string)

    YANG Description: Execution environment identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Execution environment identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_juju(self):
    """
    Getter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/juju (container)
    """
    return self.__juju
      
  def _set_juju(self, v, load=False):
    """
    Setter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_juju_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__juju = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju(self):
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_helm_chart(self):
    """
    Getter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/helm_chart (string)

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
    return self.__helm_chart
      
  def _set_helm_chart(self, v, load=False):
    """
    Setter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/helm_chart (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_chart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_chart() directly.

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helm_chart must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__helm_chart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helm_chart(self):
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_metric_service(self):
    """
    Getter method for metric_service, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/metric_service (string)

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
    return self.__metric_service
      
  def _set_metric_service(self, v, load=False):
    """
    Setter method for metric_service, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/metric_service (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_service() directly.

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_service must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__metric_service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_service(self):
    self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_connection_point_ref(self):
    """
    Getter method for connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/connection_point_ref (string)

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
    return self.__connection_point_ref
      
  def _set_connection_point_ref(self, v, load=False):
    """
    Setter method for connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list/connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_point_ref() directly.

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_point_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_point_ref(self):
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  juju = __builtin__.property(_get_juju, _set_juju)
  helm_chart = __builtin__.property(_get_helm_chart, _set_helm_chart)
  metric_service = __builtin__.property(_get_metric_service, _set_metric_service)
  connection_point_ref = __builtin__.property(_get_connection_point_ref, _set_connection_point_ref)

  __choices__ = {u'config-method': {u'execution-environment-list': [u'id', u'metric_service', u'connection_point_ref']}, u'execution-environment-model': {u'juju': [u'juju'], u'helm-chart': [u'helm_chart']}}
  _pyangbind_elements = OrderedDict([('id', id), ('juju', juju), ('helm_chart', helm_chart), ('metric_service', metric_service), ('connection_point_ref', connection_point_ref), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the config primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__mandatory','__default_value','__parameter_pool','__read_only','__hidden',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_mandatory(self):
    """
    Getter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
    return self.__mandatory
      
  def _set_mandatory(self, v, load=False):
    """
    Setter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mandatory must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__mandatory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mandatory(self):
    self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_default_value(self):
    """
    Getter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/default_value (string)

    YANG Description: The default value for this field
    """
    return self.__default_value
      
  def _set_default_value(self, v, load=False):
    """
    Setter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__default_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_value(self):
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_parameter_pool(self):
    """
    Getter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
    return self.__parameter_pool
      
  def _set_parameter_pool(self, v, load=False):
    """
    Setter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter_pool must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__parameter_pool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter_pool(self):
    self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_read_only(self):
    """
    Getter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
    return self.__read_only
      
  def _set_read_only(self, v, load=False):
    """
    Setter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """read_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__read_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_read_only(self):
    self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_hidden(self):
    """
    Getter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
    return self.__hidden
      
  def _set_hidden(self, v, load=False):
    """
    Setter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hidden must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hidden(self):
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  mandatory = __builtin__.property(_get_mandatory, _set_mandatory)
  default_value = __builtin__.property(_get_default_value, _set_default_value)
  parameter_pool = __builtin__.property(_get_parameter_pool, _set_parameter_pool)
  read_only = __builtin__.property(_get_read_only, _set_read_only)
  hidden = __builtin__.property(_get_hidden, _set_hidden)


  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('mandatory', mandatory), ('default_value', default_value), ('parameter_pool', parameter_pool), ('read_only', read_only), ('hidden', hidden), ])


class yc_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__execution_environment_ref','__execution_environment_primitive','__parameter','__user_defined_script',)

  _yang_name = 'config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'config-primitive']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/name (string)

    YANG Description: Name of the config primitive.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the config primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_execution_environment_primitive(self):
    """
    Getter method for execution_environment_primitive, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/execution_environment_primitive (string)

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
    return self.__execution_environment_primitive
      
  def _set_execution_environment_primitive(self, v, load=False):
    """
    Setter method for execution_environment_primitive, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/execution_environment_primitive (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_primitive() directly.

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_primitive must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__execution_environment_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_primitive(self):
    self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter (list)

    YANG Description: List of parameters to the config primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the config primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/user_defined_script (string)

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  execution_environment_primitive = __builtin__.property(_get_execution_environment_primitive, _set_execution_environment_primitive)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)


  _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref), ('execution_environment_primitive', execution_environment_primitive), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_initial_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/initial-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__value',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'initial-config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  value = __builtin__.property(_get_value, _set_value)

  __choices__ = {u'primitive-type': {u'primitive-definition': [u'name', u'data_type', u'value']}}
  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_initial_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/initial-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Initial set of configuration primitives.
  """
  __slots__ = ('_path_helper', '_extmethods', '__seq','__name','__execution_environment_ref','__parameter','__user_defined_script',)

  _yang_name = 'initial-config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'initial-config-primitive']

  def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq
      
  def _set_seq(self, v, load=False):
    """
    Setter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__seq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq(self):
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/name (string)

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  seq = __builtin__.property(_get_seq, _set_seq)
  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

  __choices__ = {u'primitive-type': {u'primitive-definition': [u'name', u'execution_environment_ref', u'parameter', u'user_defined_script']}}
  _pyangbind_elements = OrderedDict([('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_terminate_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/terminate-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__value',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'terminate-config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_terminate_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/terminate-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Terminate set of configuration primitives.
  """
  __slots__ = ('_path_helper', '_extmethods', '__seq','__name','__execution_environment_ref','__parameter','__user_defined_script',)

  _yang_name = 'terminate-config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'terminate-config-primitive']

  def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq
      
  def _set_seq(self, v, load=False):
    """
    Setter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__seq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq(self):
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/name (string)

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  seq = __builtin__.property(_get_seq, _set_seq)
  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)


  _pyangbind_elements = OrderedDict([('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_metrics_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_metrics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VCA related metrics
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__execution_environment_ref','__execution_environment_metric',)

  _yang_name = 'metrics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__execution_environment_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'metrics']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/metrics/name (string)

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/metrics/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment getting that metric
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/metrics/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment getting that metric
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_execution_environment_metric(self):
    """
    Getter method for execution_environment_metric, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/metrics/execution_environment_metric (string)

    YANG Description: Metric in the execution environment referenced by execution-environment-ref
    """
    return self.__execution_environment_metric
      
  def _set_execution_environment_metric(self, v, load=False):
    """
    Setter method for execution_environment_metric, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/metrics/execution_environment_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_metric() directly.

    YANG Description: Metric in the execution environment referenced by execution-environment-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_metric must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__execution_environment_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_metric(self):
    self.__execution_environment_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  execution_environment_metric = __builtin__.property(_get_execution_environment_metric, _set_execution_environment_metric)


  _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref), ('execution_environment_metric', execution_environment_metric), ])


class yc_ssh_access_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_access_ssh_access(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/config-access/ssh-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
  """
  __slots__ = ('_path_helper', '_extmethods', '__required','__default_user',)

  _yang_name = 'ssh-access'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__required = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__default_user = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'config-access', u'ssh-access']

  def _get_required(self):
    """
    Getter method for required, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_access/ssh_access/required (boolean)

    YANG Description: whether ssh access is needed or not
    """
    return self.__required
      
  def _set_required(self, v, load=False):
    """
    Setter method for required, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_access/ssh_access/required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required() directly.

    YANG Description: whether ssh access is needed or not
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required(self):
    self.__required = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_default_user(self):
    """
    Getter method for default_user, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_access/ssh_access/default_user (string)

    YANG Description: Default user for ssh
    """
    return self.__default_user
      
  def _set_default_user(self, v, load=False):
    """
    Setter method for default_user, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_access/ssh_access/default_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_user() directly.

    YANG Description: Default user for ssh
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_user must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__default_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_user(self):
    self.__default_user = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  required = __builtin__.property(_get_required, _set_required)
  default_user = __builtin__.property(_get_default_user, _set_default_user)


  _pyangbind_elements = OrderedDict([('required', required), ('default_user', default_user), ])


class yc_config_access_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_access(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration/config-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
  """
  __slots__ = ('_path_helper', '_extmethods', '__ssh_access',)

  _yang_name = 'config-access'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ssh_access = YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration', u'config-access']

  def _get_ssh_access(self):
    """
    Getter method for ssh_access, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_access/ssh_access (container)

    YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
    """
    return self.__ssh_access
      
  def _set_ssh_access(self, v, load=False):
    """
    Setter method for ssh_access, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_access/ssh_access (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_access() directly.

    YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_access must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__ssh_access = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_access(self):
    self.__ssh_access = YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  ssh_access = __builtin__.property(_get_ssh_access, _set_ssh_access)


  _pyangbind_elements = OrderedDict([('ssh_access', ssh_access), ])


class yc_kdu_configuration_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/kdu-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__script','__juju','__execution_environment_list','__config_primitive','__initial_config_primitive','__terminate_config_primitive','__metrics','__config_access','__blacklist_config_primitive',)

  _yang_name = 'kdu-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config_primitive = YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__execution_environment_list = YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__blacklist_config_primitive = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'upgrade': {}, u'rollback': {}},)), is_leaf=False, yang_name="blacklist-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__config_access = YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'kdu-configuration']

  def _get_script(self):
    """
    Getter method for script, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/script (container)
    """
    return self.__script
      
  def _set_script(self, v, load=False):
    """
    Setter method for script, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/script (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_script_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script(self):
    self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_juju(self):
    """
    Getter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/juju (container)
    """
    return self.__juju
      
  def _set_juju(self, v, load=False):
    """
    Setter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_juju_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__juju = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju(self):
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_execution_environment_list(self):
    """
    Getter method for execution_environment_list, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list (list)
    """
    return self.__execution_environment_list
      
  def _set_execution_environment_list(self, v, load=False):
    """
    Setter method for execution_environment_list, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/execution_environment_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__execution_environment_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_list(self):
    self.__execution_environment_list = YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_config_primitive(self):
    """
    Getter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive (list)

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
    return self.__config_primitive
      
  def _set_config_primitive(self, v, load=False):
    """
    Setter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_primitive() directly.

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_primitive(self):
    self.__config_primitive = YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_initial_config_primitive(self):
    """
    Getter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive (list)

    YANG Description: Initial set of configuration primitives.
    """
    return self.__initial_config_primitive
      
  def _set_initial_config_primitive(self, v, load=False):
    """
    Setter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/initial_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_initial_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_initial_config_primitive() directly.

    YANG Description: Initial set of configuration primitives.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """initial_config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__initial_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_initial_config_primitive(self):
    self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_terminate_config_primitive(self):
    """
    Getter method for terminate_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive (list)

    YANG Description: Terminate set of configuration primitives.
    """
    return self.__terminate_config_primitive
      
  def _set_terminate_config_primitive(self, v, load=False):
    """
    Setter method for terminate_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/terminate_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_config_primitive() directly.

    YANG Description: Terminate set of configuration primitives.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminate_config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__terminate_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminate_config_primitive(self):
    self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_metrics(self):
    """
    Getter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/metrics (list)

    YANG Description: List of VCA related metrics
    """
    return self.__metrics
      
  def _set_metrics(self, v, load=False):
    """
    Setter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: List of VCA related metrics
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metrics must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__metrics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metrics(self):
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_config_access(self):
    """
    Getter method for config_access, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_access (container)

    YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
    """
    return self.__config_access
      
  def _set_config_access(self, v, load=False):
    """
    Setter method for config_access, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/config_access (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_access() directly.

    YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_access_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_access must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__config_access = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_access(self):
    self.__config_access = YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_blacklist_config_primitive(self):
    """
    Getter method for blacklist_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/blacklist_config_primitive (enumeration)

    YANG Description: List of blacklisted config primitives from the list of
default kdu config primitives
    """
    return self.__blacklist_config_primitive
      
  def _set_blacklist_config_primitive(self, v, load=False):
    """
    Setter method for blacklist_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration/blacklist_config_primitive (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_blacklist_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_blacklist_config_primitive() directly.

    YANG Description: List of blacklisted config primitives from the list of
default kdu config primitives
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'upgrade': {}, u'rollback': {}},)), is_leaf=False, yang_name="blacklist-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """blacklist_config_primitive must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'upgrade': {}, u'rollback': {}},)), is_leaf=False, yang_name="blacklist-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__blacklist_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_blacklist_config_primitive(self):
    self.__blacklist_config_primitive = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'upgrade': {}, u'rollback': {}},)), is_leaf=False, yang_name="blacklist-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  script = __builtin__.property(_get_script, _set_script)
  juju = __builtin__.property(_get_juju, _set_juju)
  execution_environment_list = __builtin__.property(_get_execution_environment_list, _set_execution_environment_list)
  config_primitive = __builtin__.property(_get_config_primitive, _set_config_primitive)
  initial_config_primitive = __builtin__.property(_get_initial_config_primitive, _set_initial_config_primitive)
  terminate_config_primitive = __builtin__.property(_get_terminate_config_primitive, _set_terminate_config_primitive)
  metrics = __builtin__.property(_get_metrics, _set_metrics)
  config_access = __builtin__.property(_get_config_access, _set_config_access)
  blacklist_config_primitive = __builtin__.property(_get_blacklist_config_primitive, _set_blacklist_config_primitive)

  __choices__ = {u'config-method': {u'juju': [u'juju'], u'execution-environment-list': [u'execution_environment_list'], u'script': [u'script']}}
  _pyangbind_elements = OrderedDict([('script', script), ('juju', juju), ('execution_environment_list', execution_environment_list), ('config_primitive', config_primitive), ('initial_config_primitive', initial_config_primitive), ('terminate_config_primitive', terminate_config_primitive), ('metrics', metrics), ('config_access', config_access), ('blacklist_config_primitive', blacklist_config_primitive), ])


class yc_service_vnfd__vnfd_catalog_vnfd_kdu_service(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu/service. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Kubernetes services exposed by the KDU.
If empty, all services are assumed to be exposed in the CP associated to the first network
in k8s-cluster.nets.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__mgmt_service','__external_connection_point_ref',)

  _yang_name = 'service'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__mgmt_service = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu', u'service']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/service/name (string)

    YANG Description: Name of the Kubernetes service exposed by he KDU model
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/service/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the Kubernetes service exposed by he KDU model
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_mgmt_service(self):
    """
    Getter method for mgmt_service, mapped from YANG variable /vnfd_catalog/vnfd/kdu/service/mgmt_service (boolean)

    YANG Description: Flag to indicate that this Kubernetes service is a mgmt service
to be used for KDU configuration. Defaults to false (if no present).
All services with mgmt-service set to true will be passed to the execution
environment in charge of the KDU configuration.
    """
    return self.__mgmt_service
      
  def _set_mgmt_service(self, v, load=False):
    """
    Setter method for mgmt_service, mapped from YANG variable /vnfd_catalog/vnfd/kdu/service/mgmt_service (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_service() directly.

    YANG Description: Flag to indicate that this Kubernetes service is a mgmt service
to be used for KDU configuration. Defaults to false (if no present).
All services with mgmt-service set to true will be passed to the execution
environment in charge of the KDU configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_service must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__mgmt_service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_service(self):
    self.__mgmt_service = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_external_connection_point_ref(self):
    """
    Getter method for external_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/service/external_connection_point_ref (leafref)

    YANG Description: Leaf Ref to the particular external connection point
    """
    return self.__external_connection_point_ref
      
  def _set_external_connection_point_ref(self, v, load=False):
    """
    Setter method for external_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/kdu/service/external_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_connection_point_ref() directly.

    YANG Description: Leaf Ref to the particular external connection point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__external_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external_connection_point_ref(self):
    self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  mgmt_service = __builtin__.property(_get_mgmt_service, _set_mgmt_service)
  external_connection_point_ref = __builtin__.property(_get_external_connection_point_ref, _set_external_connection_point_ref)


  _pyangbind_elements = OrderedDict([('name', name), ('mgmt_service', mgmt_service), ('external_connection_point_ref', external_connection_point_ref), ])


class yc_kdu_vnfd__vnfd_catalog_vnfd_kdu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/kdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of K8s Deployment Units
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__kdu_configuration','__helm_chart','__juju_bundle','__service',)

  _yang_name = 'kdu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__juju_bundle = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self, choice=(u'kdu-model', u'juju-bundle'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__service = YANGDynClass(base=YANGListType("name",yc_service_vnfd__vnfd_catalog_vnfd_kdu_service, yang_name="service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'kdu-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__kdu_configuration = YANGDynClass(base=yc_kdu_configuration_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration, is_container='container', yang_name="kdu-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'kdu']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/name (string)

    YANG Description: Unique name for the KDU
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/kdu/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Unique name for the KDU
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/kdu/description (string)

    YANG Description: Description of the KDU.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/kdu/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the KDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_kdu_configuration(self):
    """
    Getter method for kdu_configuration, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration (container)
    """
    return self.__kdu_configuration
      
  def _set_kdu_configuration(self, v, load=False):
    """
    Setter method for kdu_configuration, mapped from YANG variable /vnfd_catalog/vnfd/kdu/kdu_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_kdu_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_kdu_configuration() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_kdu_configuration_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration, is_container='container', yang_name="kdu-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """kdu_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_kdu_configuration_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration, is_container='container', yang_name="kdu-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__kdu_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_kdu_configuration(self):
    self.__kdu_configuration = YANGDynClass(base=yc_kdu_configuration_vnfd__vnfd_catalog_vnfd_kdu_kdu_configuration, is_container='container', yang_name="kdu-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_helm_chart(self):
    """
    Getter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/kdu/helm_chart (string)

    YANG Description: Helm chart that models the KDU, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder under k8s_models folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under k8s_models folder in the package>
- <URL_where_to_fetch_chart>

    """
    return self.__helm_chart
      
  def _set_helm_chart(self, v, load=False):
    """
    Setter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/kdu/helm_chart (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_chart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_chart() directly.

    YANG Description: Helm chart that models the KDU, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder under k8s_models folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under k8s_models folder in the package>
- <URL_where_to_fetch_chart>

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'kdu-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helm_chart must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'kdu-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__helm_chart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helm_chart(self):
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'kdu-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_juju_bundle(self):
    """
    Getter method for juju_bundle, mapped from YANG variable /vnfd_catalog/vnfd/kdu/juju_bundle (string)

    YANG Description: Juju bundle that models the KDU, in any of the following ways:
- <juju-repo>/<juju-bundle>
- <juju-bundle folder under k8s_models folder in the package>
- <juju-bundle tgz file (w/ or w/o extension) under k8s_models folder in the package>
- <URL_where_to_fetch_juju_bundle>

    """
    return self.__juju_bundle
      
  def _set_juju_bundle(self, v, load=False):
    """
    Setter method for juju_bundle, mapped from YANG variable /vnfd_catalog/vnfd/kdu/juju_bundle (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju_bundle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju_bundle() directly.

    YANG Description: Juju bundle that models the KDU, in any of the following ways:
- <juju-repo>/<juju-bundle>
- <juju-bundle folder under k8s_models folder in the package>
- <juju-bundle tgz file (w/ or w/o extension) under k8s_models folder in the package>
- <URL_where_to_fetch_juju_bundle>

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self, choice=(u'kdu-model', u'juju-bundle'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju_bundle must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self, choice=(u'kdu-model', u'juju-bundle'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__juju_bundle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju_bundle(self):
    self.__juju_bundle = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self, choice=(u'kdu-model', u'juju-bundle'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_service(self):
    """
    Getter method for service, mapped from YANG variable /vnfd_catalog/vnfd/kdu/service (list)

    YANG Description: List of Kubernetes services exposed by the KDU.
If empty, all services are assumed to be exposed in the CP associated to the first network
in k8s-cluster.nets.
    """
    return self.__service
      
  def _set_service(self, v, load=False):
    """
    Setter method for service, mapped from YANG variable /vnfd_catalog/vnfd/kdu/service (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service() directly.

    YANG Description: List of Kubernetes services exposed by the KDU.
If empty, all services are assumed to be exposed in the CP associated to the first network
in k8s-cluster.nets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_service_vnfd__vnfd_catalog_vnfd_kdu_service, yang_name="service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_service_vnfd__vnfd_catalog_vnfd_kdu_service, yang_name="service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service(self):
    self.__service = YANGDynClass(base=YANGListType("name",yc_service_vnfd__vnfd_catalog_vnfd_kdu_service, yang_name="service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  kdu_configuration = __builtin__.property(_get_kdu_configuration, _set_kdu_configuration)
  helm_chart = __builtin__.property(_get_helm_chart, _set_helm_chart)
  juju_bundle = __builtin__.property(_get_juju_bundle, _set_juju_bundle)
  service = __builtin__.property(_get_service, _set_service)

  __choices__ = {u'kdu-model': {u'juju-bundle': [u'juju_bundle'], u'helm-chart': [u'helm_chart']}}
  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('kdu_configuration', kdu_configuration), ('helm_chart', helm_chart), ('juju_bundle', juju_bundle), ('service', service), ])


class yc_script_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_script(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__script_type',)

  _yang_name = 'script'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'script']

  def _get_script_type(self):
    """
    Getter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/script/script_type (enumeration)

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
    return self.__script_type
      
  def _set_script_type(self, v, load=False):
    """
    Setter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/script/script_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_type() directly.

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script_type must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__script_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script_type(self):
    self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  script_type = __builtin__.property(_get_script_type, _set_script_type)

  __choices__ = {u'config-method': {u'script': [u'script_type']}}
  _pyangbind_elements = OrderedDict([('script_type', script_type), ])


class yc_juju_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_juju(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__charm','__proxy','__cloud',)

  _yang_name = 'juju'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'juju']

  def _get_charm(self):
    """
    Getter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    return self.__charm
      
  def _set_charm(self, v, load=False):
    """
    Setter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """charm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__charm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_charm(self):
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_cloud(self):
    """
    Getter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    return self.__cloud
      
  def _set_cloud(self, v, load=False):
    """
    Setter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud(self):
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  charm = __builtin__.property(_get_charm, _set_charm)
  proxy = __builtin__.property(_get_proxy, _set_proxy)
  cloud = __builtin__.property(_get_cloud, _set_cloud)

  __choices__ = {u'config-method': {u'juju': [u'charm', u'proxy', u'cloud']}}
  _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_juju_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_execution_environment_list_juju(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/execution-environment-list/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__charm','__proxy','__cloud',)

  _yang_name = 'juju'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'execution-environment-list', u'juju']

  def _get_charm(self):
    """
    Getter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    return self.__charm
      
  def _set_charm(self, v, load=False):
    """
    Setter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """charm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__charm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_charm(self):
    self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_proxy(self):
    """
    Getter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
    return self.__proxy
      
  def _set_proxy(self, v, load=False):
    """
    Setter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proxy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proxy(self):
    self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_cloud(self):
    """
    Getter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    return self.__cloud
      
  def _set_cloud(self, v, load=False):
    """
    Setter method for cloud, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud(self):
    self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'k8s': {}, u'lxd': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  charm = __builtin__.property(_get_charm, _set_charm)
  proxy = __builtin__.property(_get_proxy, _set_proxy)
  cloud = __builtin__.property(_get_cloud, _set_cloud)

  __choices__ = {u'execution-environment-model': {u'juju': [u'charm', u'proxy', u'cloud']}}
  _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_execution_environment_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/execution-environment-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__juju','__helm_chart','__metric_service','__connection_point_ref',)

  _yang_name = 'execution-environment-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'execution-environment-list']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/id (string)

    YANG Description: Execution environment identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Execution environment identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_juju(self):
    """
    Getter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/juju (container)
    """
    return self.__juju
      
  def _set_juju(self, v, load=False):
    """
    Setter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_juju_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__juju = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju(self):
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=(u'execution-environment-model', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_helm_chart(self):
    """
    Getter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/helm_chart (string)

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
    return self.__helm_chart
      
  def _set_helm_chart(self, v, load=False):
    """
    Setter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/helm_chart (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_chart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_chart() directly.

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helm_chart must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__helm_chart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helm_chart(self):
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'execution-environment-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_metric_service(self):
    """
    Getter method for metric_service, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/metric_service (string)

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
    return self.__metric_service
      
  def _set_metric_service(self, v, load=False):
    """
    Setter method for metric_service, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/metric_service (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_service() directly.

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_service must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__metric_service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_service(self):
    self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_connection_point_ref(self):
    """
    Getter method for connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/connection_point_ref (string)

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
    return self.__connection_point_ref
      
  def _set_connection_point_ref(self, v, load=False):
    """
    Setter method for connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list/connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_point_ref() directly.

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_point_ref must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_point_ref(self):
    self.__connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connection-point-ref", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  juju = __builtin__.property(_get_juju, _set_juju)
  helm_chart = __builtin__.property(_get_helm_chart, _set_helm_chart)
  metric_service = __builtin__.property(_get_metric_service, _set_metric_service)
  connection_point_ref = __builtin__.property(_get_connection_point_ref, _set_connection_point_ref)

  __choices__ = {u'config-method': {u'execution-environment-list': [u'id', u'metric_service', u'connection_point_ref']}, u'execution-environment-model': {u'juju': [u'juju'], u'helm-chart': [u'helm_chart']}}
  _pyangbind_elements = OrderedDict([('id', id), ('juju', juju), ('helm_chart', helm_chart), ('metric_service', metric_service), ('connection_point_ref', connection_point_ref), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the config primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__mandatory','__default_value','__parameter_pool','__read_only','__hidden',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_mandatory(self):
    """
    Getter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
    return self.__mandatory
      
  def _set_mandatory(self, v, load=False):
    """
    Setter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mandatory must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__mandatory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mandatory(self):
    self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_default_value(self):
    """
    Getter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/default_value (string)

    YANG Description: The default value for this field
    """
    return self.__default_value
      
  def _set_default_value(self, v, load=False):
    """
    Setter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__default_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_value(self):
    self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_parameter_pool(self):
    """
    Getter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
    return self.__parameter_pool
      
  def _set_parameter_pool(self, v, load=False):
    """
    Setter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter_pool must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__parameter_pool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter_pool(self):
    self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_read_only(self):
    """
    Getter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
    return self.__read_only
      
  def _set_read_only(self, v, load=False):
    """
    Setter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """read_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__read_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_read_only(self):
    self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_hidden(self):
    """
    Getter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
    return self.__hidden
      
  def _set_hidden(self, v, load=False):
    """
    Setter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hidden must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hidden(self):
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  mandatory = __builtin__.property(_get_mandatory, _set_mandatory)
  default_value = __builtin__.property(_get_default_value, _set_default_value)
  parameter_pool = __builtin__.property(_get_parameter_pool, _set_parameter_pool)
  read_only = __builtin__.property(_get_read_only, _set_read_only)
  hidden = __builtin__.property(_get_hidden, _set_hidden)


  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('mandatory', mandatory), ('default_value', default_value), ('parameter_pool', parameter_pool), ('read_only', read_only), ('hidden', hidden), ])


class yc_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__execution_environment_ref','__execution_environment_primitive','__parameter','__user_defined_script',)

  _yang_name = 'config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'config-primitive']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/name (string)

    YANG Description: Name of the config primitive.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the config primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_execution_environment_primitive(self):
    """
    Getter method for execution_environment_primitive, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/execution_environment_primitive (string)

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
    return self.__execution_environment_primitive
      
  def _set_execution_environment_primitive(self, v, load=False):
    """
    Setter method for execution_environment_primitive, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/execution_environment_primitive (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_primitive() directly.

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_primitive must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__execution_environment_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_primitive(self):
    self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter (list)

    YANG Description: List of parameters to the config primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the config primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/user_defined_script (string)

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  execution_environment_primitive = __builtin__.property(_get_execution_environment_primitive, _set_execution_environment_primitive)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)


  _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref), ('execution_environment_primitive', execution_environment_primitive), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_initial_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/initial-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__value',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'initial-config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  value = __builtin__.property(_get_value, _set_value)

  __choices__ = {u'primitive-type': {u'primitive-definition': [u'name', u'data_type', u'value']}}
  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_initial_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/initial-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Initial set of configuration primitives.
  """
  __slots__ = ('_path_helper', '_extmethods', '__seq','__name','__execution_environment_ref','__parameter','__user_defined_script',)

  _yang_name = 'initial-config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'initial-config-primitive']

  def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq
      
  def _set_seq(self, v, load=False):
    """
    Setter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__seq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq(self):
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/name (string)

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  seq = __builtin__.property(_get_seq, _set_seq)
  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

  __choices__ = {u'primitive-type': {u'primitive-definition': [u'name', u'execution_environment_ref', u'parameter', u'user_defined_script']}}
  _pyangbind_elements = OrderedDict([('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_terminate_config_primitive_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/terminate-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__data_type','__value',)

  _yang_name = 'parameter'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'terminate-config-primitive', u'parameter']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_data_type(self):
    """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
    return self.__data_type
      
  def _set_data_type(self, v, load=False):
    """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""",
          'defined-type': "manotypes:parameter-data-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""",
        })

    self.__data_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_type(self):
    self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  data_type = __builtin__.property(_get_data_type, _set_data_type)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_terminate_config_primitive(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/terminate-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Terminate set of configuration primitives.
  """
  __slots__ = ('_path_helper', '_extmethods', '__seq','__name','__execution_environment_ref','__parameter','__user_defined_script',)

  _yang_name = 'terminate-config-primitive'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'terminate-config-primitive']

  def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq
      
  def _set_seq(self, v, load=False):
    """
    Setter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__seq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq(self):
    self.__seq = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/name (string)

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive in the execution environment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script
      
  def _set_user_defined_script(self, v, load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined_script must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__user_defined_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  seq = __builtin__.property(_get_seq, _set_seq)
  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  parameter = __builtin__.property(_get_parameter, _set_parameter)
  user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)


  _pyangbind_elements = OrderedDict([('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref), ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_metrics_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_metrics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VCA related metrics
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__execution_environment_ref','__execution_environment_metric',)

  _yang_name = 'metrics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__execution_environment_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'metrics']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/metrics/name (string)

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_execution_environment_ref(self):
    """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/metrics/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment getting that metric
    """
    return self.__execution_environment_ref
      
  def _set_execution_environment_ref(self, v, load=False):
    """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/metrics/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment getting that metric
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__execution_environment_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_ref(self):
    self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_execution_environment_metric(self):
    """
    Getter method for execution_environment_metric, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/metrics/execution_environment_metric (string)

    YANG Description: Metric in the execution environment referenced by execution-environment-ref
    """
    return self.__execution_environment_metric
      
  def _set_execution_environment_metric(self, v, load=False):
    """
    Setter method for execution_environment_metric, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/metrics/execution_environment_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_metric() directly.

    YANG Description: Metric in the execution environment referenced by execution-environment-ref
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_metric must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__execution_environment_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_metric(self):
    self.__execution_environment_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
  execution_environment_metric = __builtin__.property(_get_execution_environment_metric, _set_execution_environment_metric)


  _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref), ('execution_environment_metric', execution_environment_metric), ])


class yc_ssh_access_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_access_ssh_access(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/config-access/ssh-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
  """
  __slots__ = ('_path_helper', '_extmethods', '__required','__default_user',)

  _yang_name = 'ssh-access'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__required = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__default_user = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'config-access', u'ssh-access']

  def _get_required(self):
    """
    Getter method for required, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_access/ssh_access/required (boolean)

    YANG Description: whether ssh access is needed or not
    """
    return self.__required
      
  def _set_required(self, v, load=False):
    """
    Setter method for required, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_access/ssh_access/required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required() directly.

    YANG Description: whether ssh access is needed or not
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required(self):
    self.__required = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_default_user(self):
    """
    Getter method for default_user, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_access/ssh_access/default_user (string)

    YANG Description: Default user for ssh
    """
    return self.__default_user
      
  def _set_default_user(self, v, load=False):
    """
    Setter method for default_user, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_access/ssh_access/default_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_user() directly.

    YANG Description: Default user for ssh
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_user must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__default_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_user(self):
    self.__default_user = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  required = __builtin__.property(_get_required, _set_required)
  default_user = __builtin__.property(_get_default_user, _set_default_user)


  _pyangbind_elements = OrderedDict([('required', required), ('default_user', default_user), ])


class yc_config_access_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_access(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration/config-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
  """
  __slots__ = ('_path_helper', '_extmethods', '__ssh_access',)

  _yang_name = 'config-access'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ssh_access = YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration', u'config-access']

  def _get_ssh_access(self):
    """
    Getter method for ssh_access, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_access/ssh_access (container)

    YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
    """
    return self.__ssh_access
      
  def _set_ssh_access(self, v, load=False):
    """
    Setter method for ssh_access, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_access/ssh_access (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_access() directly.

    YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_access must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__ssh_access = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_access(self):
    self.__ssh_access = YANGDynClass(base=yc_ssh_access_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  ssh_access = __builtin__.property(_get_ssh_access, _set_ssh_access)


  _pyangbind_elements = OrderedDict([('ssh_access', ssh_access), ])


class yc_paas_configuration_vnfd__vnfd_catalog_vnfd_paas_paas_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__script','__juju','__execution_environment_list','__config_primitive','__initial_config_primitive','__terminate_config_primitive','__metrics','__config_access','__blacklist_config_primitive',)

  _yang_name = 'paas-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config_primitive = YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__execution_environment_list = YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__blacklist_config_primitive = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'upgrade': {}, u'rollback': {}},)), is_leaf=False, yang_name="blacklist-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__config_access = YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-configuration']

  def _get_script(self):
    """
    Getter method for script, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/script (container)
    """
    return self.__script
      
  def _set_script(self, v, load=False):
    """
    Setter method for script, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/script (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_script_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """script must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_script(self):
    self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_juju(self):
    """
    Getter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/juju (container)
    """
    return self.__juju
      
  def _set_juju(self, v, load=False):
    """
    Setter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_juju_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__juju = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju(self):
    self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_execution_environment_list(self):
    """
    Getter method for execution_environment_list, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list (list)
    """
    return self.__execution_environment_list
      
  def _set_execution_environment_list(self, v, load=False):
    """
    Setter method for execution_environment_list, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/execution_environment_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_list() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """execution_environment_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__execution_environment_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_execution_environment_list(self):
    self.__execution_environment_list = YANGDynClass(base=YANGListType("id",yc_execution_environment_list_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=(u'config-method', u'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_config_primitive(self):
    """
    Getter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive (list)

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
    return self.__config_primitive
      
  def _set_config_primitive(self, v, load=False):
    """
    Setter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_primitive() directly.

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_primitive(self):
    self.__config_primitive = YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_initial_config_primitive(self):
    """
    Getter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive (list)

    YANG Description: Initial set of configuration primitives.
    """
    return self.__initial_config_primitive
      
  def _set_initial_config_primitive(self, v, load=False):
    """
    Setter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/initial_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_initial_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_initial_config_primitive() directly.

    YANG Description: Initial set of configuration primitives.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """initial_config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__initial_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_initial_config_primitive(self):
    self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_terminate_config_primitive(self):
    """
    Getter method for terminate_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive (list)

    YANG Description: Terminate set of configuration primitives.
    """
    return self.__terminate_config_primitive
      
  def _set_terminate_config_primitive(self, v, load=False):
    """
    Setter method for terminate_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/terminate_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_config_primitive() directly.

    YANG Description: Terminate set of configuration primitives.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminate_config_primitive must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__terminate_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminate_config_primitive(self):
    self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_metrics(self):
    """
    Getter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/metrics (list)

    YANG Description: List of VCA related metrics
    """
    return self.__metrics
      
  def _set_metrics(self, v, load=False):
    """
    Setter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: List of VCA related metrics
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metrics must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__metrics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metrics(self):
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_config_access(self):
    """
    Getter method for config_access, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_access (container)

    YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
    """
    return self.__config_access
      
  def _set_config_access(self, v, load=False):
    """
    Setter method for config_access, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/config_access (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_access() directly.

    YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_access_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_access must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__config_access = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_access(self):
    self.__config_access = YANGDynClass(base=yc_config_access_vnfd__vnfd_catalog_vnfd_paas_paas_configuration_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_blacklist_config_primitive(self):
    """
    Getter method for blacklist_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/blacklist_config_primitive (enumeration)

    YANG Description: List of blacklisted config primitives from the list of
default paas config primitives
    """
    return self.__blacklist_config_primitive
      
  def _set_blacklist_config_primitive(self, v, load=False):
    """
    Setter method for blacklist_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration/blacklist_config_primitive (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_blacklist_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_blacklist_config_primitive() directly.

    YANG Description: List of blacklisted config primitives from the list of
default paas config primitives
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'upgrade': {}, u'rollback': {}},)), is_leaf=False, yang_name="blacklist-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """blacklist_config_primitive must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'upgrade': {}, u'rollback': {}},)), is_leaf=False, yang_name="blacklist-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__blacklist_config_primitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_blacklist_config_primitive(self):
    self.__blacklist_config_primitive = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'upgrade': {}, u'rollback': {}},)), is_leaf=False, yang_name="blacklist-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

  script = __builtin__.property(_get_script, _set_script)
  juju = __builtin__.property(_get_juju, _set_juju)
  execution_environment_list = __builtin__.property(_get_execution_environment_list, _set_execution_environment_list)
  config_primitive = __builtin__.property(_get_config_primitive, _set_config_primitive)
  initial_config_primitive = __builtin__.property(_get_initial_config_primitive, _set_initial_config_primitive)
  terminate_config_primitive = __builtin__.property(_get_terminate_config_primitive, _set_terminate_config_primitive)
  metrics = __builtin__.property(_get_metrics, _set_metrics)
  config_access = __builtin__.property(_get_config_access, _set_config_access)
  blacklist_config_primitive = __builtin__.property(_get_blacklist_config_primitive, _set_blacklist_config_primitive)

  __choices__ = {u'config-method': {u'juju': [u'juju'], u'execution-environment-list': [u'execution_environment_list'], u'script': [u'script']}}
  _pyangbind_elements = OrderedDict([('script', script), ('juju', juju), ('execution_environment_list', execution_environment_list), ('config_primitive', config_primitive), ('initial_config_primitive', initial_config_primitive), ('terminate_config_primitive', terminate_config_primitive), ('metrics', metrics), ('config_access', config_access), ('blacklist_config_primitive', blacklist_config_primitive), ])


class yc_paas_requirements_vnfd__vnfd_catalog_vnfd_paas_paas_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__typepaas','__throughput','__maximum_users',)

  _yang_name = 'paas-requirements'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__throughput = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="throughput", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)
    self.__typepaas = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'CONTAINER': {}, u'VM': {}},), is_leaf=True, yang_name="typepaas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__maximum_users = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maximum-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-requirements']

  def _get_typepaas(self):
    """
    Getter method for typepaas, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_requirements/typepaas (enumeration)

    YANG Description: Type of PaaS (container or VM)
    """
    return self.__typepaas
      
  def _set_typepaas(self, v, load=False):
    """
    Setter method for typepaas, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_requirements/typepaas (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_typepaas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_typepaas() directly.

    YANG Description: Type of PaaS (container or VM)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'CONTAINER': {}, u'VM': {}},), is_leaf=True, yang_name="typepaas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """typepaas must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'CONTAINER': {}, u'VM': {}},), is_leaf=True, yang_name="typepaas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__typepaas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_typepaas(self):
    self.__typepaas = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'CONTAINER': {}, u'VM': {}},), is_leaf=True, yang_name="typepaas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_throughput(self):
    """
    Getter method for throughput, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_requirements/throughput (uint16)

    YANG Description: Maximum throughput of PaaS
    """
    return self.__throughput
      
  def _set_throughput(self, v, load=False):
    """
    Setter method for throughput, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_requirements/throughput (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_throughput is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_throughput() directly.

    YANG Description: Maximum throughput of PaaS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="throughput", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """throughput must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="throughput", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)""",
        })

    self.__throughput = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_throughput(self):
    self.__throughput = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="throughput", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)


  def _get_maximum_users(self):
    """
    Getter method for maximum_users, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_requirements/maximum_users (uint64)

    YANG Description: Maximum number of connected users
    """
    return self.__maximum_users
      
  def _set_maximum_users(self, v, load=False):
    """
    Setter method for maximum_users, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_requirements/maximum_users (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_users is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_users() directly.

    YANG Description: Maximum number of connected users
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maximum-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_users must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maximum-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__maximum_users = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_users(self):
    self.__maximum_users = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maximum-users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

  typepaas = __builtin__.property(_get_typepaas, _set_typepaas)
  throughput = __builtin__.property(_get_throughput, _set_throughput)
  maximum_users = __builtin__.property(_get_maximum_users, _set_maximum_users)


  _pyangbind_elements = OrderedDict([('typepaas', typepaas), ('throughput', throughput), ('maximum_users', maximum_users), ])


class yc_interface_vnfd__vnfd_catalog_vnfd_paas_paas_interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of paas interfaces: Quality, type & external connection point  of each interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__quality','__external_connection_point_ref',)

  _yang_name = 'interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__quality = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'HIGH': {}, u'BEST-EFFORT': {}, u'MID': {}},), is_leaf=True, yang_name="quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-interfaces', u'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces/interface/name (uint64)

    YANG Description: paas interface unique name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces/interface/name (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: paas interface unique name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces/interface/type (string)

    YANG Description: Type of paas interface
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces/interface/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of paas interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_quality(self):
    """
    Getter method for quality, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces/interface/quality (enumeration)

    YANG Description: paas interface unique name
    """
    return self.__quality
      
  def _set_quality(self, v, load=False):
    """
    Setter method for quality, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces/interface/quality (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_quality is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_quality() directly.

    YANG Description: paas interface unique name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'HIGH': {}, u'BEST-EFFORT': {}, u'MID': {}},), is_leaf=True, yang_name="quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """quality must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'HIGH': {}, u'BEST-EFFORT': {}, u'MID': {}},), is_leaf=True, yang_name="quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__quality = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_quality(self):
    self.__quality = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'HIGH': {}, u'BEST-EFFORT': {}, u'MID': {}},), is_leaf=True, yang_name="quality", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_external_connection_point_ref(self):
    """
    Getter method for external_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces/interface/external_connection_point_ref (leafref)

    YANG Description: Leaf Ref to the particular external connection point
    """
    return self.__external_connection_point_ref
      
  def _set_external_connection_point_ref(self, v, load=False):
    """
    Setter method for external_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces/interface/external_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_connection_point_ref() directly.

    YANG Description: Leaf Ref to the particular external connection point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__external_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external_connection_point_ref(self):
    self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  quality = __builtin__.property(_get_quality, _set_quality)
  external_connection_point_ref = __builtin__.property(_get_external_connection_point_ref, _set_external_connection_point_ref)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('quality', quality), ('external_connection_point_ref', external_connection_point_ref), ])


class yc_paas_interfaces_vnfd__vnfd_catalog_vnfd_paas_paas_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/paas-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'paas-interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_vnfd__vnfd_catalog_vnfd_paas_paas_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'paas-interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces/interface (list)

    YANG Description: List of paas interfaces: Quality, type & external connection point  of each interface
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: List of paas interfaces: Quality, type & external connection point  of each interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_vnfd__vnfd_catalog_vnfd_paas_paas_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_vnfd__vnfd_catalog_vnfd_paas_paas_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_vnfd__vnfd_catalog_vnfd_paas_paas_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_paas_mgmt_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas/mgmt-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface over which the PaaS is managed.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cp',)

  _yang_name = 'mgmt-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas', u'mgmt-interface']

  def _get_cp(self):
    """
    Getter method for cp, mapped from YANG variable /vnfd_catalog/vnfd/paas/mgmt_interface/cp (leafref)

    YANG Description: Use the ip address associated with this connection point. This cp is then considered as management.
    """
    return self.__cp
      
  def _set_cp(self, v, load=False):
    """
    Setter method for cp, mapped from YANG variable /vnfd_catalog/vnfd/paas/mgmt_interface/cp (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp() directly.

    YANG Description: Use the ip address associated with this connection point. This cp is then considered as management.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__cp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp(self):
    self.__cp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  cp = __builtin__.property(_get_cp, _set_cp)


  _pyangbind_elements = OrderedDict([('cp', cp), ])


class yc_paas_vnfd__vnfd_catalog_vnfd_paas(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/paas. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of PaaS Deployment Units
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__description','__paas_configuration','__helm_chart','__juju_bundle','__paas_requirements','__paas_interfaces','__mgmt_interface',)

  _yang_name = 'paas'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__juju_bundle = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self, choice=(u'paas-model', u'juju-bundle'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'paas-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__paas_requirements = YANGDynClass(base=yc_paas_requirements_vnfd__vnfd_catalog_vnfd_paas_paas_requirements, is_container='container', yang_name="paas-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__mgmt_interface = YANGDynClass(base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_paas_mgmt_interface, is_container='container', yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__paas_configuration = YANGDynClass(base=yc_paas_configuration_vnfd__vnfd_catalog_vnfd_paas_paas_configuration, is_container='container', yang_name="paas-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__paas_interfaces = YANGDynClass(base=yc_paas_interfaces_vnfd__vnfd_catalog_vnfd_paas_paas_interfaces, is_container='container', yang_name="paas-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'paas']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/paas/id (string)

    YANG Description: Unique id for the PaaS
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/paas/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique id for the PaaS
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/name (string)

    YANG Description: Unique name for the PaaS
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/paas/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Unique name for the PaaS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/paas/description (string)

    YANG Description: Description of the PaaS.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/paas/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the PaaS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_paas_configuration(self):
    """
    Getter method for paas_configuration, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration (container)
    """
    return self.__paas_configuration
      
  def _set_paas_configuration(self, v, load=False):
    """
    Setter method for paas_configuration, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paas_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paas_configuration() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_paas_configuration_vnfd__vnfd_catalog_vnfd_paas_paas_configuration, is_container='container', yang_name="paas-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """paas_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_paas_configuration_vnfd__vnfd_catalog_vnfd_paas_paas_configuration, is_container='container', yang_name="paas-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__paas_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_paas_configuration(self):
    self.__paas_configuration = YANGDynClass(base=yc_paas_configuration_vnfd__vnfd_catalog_vnfd_paas_paas_configuration, is_container='container', yang_name="paas-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_helm_chart(self):
    """
    Getter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/paas/helm_chart (string)

    YANG Description: Helm chart that models the PaaS, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder under paas_models folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under k8s_models folder in the package>
- <URL_where_to_fetch_chart>

    """
    return self.__helm_chart
      
  def _set_helm_chart(self, v, load=False):
    """
    Setter method for helm_chart, mapped from YANG variable /vnfd_catalog/vnfd/paas/helm_chart (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_chart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_chart() directly.

    YANG Description: Helm chart that models the PaaS, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder under paas_models folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under k8s_models folder in the package>
- <URL_where_to_fetch_chart>

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'paas-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helm_chart must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'paas-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__helm_chart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helm_chart(self):
    self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=(u'paas-model', u'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_juju_bundle(self):
    """
    Getter method for juju_bundle, mapped from YANG variable /vnfd_catalog/vnfd/paas/juju_bundle (string)

    YANG Description: Juju bundle that models the KDU, in any of the following ways:
- <juju-repo>/<juju-bundle>
- <juju-bundle folder under k8s_models folder in the package>
- <juju-bundle tgz file (w/ or w/o extension) under PaaS_models folder in the package>
- <URL_where_to_fetch_juju_bundle>

    """
    return self.__juju_bundle
      
  def _set_juju_bundle(self, v, load=False):
    """
    Setter method for juju_bundle, mapped from YANG variable /vnfd_catalog/vnfd/paas/juju_bundle (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju_bundle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju_bundle() directly.

    YANG Description: Juju bundle that models the KDU, in any of the following ways:
- <juju-repo>/<juju-bundle>
- <juju-bundle folder under k8s_models folder in the package>
- <juju-bundle tgz file (w/ or w/o extension) under PaaS_models folder in the package>
- <URL_where_to_fetch_juju_bundle>

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self, choice=(u'paas-model', u'juju-bundle'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """juju_bundle must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self, choice=(u'paas-model', u'juju-bundle'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__juju_bundle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_juju_bundle(self):
    self.__juju_bundle = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self, choice=(u'paas-model', u'juju-bundle'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_paas_requirements(self):
    """
    Getter method for paas_requirements, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_requirements (container)
    """
    return self.__paas_requirements
      
  def _set_paas_requirements(self, v, load=False):
    """
    Setter method for paas_requirements, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paas_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paas_requirements() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_paas_requirements_vnfd__vnfd_catalog_vnfd_paas_paas_requirements, is_container='container', yang_name="paas-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """paas_requirements must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_paas_requirements_vnfd__vnfd_catalog_vnfd_paas_paas_requirements, is_container='container', yang_name="paas-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__paas_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_paas_requirements(self):
    self.__paas_requirements = YANGDynClass(base=yc_paas_requirements_vnfd__vnfd_catalog_vnfd_paas_paas_requirements, is_container='container', yang_name="paas-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_paas_interfaces(self):
    """
    Getter method for paas_interfaces, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces (container)
    """
    return self.__paas_interfaces
      
  def _set_paas_interfaces(self, v, load=False):
    """
    Setter method for paas_interfaces, mapped from YANG variable /vnfd_catalog/vnfd/paas/paas_interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paas_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paas_interfaces() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_paas_interfaces_vnfd__vnfd_catalog_vnfd_paas_paas_interfaces, is_container='container', yang_name="paas-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """paas_interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_paas_interfaces_vnfd__vnfd_catalog_vnfd_paas_paas_interfaces, is_container='container', yang_name="paas-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__paas_interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_paas_interfaces(self):
    self.__paas_interfaces = YANGDynClass(base=yc_paas_interfaces_vnfd__vnfd_catalog_vnfd_paas_paas_interfaces, is_container='container', yang_name="paas-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_mgmt_interface(self):
    """
    Getter method for mgmt_interface, mapped from YANG variable /vnfd_catalog/vnfd/paas/mgmt_interface (container)

    YANG Description: Interface over which the PaaS is managed.
    """
    return self.__mgmt_interface
      
  def _set_mgmt_interface(self, v, load=False):
    """
    Setter method for mgmt_interface, mapped from YANG variable /vnfd_catalog/vnfd/paas/mgmt_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_interface() directly.

    YANG Description: Interface over which the PaaS is managed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_paas_mgmt_interface, is_container='container', yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_paas_mgmt_interface, is_container='container', yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__mgmt_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_interface(self):
    self.__mgmt_interface = YANGDynClass(base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_paas_mgmt_interface, is_container='container', yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  paas_configuration = __builtin__.property(_get_paas_configuration, _set_paas_configuration)
  helm_chart = __builtin__.property(_get_helm_chart, _set_helm_chart)
  juju_bundle = __builtin__.property(_get_juju_bundle, _set_juju_bundle)
  paas_requirements = __builtin__.property(_get_paas_requirements, _set_paas_requirements)
  paas_interfaces = __builtin__.property(_get_paas_interfaces, _set_paas_interfaces)
  mgmt_interface = __builtin__.property(_get_mgmt_interface, _set_mgmt_interface)

  __choices__ = {u'paas-model': {u'juju-bundle': [u'juju_bundle'], u'helm-chart': [u'helm_chart']}}
  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('description', description), ('paas_configuration', paas_configuration), ('helm_chart', helm_chart), ('juju_bundle', juju_bundle), ('paas_requirements', paas_requirements), ('paas_interfaces', paas_interfaces), ('mgmt_interface', mgmt_interface), ])


class yc_nets_vnfd__vnfd_catalog_vnfd_k8s_cluster_nets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/k8s-cluster/nets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of required networks in the K8s cluster.
The cluster where the KDUs will be deployed will have to use
one of these CNI plugins.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__external_connection_point_ref',)

  _yang_name = 'nets'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'k8s-cluster', u'nets']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster/nets/id (string)

    YANG Description: Internal identifier for the K8s cluster network in this VNF
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster/nets/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Internal identifier for the K8s cluster network in this VNF
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_external_connection_point_ref(self):
    """
    Getter method for external_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster/nets/external_connection_point_ref (leafref)

    YANG Description: Leaf Ref to the particular external connection point
    """
    return self.__external_connection_point_ref
      
  def _set_external_connection_point_ref(self, v, load=False):
    """
    Setter method for external_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster/nets/external_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_connection_point_ref() directly.

    YANG Description: Leaf Ref to the particular external connection point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external_connection_point_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__external_connection_point_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external_connection_point_ref(self):
    self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  external_connection_point_ref = __builtin__.property(_get_external_connection_point_ref, _set_external_connection_point_ref)


  _pyangbind_elements = OrderedDict([('id', id), ('external_connection_point_ref', external_connection_point_ref), ])


class yc_k8s_cluster_vnfd__vnfd_catalog_vnfd_k8s_cluster(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/k8s-cluster. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__version','__cni','__nets',)

  _yang_name = 'k8s-cluster'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__version = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__nets = YANGDynClass(base=YANGListType("id",yc_nets_vnfd__vnfd_catalog_vnfd_k8s_cluster_nets, yang_name="nets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__cni = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'multus': {}, u'calico': {}, u'flannel': {}},)), is_leaf=False, yang_name="cni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'k8s-cluster']

  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster/version (string)

    YANG Description: List of supported K8s versions.
The cluster where the KDUs will be deployed will have to match
one of these versions.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: List of supported K8s versions.
The cluster where the KDUs will be deployed will have to match
one of these versions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_cni(self):
    """
    Getter method for cni, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster/cni (enumeration)

    YANG Description: List of supported CNI plugins.
The cluster where the KDUs will be deployed will have to use
one of these CNI plugins.
    """
    return self.__cni
      
  def _set_cni(self, v, load=False):
    """
    Setter method for cni, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster/cni (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cni is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cni() directly.

    YANG Description: List of supported CNI plugins.
The cluster where the KDUs will be deployed will have to use
one of these CNI plugins.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'multus': {}, u'calico': {}, u'flannel': {}},)), is_leaf=False, yang_name="cni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cni must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'multus': {}, u'calico': {}, u'flannel': {}},)), is_leaf=False, yang_name="cni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__cni = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cni(self):
    self.__cni = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'multus': {}, u'calico': {}, u'flannel': {}},)), is_leaf=False, yang_name="cni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_nets(self):
    """
    Getter method for nets, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster/nets (list)

    YANG Description: List of required networks in the K8s cluster.
The cluster where the KDUs will be deployed will have to use
one of these CNI plugins.
    """
    return self.__nets
      
  def _set_nets(self, v, load=False):
    """
    Setter method for nets, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster/nets (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nets() directly.

    YANG Description: List of required networks in the K8s cluster.
The cluster where the KDUs will be deployed will have to use
one of these CNI plugins.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_nets_vnfd__vnfd_catalog_vnfd_k8s_cluster_nets, yang_name="nets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nets must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_nets_vnfd__vnfd_catalog_vnfd_k8s_cluster_nets, yang_name="nets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__nets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nets(self):
    self.__nets = YANGDynClass(base=YANGListType("id",yc_nets_vnfd__vnfd_catalog_vnfd_k8s_cluster_nets, yang_name="nets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  version = __builtin__.property(_get_version, _set_version)
  cni = __builtin__.property(_get_cni, _set_cni)
  nets = __builtin__.property(_get_nets, _set_nets)


  _pyangbind_elements = OrderedDict([('version', version), ('cni', cni), ('nets', nets), ])


class yc_vdu_dependency_vnfd__vnfd_catalog_vnfd_vdu_dependency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu-dependency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VDU dependencies.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vdu_source_ref','__vdu_depends_on_ref',)

  _yang_name = 'vdu-dependency'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vdu_depends_on_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-depends-on-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__vdu_source_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-source-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'vdu-dependency']

  def _get_vdu_source_ref(self):
    """
    Getter method for vdu_source_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency/vdu_source_ref (leafref)
    """
    return self.__vdu_source_ref
      
  def _set_vdu_source_ref(self, v, load=False):
    """
    Setter method for vdu_source_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency/vdu_source_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_source_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_source_ref() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vdu-source-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_source_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-source-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vdu_source_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_source_ref(self):
    self.__vdu_source_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-source-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_vdu_depends_on_ref(self):
    """
    Getter method for vdu_depends_on_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency/vdu_depends_on_ref (leafref)

    YANG Description: Reference to the VDU on which
the source VDU depends.
    """
    return self.__vdu_depends_on_ref
      
  def _set_vdu_depends_on_ref(self, v, load=False):
    """
    Setter method for vdu_depends_on_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency/vdu_depends_on_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_depends_on_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_depends_on_ref() directly.

    YANG Description: Reference to the VDU on which
the source VDU depends.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vdu-depends-on-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_depends_on_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-depends-on-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vdu_depends_on_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_depends_on_ref(self):
    self.__vdu_depends_on_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-depends-on-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  vdu_source_ref = __builtin__.property(_get_vdu_source_ref, _set_vdu_source_ref)
  vdu_depends_on_ref = __builtin__.property(_get_vdu_depends_on_ref, _set_vdu_depends_on_ref)


  _pyangbind_elements = OrderedDict([('vdu_source_ref', vdu_source_ref), ('vdu_depends_on_ref', vdu_depends_on_ref), ])


class yc_headers_vnfd__vnfd_catalog_vnfd_http_endpoint_headers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/http-endpoint/headers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Custom HTTP headers to put on HTTP request
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'headers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'http-endpoint', u'headers']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers/key (string)

    YANG Description: HTTP header key
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: HTTP header key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers/value (string)

    YANG Description: HTTP header value
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: HTTP header value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_http_endpoint_vnfd__vnfd_catalog_vnfd_http_endpoint(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/http-endpoint. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of http endpoints to be used by monitoring params
  """
  __slots__ = ('_path_helper', '_extmethods', '__path','__https','__port','__username','__password','__polling_interval_secs','__method','__headers',)

  _yang_name = 'http-endpoint'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__polling_interval_secs = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="polling-interval-secs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    self.__method = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GET': {}, u'PATCH': {}, u'PUT': {}, u'POST': {}, u'OPTIONS': {}, u'DELETE': {}},), default=six.text_type("GET"), is_leaf=True, yang_name="method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:http-method', is_config=True)
    self.__headers = YANGDynClass(base=YANGListType("key",yc_headers_vnfd__vnfd_catalog_vnfd_http_endpoint_headers, yang_name="headers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="headers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__https = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="https", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'http-endpoint']

  def _get_path(self):
    """
    Getter method for path, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/path (string)

    YANG Description: The HTTP path on the management server
    """
    return self.__path
      
  def _set_path(self, v, load=False):
    """
    Setter method for path, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path() directly.

    YANG Description: The HTTP path on the management server
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path(self):
    self.__path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_https(self):
    """
    Getter method for https, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/https (boolean)

    YANG Description: Pick HTTPS instead of HTTP , Default is false
    """
    return self.__https
      
  def _set_https(self, v, load=False):
    """
    Setter method for https, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/https (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_https is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_https() directly.

    YANG Description: Pick HTTPS instead of HTTP , Default is false
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="https", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """https must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="https", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__https = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_https(self):
    self.__https = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="https", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/port (inet:port-number)

    YANG Description: The HTTP port to connect to
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: The HTTP port to connect to
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)


  def _get_username(self):
    """
    Getter method for username, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/username (string)

    YANG Description: The HTTP basic auth username
    """
    return self.__username
      
  def _set_username(self, v, load=False):
    """
    Setter method for username, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/username (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_username() directly.

    YANG Description: The HTTP basic auth username
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """username must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__username = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_username(self):
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_password(self):
    """
    Getter method for password, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/password (string)

    YANG Description: The HTTP basic auth password
    """
    return self.__password
      
  def _set_password(self, v, load=False):
    """
    Setter method for password, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password() directly.

    YANG Description: The HTTP basic auth password
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password(self):
    self.__password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_polling_interval_secs(self):
    """
    Getter method for polling_interval_secs, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/polling_interval_secs (uint8)

    YANG Description: The HTTP polling interval in seconds
    """
    return self.__polling_interval_secs
      
  def _set_polling_interval_secs(self, v, load=False):
    """
    Setter method for polling_interval_secs, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/polling_interval_secs (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polling_interval_secs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polling_interval_secs() directly.

    YANG Description: The HTTP polling interval in seconds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="polling-interval-secs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polling_interval_secs must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="polling-interval-secs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""",
        })

    self.__polling_interval_secs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polling_interval_secs(self):
    self.__polling_interval_secs = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="polling-interval-secs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)


  def _get_method(self):
    """
    Getter method for method, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/method (manotypes:http-method)

    YANG Description: Method that the URI should perform.
Deafult action is GET.
    """
    return self.__method
      
  def _set_method(self, v, load=False):
    """
    Setter method for method, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/method (manotypes:http-method)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_method() directly.

    YANG Description: Method that the URI should perform.
Deafult action is GET.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GET': {}, u'PATCH': {}, u'PUT': {}, u'POST': {}, u'OPTIONS': {}, u'DELETE': {}},), default=six.text_type("GET"), is_leaf=True, yang_name="method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:http-method', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """method must be of a type compatible with manotypes:http-method""",
          'defined-type': "manotypes:http-method",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GET': {}, u'PATCH': {}, u'PUT': {}, u'POST': {}, u'OPTIONS': {}, u'DELETE': {}},), default=six.text_type("GET"), is_leaf=True, yang_name="method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:http-method', is_config=True)""",
        })

    self.__method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_method(self):
    self.__method = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GET': {}, u'PATCH': {}, u'PUT': {}, u'POST': {}, u'OPTIONS': {}, u'DELETE': {}},), default=six.text_type("GET"), is_leaf=True, yang_name="method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:http-method', is_config=True)


  def _get_headers(self):
    """
    Getter method for headers, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers (list)

    YANG Description: Custom HTTP headers to put on HTTP request
    """
    return self.__headers
      
  def _set_headers(self, v, load=False):
    """
    Setter method for headers, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_headers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_headers() directly.

    YANG Description: Custom HTTP headers to put on HTTP request
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_headers_vnfd__vnfd_catalog_vnfd_http_endpoint_headers, yang_name="headers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="headers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """headers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_headers_vnfd__vnfd_catalog_vnfd_http_endpoint_headers, yang_name="headers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="headers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__headers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_headers(self):
    self.__headers = YANGDynClass(base=YANGListType("key",yc_headers_vnfd__vnfd_catalog_vnfd_http_endpoint_headers, yang_name="headers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="headers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  path = __builtin__.property(_get_path, _set_path)
  https = __builtin__.property(_get_https, _set_https)
  port = __builtin__.property(_get_port, _set_port)
  username = __builtin__.property(_get_username, _set_username)
  password = __builtin__.property(_get_password, _set_password)
  polling_interval_secs = __builtin__.property(_get_polling_interval_secs, _set_polling_interval_secs)
  method = __builtin__.property(_get_method, _set_method)
  headers = __builtin__.property(_get_headers, _set_headers)


  _pyangbind_elements = OrderedDict([('path', path), ('https', https), ('port', port), ('username', username), ('password', password), ('polling_interval_secs', polling_interval_secs), ('method', method), ('headers', headers), ])


class yc_scaling_criteria_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy_scaling_criteria(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/scaling-group-descriptor/scaling-policy/scaling-criteria. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: list of conditions to be met for generating scaling
  requests
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__scale_in_threshold','__scale_in_relational_operation','__scale_out_threshold','__scale_out_relational_operation','__vnf_monitoring_param_ref',)

  _yang_name = 'scaling-criteria'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__scale_out_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)
    self.__vnf_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__scale_in_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)
    self.__scale_out_relational_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:relational-operation-type', is_config=True)
    self.__scale_in_relational_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:relational-operation-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'scaling-group-descriptor', u'scaling-policy', u'scaling-criteria']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_scale_in_threshold(self):
    """
    Getter method for scale_in_threshold, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_threshold (decimal64)

    YANG Description: Value below which scale-in requests are generated
    """
    return self.__scale_in_threshold
      
  def _set_scale_in_threshold(self, v, load=False):
    """
    Setter method for scale_in_threshold, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_threshold() directly.

    YANG Description: Value below which scale-in requests are generated
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_in_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)""",
        })

    self.__scale_in_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_in_threshold(self):
    self.__scale_in_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)


  def _get_scale_in_relational_operation(self):
    """
    Getter method for scale_in_relational_operation, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_relational_operation (manotypes:relational-operation-type)

    YANG Description: The relational operator used to compare the monitoring param
against the scale-in-threshold.
    """
    return self.__scale_in_relational_operation
      
  def _set_scale_in_relational_operation(self, v, load=False):
    """
    Setter method for scale_in_relational_operation, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_relational_operation (manotypes:relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_relational_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_relational_operation() directly.

    YANG Description: The relational operator used to compare the monitoring param
against the scale-in-threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:relational-operation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_in_relational_operation must be of a type compatible with manotypes:relational-operation-type""",
          'defined-type': "manotypes:relational-operation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:relational-operation-type', is_config=True)""",
        })

    self.__scale_in_relational_operation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_in_relational_operation(self):
    self.__scale_in_relational_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:relational-operation-type', is_config=True)


  def _get_scale_out_threshold(self):
    """
    Getter method for scale_out_threshold, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_threshold (decimal64)

    YANG Description: Value above which scale-out requests are generated
    """
    return self.__scale_out_threshold
      
  def _set_scale_out_threshold(self, v, load=False):
    """
    Setter method for scale_out_threshold, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_threshold() directly.

    YANG Description: Value above which scale-out requests are generated
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_out_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)""",
        })

    self.__scale_out_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_out_threshold(self):
    self.__scale_out_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)


  def _get_scale_out_relational_operation(self):
    """
    Getter method for scale_out_relational_operation, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_relational_operation (manotypes:relational-operation-type)

    YANG Description: The relational operator used to compare the monitoring param
against the scale-out-threshold.
    """
    return self.__scale_out_relational_operation
      
  def _set_scale_out_relational_operation(self, v, load=False):
    """
    Setter method for scale_out_relational_operation, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_relational_operation (manotypes:relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_relational_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_relational_operation() directly.

    YANG Description: The relational operator used to compare the monitoring param
against the scale-out-threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:relational-operation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_out_relational_operation must be of a type compatible with manotypes:relational-operation-type""",
          'defined-type': "manotypes:relational-operation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:relational-operation-type', is_config=True)""",
        })

    self.__scale_out_relational_operation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_out_relational_operation(self):
    self.__scale_out_relational_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:relational-operation-type', is_config=True)


  def _get_vnf_monitoring_param_ref(self):
    """
    Getter method for vnf_monitoring_param_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/vnf_monitoring_param_ref (leafref)

    YANG Description: Reference to the VNF level monitoring parameter
that is aggregated
    """
    return self.__vnf_monitoring_param_ref
      
  def _set_vnf_monitoring_param_ref(self, v, load=False):
    """
    Setter method for vnf_monitoring_param_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/vnf_monitoring_param_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_monitoring_param_ref() directly.

    YANG Description: Reference to the VNF level monitoring parameter
that is aggregated
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_monitoring_param_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vnf_monitoring_param_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_monitoring_param_ref(self):
    self.__vnf_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  scale_in_threshold = __builtin__.property(_get_scale_in_threshold, _set_scale_in_threshold)
  scale_in_relational_operation = __builtin__.property(_get_scale_in_relational_operation, _set_scale_in_relational_operation)
  scale_out_threshold = __builtin__.property(_get_scale_out_threshold, _set_scale_out_threshold)
  scale_out_relational_operation = __builtin__.property(_get_scale_out_relational_operation, _set_scale_out_relational_operation)
  vnf_monitoring_param_ref = __builtin__.property(_get_vnf_monitoring_param_ref, _set_vnf_monitoring_param_ref)


  _pyangbind_elements = OrderedDict([('name', name), ('scale_in_threshold', scale_in_threshold), ('scale_in_relational_operation', scale_in_relational_operation), ('scale_out_threshold', scale_out_threshold), ('scale_out_relational_operation', scale_out_relational_operation), ('vnf_monitoring_param_ref', vnf_monitoring_param_ref), ])


class yc_scaling_policy_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/scaling-group-descriptor/scaling-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__scaling_type','__enabled','__scale_in_operation_type','__scale_out_operation_type','__threshold_time','__cooldown_time','__scaling_criteria',)

  _yang_name = 'scaling-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__scale_out_operation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-criteria-operation', is_config=True)
    self.__scale_in_operation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-criteria-operation', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    self.__cooldown_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    self.__scaling_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'automatic': {u'value': 2}, u'manual': {u'value': 1}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-policy-type', is_config=True)
    self.__threshold_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    self.__scaling_criteria = YANGDynClass(base=YANGListType("name",yc_scaling_criteria_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'scaling-group-descriptor', u'scaling-policy']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/name (string)

    YANG Description: Name of the scaling policy
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the scaling policy
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_scaling_type(self):
    """
    Getter method for scaling_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_type (manotypes:scaling-policy-type)

    YANG Description: Type of scaling
    """
    return self.__scaling_type
      
  def _set_scaling_type(self, v, load=False):
    """
    Setter method for scaling_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_type (manotypes:scaling-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_type() directly.

    YANG Description: Type of scaling
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'automatic': {u'value': 2}, u'manual': {u'value': 1}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scaling_type must be of a type compatible with manotypes:scaling-policy-type""",
          'defined-type': "manotypes:scaling-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'automatic': {u'value': 2}, u'manual': {u'value': 1}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-policy-type', is_config=True)""",
        })

    self.__scaling_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scaling_type(self):
    self.__scaling_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'automatic': {u'value': 2}, u'manual': {u'value': 1}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-policy-type', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/enabled (boolean)

    YANG Description: Specifies if the scaling policy can be applied
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Specifies if the scaling policy can be applied
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)


  def _get_scale_in_operation_type(self):
    """
    Getter method for scale_in_operation_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scale_in_operation_type (manotypes:scaling-criteria-operation)

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale in threshold condition has been met.
Defaults to AND
    """
    return self.__scale_in_operation_type
      
  def _set_scale_in_operation_type(self, v, load=False):
    """
    Setter method for scale_in_operation_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scale_in_operation_type (manotypes:scaling-criteria-operation)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_operation_type() directly.

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale in threshold condition has been met.
Defaults to AND
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-criteria-operation', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_in_operation_type must be of a type compatible with manotypes:scaling-criteria-operation""",
          'defined-type': "manotypes:scaling-criteria-operation",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-criteria-operation', is_config=True)""",
        })

    self.__scale_in_operation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_in_operation_type(self):
    self.__scale_in_operation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-criteria-operation', is_config=True)


  def _get_scale_out_operation_type(self):
    """
    Getter method for scale_out_operation_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scale_out_operation_type (manotypes:scaling-criteria-operation)

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale out threshold condition has been met.
Defauls to OR
    """
    return self.__scale_out_operation_type
      
  def _set_scale_out_operation_type(self, v, load=False):
    """
    Setter method for scale_out_operation_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scale_out_operation_type (manotypes:scaling-criteria-operation)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_operation_type() directly.

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale out threshold condition has been met.
Defauls to OR
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-criteria-operation', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scale_out_operation_type must be of a type compatible with manotypes:scaling-criteria-operation""",
          'defined-type': "manotypes:scaling-criteria-operation",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-criteria-operation', is_config=True)""",
        })

    self.__scale_out_operation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scale_out_operation_type(self):
    self.__scale_out_operation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {u'value': 1}, u'OR': {u'value': 2}},), default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-criteria-operation', is_config=True)


  def _get_threshold_time(self):
    """
    Getter method for threshold_time, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/threshold_time (uint32)

    YANG Description: The duration for which the criteria must hold true
    """
    return self.__threshold_time
      
  def _set_threshold_time(self, v, load=False):
    """
    Setter method for threshold_time, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/threshold_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_time() directly.

    YANG Description: The duration for which the criteria must hold true
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""",
        })

    self.__threshold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_time(self):
    self.__threshold_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)


  def _get_cooldown_time(self):
    """
    Getter method for cooldown_time, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/cooldown_time (uint32)

    YANG Description: The duration after a scaling-in/scaling-out action has been
triggered, for which there will be no further optional
    """
    return self.__cooldown_time
      
  def _set_cooldown_time(self, v, load=False):
    """
    Setter method for cooldown_time, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/cooldown_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cooldown_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cooldown_time() directly.

    YANG Description: The duration after a scaling-in/scaling-out action has been
triggered, for which there will be no further optional
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cooldown_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""",
        })

    self.__cooldown_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cooldown_time(self):
    self.__cooldown_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)


  def _get_scaling_criteria(self):
    """
    Getter method for scaling_criteria, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria (list)

    YANG Description: list of conditions to be met for generating scaling
  requests
    """
    return self.__scaling_criteria
      
  def _set_scaling_criteria(self, v, load=False):
    """
    Setter method for scaling_criteria, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_criteria is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_criteria() directly.

    YANG Description: list of conditions to be met for generating scaling
  requests
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_scaling_criteria_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scaling_criteria must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_criteria_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__scaling_criteria = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scaling_criteria(self):
    self.__scaling_criteria = YANGDynClass(base=YANGListType("name",yc_scaling_criteria_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  scaling_type = __builtin__.property(_get_scaling_type, _set_scaling_type)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  scale_in_operation_type = __builtin__.property(_get_scale_in_operation_type, _set_scale_in_operation_type)
  scale_out_operation_type = __builtin__.property(_get_scale_out_operation_type, _set_scale_out_operation_type)
  threshold_time = __builtin__.property(_get_threshold_time, _set_threshold_time)
  cooldown_time = __builtin__.property(_get_cooldown_time, _set_cooldown_time)
  scaling_criteria = __builtin__.property(_get_scaling_criteria, _set_scaling_criteria)


  _pyangbind_elements = OrderedDict([('name', name), ('scaling_type', scaling_type), ('enabled', enabled), ('scale_in_operation_type', scale_in_operation_type), ('scale_out_operation_type', scale_out_operation_type), ('threshold_time', threshold_time), ('cooldown_time', cooldown_time), ('scaling_criteria', scaling_criteria), ])


class yc_vdu_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_vdu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/scaling-group-descriptor/vdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VDUs in this scaling group
  """
  __slots__ = ('_path_helper', '_extmethods', '__vdu_id_ref','__count',)

  _yang_name = 'vdu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    self.__vdu_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'scaling-group-descriptor', u'vdu']

  def _get_vdu_id_ref(self):
    """
    Getter method for vdu_id_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu/vdu_id_ref (leafref)

    YANG Description: Reference to the VDU id
    """
    return self.__vdu_id_ref
      
  def _set_vdu_id_ref(self, v, load=False):
    """
    Setter method for vdu_id_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu/vdu_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_id_ref() directly.

    YANG Description: Reference to the VDU id
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vdu-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_id_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vdu_id_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_id_ref(self):
    self.__vdu_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu/count (uint32)

    YANG Description: count of this VDU id within this scaling group.
The count allows to define the number of instances
when a scaling action targets this scaling group
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu/count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: count of this VDU id within this scaling group.
The count allows to define the number of instances
when a scaling action targets this scaling group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)

  vdu_id_ref = __builtin__.property(_get_vdu_id_ref, _set_vdu_id_ref)
  count = __builtin__.property(_get_count, _set_count)


  _pyangbind_elements = OrderedDict([('vdu_id_ref', vdu_id_ref), ('count', count), ])


class yc_scaling_config_action_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_config_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/scaling-group-descriptor/scaling-config-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of scaling config actions
  """
  __slots__ = ('_path_helper', '_extmethods', '__trigger','__vnf_config_primitive_name_ref',)

  _yang_name = 'scaling-config-action'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__trigger = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'pre-scale-out': {u'value': 3}, u'pre-scale-in': {u'value': 1}, u'post-scale-in': {u'value': 2}, u'post-scale-out': {u'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-trigger', is_config=True)
    self.__vnf_config_primitive_name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-config-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'scaling-group-descriptor', u'scaling-config-action']

  def _get_trigger(self):
    """
    Getter method for trigger, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action/trigger (manotypes:scaling-trigger)

    YANG Description: scaling trigger
    """
    return self.__trigger
      
  def _set_trigger(self, v, load=False):
    """
    Setter method for trigger, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action/trigger (manotypes:scaling-trigger)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trigger is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trigger() directly.

    YANG Description: scaling trigger
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'pre-scale-out': {u'value': 3}, u'pre-scale-in': {u'value': 1}, u'post-scale-in': {u'value': 2}, u'post-scale-out': {u'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-trigger', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trigger must be of a type compatible with manotypes:scaling-trigger""",
          'defined-type': "manotypes:scaling-trigger",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'pre-scale-out': {u'value': 3}, u'pre-scale-in': {u'value': 1}, u'post-scale-in': {u'value': 2}, u'post-scale-out': {u'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-trigger', is_config=True)""",
        })

    self.__trigger = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trigger(self):
    self.__trigger = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'pre-scale-out': {u'value': 3}, u'pre-scale-in': {u'value': 1}, u'post-scale-in': {u'value': 2}, u'post-scale-out': {u'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-trigger', is_config=True)


  def _get_vnf_config_primitive_name_ref(self):
    """
    Getter method for vnf_config_primitive_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action/vnf_config_primitive_name_ref (leafref)

    YANG Description: Reference to the VNF config primitive
    """
    return self.__vnf_config_primitive_name_ref
      
  def _set_vnf_config_primitive_name_ref(self, v, load=False):
    """
    Setter method for vnf_config_primitive_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action/vnf_config_primitive_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_config_primitive_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_config_primitive_name_ref() directly.

    YANG Description: Reference to the VNF config primitive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnf-config-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_config_primitive_name_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-config-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vnf_config_primitive_name_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_config_primitive_name_ref(self):
    self.__vnf_config_primitive_name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-config-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  trigger = __builtin__.property(_get_trigger, _set_trigger)
  vnf_config_primitive_name_ref = __builtin__.property(_get_vnf_config_primitive_name_ref, _set_vnf_config_primitive_name_ref)


  _pyangbind_elements = OrderedDict([('trigger', trigger), ('vnf_config_primitive_name_ref', vnf_config_primitive_name_ref), ])


class yc_scaling_group_descriptor_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/scaling-group-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: scaling group descriptor within the VNF.
The scaling group defines a group of VDUs,
and the ratio of VDUs in the VNF
that is used as target for scaling action
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__scaling_policy','__vdu','__min_instance_count','__max_instance_count','__scaling_config_action',)

  _yang_name = 'scaling-group-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vdu = YANGDynClass(base=YANGListType("vdu_id_ref",yc_vdu_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-id-ref', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__max_instance_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="max-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    self.__min_instance_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="min-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    self.__scaling_policy = YANGDynClass(base=YANGListType("name",yc_scaling_policy_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__scaling_config_action = YANGDynClass(base=YANGListType("trigger",yc_scaling_config_action_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'scaling-group-descriptor']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/name (string)

    YANG Description: Name of this scaling group.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of this scaling group.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_scaling_policy(self):
    """
    Getter method for scaling_policy, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy (list)
    """
    return self.__scaling_policy
      
  def _set_scaling_policy(self, v, load=False):
    """
    Setter method for scaling_policy, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_policy() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_scaling_policy_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scaling_policy must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_policy_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__scaling_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scaling_policy(self):
    self.__scaling_policy = YANGDynClass(base=YANGListType("name",yc_scaling_policy_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_vdu(self):
    """
    Getter method for vdu, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu (list)

    YANG Description: List of VDUs in this scaling group
    """
    return self.__vdu
      
  def _set_vdu(self, v, load=False):
    """
    Setter method for vdu, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu() directly.

    YANG Description: List of VDUs in this scaling group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vdu_id_ref",yc_vdu_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-id-ref', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vdu_id_ref",yc_vdu_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-id-ref', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__vdu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu(self):
    self.__vdu = YANGDynClass(base=YANGListType("vdu_id_ref",yc_vdu_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-id-ref', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_min_instance_count(self):
    """
    Getter method for min_instance_count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/min_instance_count (uint32)

    YANG Description: Minimum instances of the scaling group which are allowed.
These instances are created by default when the network service
is instantiated.
    """
    return self.__min_instance_count
      
  def _set_min_instance_count(self, v, load=False):
    """
    Setter method for min_instance_count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/min_instance_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_instance_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_instance_count() directly.

    YANG Description: Minimum instances of the scaling group which are allowed.
These instances are created by default when the network service
is instantiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="min-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_instance_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="min-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""",
        })

    self.__min_instance_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_instance_count(self):
    self.__min_instance_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="min-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)


  def _get_max_instance_count(self):
    """
    Getter method for max_instance_count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/max_instance_count (uint32)

    YANG Description: Maximum instances of this scaling group that are allowed
in a single network service. The network service scaling
will fail, when the number of service group instances
exceed the max-instance-count specified.
    """
    return self.__max_instance_count
      
  def _set_max_instance_count(self, v, load=False):
    """
    Setter method for max_instance_count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/max_instance_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_instance_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_instance_count() directly.

    YANG Description: Maximum instances of this scaling group that are allowed
in a single network service. The network service scaling
will fail, when the number of service group instances
exceed the max-instance-count specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="max-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_instance_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="max-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""",
        })

    self.__max_instance_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_instance_count(self):
    self.__max_instance_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="max-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)


  def _get_scaling_config_action(self):
    """
    Getter method for scaling_config_action, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action (list)

    YANG Description: List of scaling config actions
    """
    return self.__scaling_config_action
      
  def _set_scaling_config_action(self, v, load=False):
    """
    Setter method for scaling_config_action, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_config_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_config_action() directly.

    YANG Description: List of scaling config actions
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("trigger",yc_scaling_config_action_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scaling_config_action must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("trigger",yc_scaling_config_action_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__scaling_config_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scaling_config_action(self):
    self.__scaling_config_action = YANGDynClass(base=YANGListType("trigger",yc_scaling_config_action_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  scaling_policy = __builtin__.property(_get_scaling_policy, _set_scaling_policy)
  vdu = __builtin__.property(_get_vdu, _set_vdu)
  min_instance_count = __builtin__.property(_get_min_instance_count, _set_min_instance_count)
  max_instance_count = __builtin__.property(_get_max_instance_count, _set_max_instance_count)
  scaling_config_action = __builtin__.property(_get_scaling_config_action, _set_scaling_config_action)


  _pyangbind_elements = OrderedDict([('name', name), ('scaling_policy', scaling_policy), ('vdu', vdu), ('min_instance_count', min_instance_count), ('max_instance_count', max_instance_count), ('scaling_config_action', scaling_config_action), ])


class yc_vdu_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_monitoring_param(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/vdu-monitoring-param. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vdu_ref','__vdu_monitoring_param_ref',)

  _yang_name = 'vdu-monitoring-param'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vdu_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-monitoring-param-ref", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__vdu_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-ref", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'monitoring-param', u'vdu-monitoring-param']

  def _get_vdu_ref(self):
    """
    Getter method for vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param/vdu_ref (leafref)
    """
    return self.__vdu_ref
      
  def _set_vdu_ref(self, v, load=False):
    """
    Setter method for vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param/vdu_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vdu-ref", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-ref", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vdu_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_ref(self):
    self.__vdu_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-ref", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_vdu_monitoring_param_ref(self):
    """
    Getter method for vdu_monitoring_param_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param/vdu_monitoring_param_ref (leafref)
    """
    return self.__vdu_monitoring_param_ref
      
  def _set_vdu_monitoring_param_ref(self, v, load=False):
    """
    Setter method for vdu_monitoring_param_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param/vdu_monitoring_param_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_monitoring_param_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vdu-monitoring-param-ref", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_monitoring_param_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-monitoring-param-ref", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vdu_monitoring_param_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_monitoring_param_ref(self):
    self.__vdu_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-monitoring-param-ref", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  vdu_ref = __builtin__.property(_get_vdu_ref, _set_vdu_ref)
  vdu_monitoring_param_ref = __builtin__.property(_get_vdu_monitoring_param_ref, _set_vdu_monitoring_param_ref)

  __choices__ = {u'monitoring-type': {u'vdu-monitoring-param': [u'vdu_ref', u'vdu_monitoring_param_ref']}}
  _pyangbind_elements = OrderedDict([('vdu_ref', vdu_ref), ('vdu_monitoring_param_ref', vdu_monitoring_param_ref), ])


class yc_vnf_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vnf_metric(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/vnf-metric. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vnf_metric_name_ref',)

  _yang_name = 'vnf-metric'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnf_metric_name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-metric-name-ref", parent=self, choice=(u'monitoring-type', u'vnf-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'monitoring-param', u'vnf-metric']

  def _get_vnf_metric_name_ref(self):
    """
    Getter method for vnf_metric_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vnf_metric/vnf_metric_name_ref (leafref)
    """
    return self.__vnf_metric_name_ref
      
  def _set_vnf_metric_name_ref(self, v, load=False):
    """
    Setter method for vnf_metric_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vnf_metric/vnf_metric_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_metric_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_metric_name_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vnf-metric-name-ref", parent=self, choice=(u'monitoring-type', u'vnf-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_metric_name_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-metric-name-ref", parent=self, choice=(u'monitoring-type', u'vnf-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vnf_metric_name_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_metric_name_ref(self):
    self.__vnf_metric_name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-metric-name-ref", parent=self, choice=(u'monitoring-type', u'vnf-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  vnf_metric_name_ref = __builtin__.property(_get_vnf_metric_name_ref, _set_vnf_metric_name_ref)

  __choices__ = {u'monitoring-type': {u'vnf-metric': [u'vnf_metric_name_ref']}}
  _pyangbind_elements = OrderedDict([('vnf_metric_name_ref', vnf_metric_name_ref), ])


class yc_vdu_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_metric(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/vdu-metric. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vdu_ref','__vdu_metric_name_ref',)

  _yang_name = 'vdu-metric'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vdu_metric_name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-metric-name-ref", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__vdu_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-ref", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'monitoring-param', u'vdu-metric']

  def _get_vdu_ref(self):
    """
    Getter method for vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric/vdu_ref (leafref)
    """
    return self.__vdu_ref
      
  def _set_vdu_ref(self, v, load=False):
    """
    Setter method for vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric/vdu_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vdu-ref", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-ref", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vdu_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_ref(self):
    self.__vdu_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-ref", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_vdu_metric_name_ref(self):
    """
    Getter method for vdu_metric_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric/vdu_metric_name_ref (leafref)
    """
    return self.__vdu_metric_name_ref
      
  def _set_vdu_metric_name_ref(self, v, load=False):
    """
    Setter method for vdu_metric_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric/vdu_metric_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_metric_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_metric_name_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vdu-metric-name-ref", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_metric_name_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-metric-name-ref", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__vdu_metric_name_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_metric_name_ref(self):
    self.__vdu_metric_name_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-metric-name-ref", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  vdu_ref = __builtin__.property(_get_vdu_ref, _set_vdu_ref)
  vdu_metric_name_ref = __builtin__.property(_get_vdu_metric_name_ref, _set_vdu_metric_name_ref)

  __choices__ = {u'monitoring-type': {u'vdu-metric': [u'vdu_ref', u'vdu_metric_name_ref']}}
  _pyangbind_elements = OrderedDict([('vdu_ref', vdu_ref), ('vdu_metric_name_ref', vdu_metric_name_ref), ])


class yc_json_query_params_vnfd__vnfd_catalog_vnfd_monitoring_param_json_query_params(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/json-query-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__json_path','__object_path',)

  _yang_name = 'json-query-params'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__json_path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="json-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__object_path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="object-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'monitoring-param', u'json-query-params']

  def _get_json_path(self):
    """
    Getter method for json_path, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params/json_path (string)

    YANG Description: The jsonpath to use to extract value from JSON structure
    """
    return self.__json_path
      
  def _set_json_path(self, v, load=False):
    """
    Setter method for json_path, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params/json_path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_json_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_json_path() directly.

    YANG Description: The jsonpath to use to extract value from JSON structure
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="json-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """json_path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="json-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__json_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_json_path(self):
    self.__json_path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="json-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_object_path(self):
    """
    Getter method for object_path, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params/object_path (string)

    YANG Description: The objectpath to use to extract value from JSON structure
    """
    return self.__object_path
      
  def _set_object_path(self, v, load=False):
    """
    Setter method for object_path, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params/object_path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_object_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_object_path() directly.

    YANG Description: The objectpath to use to extract value from JSON structure
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="object-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """object_path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="object-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__object_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_object_path(self):
    self.__object_path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="object-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  json_path = __builtin__.property(_get_json_path, _set_json_path)
  object_path = __builtin__.property(_get_object_path, _set_object_path)


  _pyangbind_elements = OrderedDict([('json_path', json_path), ('object_path', object_path), ])


class yc_numeric_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_numeric_constraints(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/numeric-constraints. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__min_value','__max_value',)

  _yang_name = 'numeric-constraints'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    self.__min_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'monitoring-param', u'numeric-constraints']

  def _get_min_value(self):
    """
    Getter method for min_value, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints/min_value (uint64)

    YANG Description: Minimum value for the parameter
    """
    return self.__min_value
      
  def _set_min_value(self, v, load=False):
    """
    Setter method for min_value, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints/min_value (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_value() directly.

    YANG Description: Minimum value for the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_value must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__min_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_value(self):
    self.__min_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)


  def _get_max_value(self):
    """
    Getter method for max_value, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints/max_value (uint64)

    YANG Description: Maximum value for the parameter
    """
    return self.__max_value
      
  def _set_max_value(self, v, load=False):
    """
    Setter method for max_value, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints/max_value (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_value() directly.

    YANG Description: Maximum value for the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_value must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""",
        })

    self.__max_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_value(self):
    self.__max_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)

  min_value = __builtin__.property(_get_min_value, _set_min_value)
  max_value = __builtin__.property(_get_max_value, _set_max_value)


  _pyangbind_elements = OrderedDict([('min_value', min_value), ('max_value', max_value), ])


class yc_text_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_text_constraints(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/text-constraints. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__min_length','__max_length',)

  _yang_name = 'text-constraints'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__min_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    self.__max_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'monitoring-param', u'text-constraints']

  def _get_min_length(self):
    """
    Getter method for min_length, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints/min_length (uint8)

    YANG Description: Minimum string length for the parameter
    """
    return self.__min_length
      
  def _set_min_length(self, v, load=False):
    """
    Setter method for min_length, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints/min_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_length() directly.

    YANG Description: Minimum string length for the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""",
        })

    self.__min_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_length(self):
    self.__min_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)


  def _get_max_length(self):
    """
    Getter method for max_length, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints/max_length (uint8)

    YANG Description: Maximum string length for the parameter
    """
    return self.__max_length
      
  def _set_max_length(self, v, load=False):
    """
    Setter method for max_length, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints/max_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_length() directly.

    YANG Description: Maximum string length for the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""",
        })

    self.__max_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_length(self):
    self.__max_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)

  min_length = __builtin__.property(_get_min_length, _set_min_length)
  max_length = __builtin__.property(_get_max_length, _set_max_length)


  _pyangbind_elements = OrderedDict([('min_length', min_length), ('max_length', max_length), ])


class yc_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of monitoring parameters at the network service level
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__aggregation_type','__vdu_monitoring_param','__vnf_metric','__vdu_metric','__http_endpoint_ref','__json_query_method','__json_query_params','__description','__group_tag','__widget_type','__units','__value_type','__numeric_constraints','__text_constraints','__value_integer','__value_decimal','__value_string',)

  _yang_name = 'monitoring-param'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value_integer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="value-integer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='int64', is_config=True)
    self.__vdu_monitoring_param = YANGDynClass(base=yc_vdu_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_monitoring_param, is_container='container', yang_name="vdu-monitoring-param", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__aggregation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="aggregation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='aggregation-type', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__text_constraints = YANGDynClass(base=yc_text_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_text_constraints, is_container='container', yang_name="text-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__group_tag = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__value_string = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__widget_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'BAR': {}, u'COUNTER': {}, u'HISTOGRAM': {}, u'SLIDER': {}, u'GAUGE': {}, u'TEXTBOX': {}},), default=six.text_type("COUNTER"), is_leaf=True, yang_name="widget-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:widget-type', is_config=True)
    self.__units = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="units", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__http_endpoint_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="http-endpoint-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    self.__vdu_metric = YANGDynClass(base=yc_vdu_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_metric, is_container='container', yang_name="vdu-metric", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__json_query_params = YANGDynClass(base=yc_json_query_params_vnfd__vnfd_catalog_vnfd_monitoring_param_json_query_params, is_container='container', yang_name="json-query-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__value_decimal = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value-decimal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)
    self.__vnf_metric = YANGDynClass(base=yc_vnf_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vnf_metric, is_container='container', yang_name="vnf-metric", parent=self, choice=(u'monitoring-type', u'vnf-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__json_query_method = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NAMEKEY': {}, u'OBJECTPATH': {}, u'JSONPATH': {}},), default=six.text_type("NAMEKEY"), is_leaf=True, yang_name="json-query-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:json-query-method', is_config=True)
    self.__value_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INT': {}, u'DECIMAL': {}, u'STRING': {}},), default=six.text_type("INT"), is_leaf=True, yang_name="value-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='param-value-type', is_config=True)
    self.__numeric_constraints = YANGDynClass(base=yc_numeric_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_numeric_constraints, is_container='container', yang_name="numeric-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'monitoring-param']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_aggregation_type(self):
    """
    Getter method for aggregation_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/aggregation_type (aggregation-type)
    """
    return self.__aggregation_type
      
  def _set_aggregation_type(self, v, load=False):
    """
    Setter method for aggregation_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/aggregation_type (aggregation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregation_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="aggregation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='aggregation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregation_type must be of a type compatible with aggregation-type""",
          'defined-type': "vnfd:aggregation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="aggregation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='aggregation-type', is_config=True)""",
        })

    self.__aggregation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregation_type(self):
    self.__aggregation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="aggregation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='aggregation-type', is_config=True)


  def _get_vdu_monitoring_param(self):
    """
    Getter method for vdu_monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param (container)
    """
    return self.__vdu_monitoring_param
      
  def _set_vdu_monitoring_param(self, v, load=False):
    """
    Setter method for vdu_monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_monitoring_param is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_monitoring_param() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vdu_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_monitoring_param, is_container='container', yang_name="vdu-monitoring-param", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_monitoring_param must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vdu_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_monitoring_param, is_container='container', yang_name="vdu-monitoring-param", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__vdu_monitoring_param = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_monitoring_param(self):
    self.__vdu_monitoring_param = YANGDynClass(base=yc_vdu_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_monitoring_param, is_container='container', yang_name="vdu-monitoring-param", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_vnf_metric(self):
    """
    Getter method for vnf_metric, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vnf_metric (container)
    """
    return self.__vnf_metric
      
  def _set_vnf_metric(self, v, load=False):
    """
    Setter method for vnf_metric, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vnf_metric (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_metric() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vnf_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vnf_metric, is_container='container', yang_name="vnf-metric", parent=self, choice=(u'monitoring-type', u'vnf-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_metric must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vnf_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vnf_metric, is_container='container', yang_name="vnf-metric", parent=self, choice=(u'monitoring-type', u'vnf-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__vnf_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_metric(self):
    self.__vnf_metric = YANGDynClass(base=yc_vnf_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vnf_metric, is_container='container', yang_name="vnf-metric", parent=self, choice=(u'monitoring-type', u'vnf-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_vdu_metric(self):
    """
    Getter method for vdu_metric, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric (container)
    """
    return self.__vdu_metric
      
  def _set_vdu_metric(self, v, load=False):
    """
    Setter method for vdu_metric, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_metric() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vdu_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_metric, is_container='container', yang_name="vdu-metric", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_metric must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vdu_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_metric, is_container='container', yang_name="vdu-metric", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__vdu_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_metric(self):
    self.__vdu_metric = YANGDynClass(base=yc_vdu_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_metric, is_container='container', yang_name="vdu-metric", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_http_endpoint_ref(self):
    """
    Getter method for http_endpoint_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/http_endpoint_ref (leafref)
    """
    return self.__http_endpoint_ref
      
  def _set_http_endpoint_ref(self, v, load=False):
    """
    Setter method for http_endpoint_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/http_endpoint_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_http_endpoint_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_http_endpoint_ref() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="http-endpoint-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """http_endpoint_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="http-endpoint-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__http_endpoint_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_http_endpoint_ref(self):
    self.__http_endpoint_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="http-endpoint-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)


  def _get_json_query_method(self):
    """
    Getter method for json_query_method, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_method (manotypes:json-query-method)
    """
    return self.__json_query_method
      
  def _set_json_query_method(self, v, load=False):
    """
    Setter method for json_query_method, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_method (manotypes:json-query-method)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_json_query_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_json_query_method() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NAMEKEY': {}, u'OBJECTPATH': {}, u'JSONPATH': {}},), default=six.text_type("NAMEKEY"), is_leaf=True, yang_name="json-query-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:json-query-method', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """json_query_method must be of a type compatible with manotypes:json-query-method""",
          'defined-type': "manotypes:json-query-method",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NAMEKEY': {}, u'OBJECTPATH': {}, u'JSONPATH': {}},), default=six.text_type("NAMEKEY"), is_leaf=True, yang_name="json-query-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:json-query-method', is_config=True)""",
        })

    self.__json_query_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_json_query_method(self):
    self.__json_query_method = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NAMEKEY': {}, u'OBJECTPATH': {}, u'JSONPATH': {}},), default=six.text_type("NAMEKEY"), is_leaf=True, yang_name="json-query-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:json-query-method', is_config=True)


  def _get_json_query_params(self):
    """
    Getter method for json_query_params, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params (container)
    """
    return self.__json_query_params
      
  def _set_json_query_params(self, v, load=False):
    """
    Setter method for json_query_params, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_json_query_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_json_query_params() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_json_query_params_vnfd__vnfd_catalog_vnfd_monitoring_param_json_query_params, is_container='container', yang_name="json-query-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """json_query_params must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_json_query_params_vnfd__vnfd_catalog_vnfd_monitoring_param_json_query_params, is_container='container', yang_name="json-query-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__json_query_params = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_json_query_params(self):
    self.__json_query_params = YANGDynClass(base=yc_json_query_params_vnfd__vnfd_catalog_vnfd_monitoring_param_json_query_params, is_container='container', yang_name="json-query-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/description (string)
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_group_tag(self):
    """
    Getter method for group_tag, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/group_tag (string)

    YANG Description: A tag to group monitoring parameters
    """
    return self.__group_tag
      
  def _set_group_tag(self, v, load=False):
    """
    Setter method for group_tag, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/group_tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_tag() directly.

    YANG Description: A tag to group monitoring parameters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="group-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__group_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_tag(self):
    self.__group_tag = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_widget_type(self):
    """
    Getter method for widget_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/widget_type (manotypes:widget-type)

    YANG Description: Defines the UI Display variant of measured counters.
    """
    return self.__widget_type
      
  def _set_widget_type(self, v, load=False):
    """
    Setter method for widget_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/widget_type (manotypes:widget-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_widget_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_widget_type() directly.

    YANG Description: Defines the UI Display variant of measured counters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'BAR': {}, u'COUNTER': {}, u'HISTOGRAM': {}, u'SLIDER': {}, u'GAUGE': {}, u'TEXTBOX': {}},), default=six.text_type("COUNTER"), is_leaf=True, yang_name="widget-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:widget-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """widget_type must be of a type compatible with manotypes:widget-type""",
          'defined-type': "manotypes:widget-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'BAR': {}, u'COUNTER': {}, u'HISTOGRAM': {}, u'SLIDER': {}, u'GAUGE': {}, u'TEXTBOX': {}},), default=six.text_type("COUNTER"), is_leaf=True, yang_name="widget-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:widget-type', is_config=True)""",
        })

    self.__widget_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_widget_type(self):
    self.__widget_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'BAR': {}, u'COUNTER': {}, u'HISTOGRAM': {}, u'SLIDER': {}, u'GAUGE': {}, u'TEXTBOX': {}},), default=six.text_type("COUNTER"), is_leaf=True, yang_name="widget-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='manotypes:widget-type', is_config=True)


  def _get_units(self):
    """
    Getter method for units, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/units (string)

    YANG Description: Measured Counter Units (e.g., Packets, Kbps, Mbps, etc.)
    """
    return self.__units
      
  def _set_units(self, v, load=False):
    """
    Setter method for units, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/units (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_units is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_units() directly.

    YANG Description: Measured Counter Units (e.g., Packets, Kbps, Mbps, etc.)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="units", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """units must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="units", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__units = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_units(self):
    self.__units = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="units", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_value_type(self):
    """
    Getter method for value_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_type (param-value-type)
    """
    return self.__value_type
      
  def _set_value_type(self, v, load=False):
    """
    Setter method for value_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_type (param-value-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INT': {}, u'DECIMAL': {}, u'STRING': {}},), default=six.text_type("INT"), is_leaf=True, yang_name="value-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='param-value-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value_type must be of a type compatible with param-value-type""",
          'defined-type': "vnfd:param-value-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INT': {}, u'DECIMAL': {}, u'STRING': {}},), default=six.text_type("INT"), is_leaf=True, yang_name="value-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='param-value-type', is_config=True)""",
        })

    self.__value_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value_type(self):
    self.__value_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'INT': {}, u'DECIMAL': {}, u'STRING': {}},), default=six.text_type("INT"), is_leaf=True, yang_name="value-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='param-value-type', is_config=True)


  def _get_numeric_constraints(self):
    """
    Getter method for numeric_constraints, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints (container)
    """
    return self.__numeric_constraints
      
  def _set_numeric_constraints(self, v, load=False):
    """
    Setter method for numeric_constraints, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numeric_constraints is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numeric_constraints() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_numeric_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_numeric_constraints, is_container='container', yang_name="numeric-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numeric_constraints must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_numeric_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_numeric_constraints, is_container='container', yang_name="numeric-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__numeric_constraints = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numeric_constraints(self):
    self.__numeric_constraints = YANGDynClass(base=yc_numeric_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_numeric_constraints, is_container='container', yang_name="numeric-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_text_constraints(self):
    """
    Getter method for text_constraints, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints (container)
    """
    return self.__text_constraints
      
  def _set_text_constraints(self, v, load=False):
    """
    Setter method for text_constraints, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_text_constraints is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_text_constraints() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_text_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_text_constraints, is_container='container', yang_name="text-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """text_constraints must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_text_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_text_constraints, is_container='container', yang_name="text-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__text_constraints = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_text_constraints(self):
    self.__text_constraints = YANGDynClass(base=yc_text_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_text_constraints, is_container='container', yang_name="text-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_value_integer(self):
    """
    Getter method for value_integer, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_integer (int64)

    YANG Description: Current value for an integer parameter
    """
    return self.__value_integer
      
  def _set_value_integer(self, v, load=False):
    """
    Setter method for value_integer, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_integer (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_integer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_integer() directly.

    YANG Description: Current value for an integer parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="value-integer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='int64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value_integer must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="value-integer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='int64', is_config=True)""",
        })

    self.__value_integer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value_integer(self):
    self.__value_integer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="value-integer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='int64', is_config=True)


  def _get_value_decimal(self):
    """
    Getter method for value_decimal, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_decimal (decimal64)

    YANG Description: Current value for a decimal parameter
    """
    return self.__value_decimal
      
  def _set_value_decimal(self, v, load=False):
    """
    Setter method for value_decimal, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_decimal (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_decimal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_decimal() directly.

    YANG Description: Current value for a decimal parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value-decimal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value_decimal must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value-decimal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)""",
        })

    self.__value_decimal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value_decimal(self):
    self.__value_decimal = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value-decimal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)


  def _get_value_string(self):
    """
    Getter method for value_string, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_string (string)

    YANG Description: Current value for a string parameter
    """
    return self.__value_string
      
  def _set_value_string(self, v, load=False):
    """
    Setter method for value_string, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_string() directly.

    YANG Description: Current value for a string parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__value_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value_string(self):
    self.__value_string = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  aggregation_type = __builtin__.property(_get_aggregation_type, _set_aggregation_type)
  vdu_monitoring_param = __builtin__.property(_get_vdu_monitoring_param, _set_vdu_monitoring_param)
  vnf_metric = __builtin__.property(_get_vnf_metric, _set_vnf_metric)
  vdu_metric = __builtin__.property(_get_vdu_metric, _set_vdu_metric)
  http_endpoint_ref = __builtin__.property(_get_http_endpoint_ref, _set_http_endpoint_ref)
  json_query_method = __builtin__.property(_get_json_query_method, _set_json_query_method)
  json_query_params = __builtin__.property(_get_json_query_params, _set_json_query_params)
  description = __builtin__.property(_get_description, _set_description)
  group_tag = __builtin__.property(_get_group_tag, _set_group_tag)
  widget_type = __builtin__.property(_get_widget_type, _set_widget_type)
  units = __builtin__.property(_get_units, _set_units)
  value_type = __builtin__.property(_get_value_type, _set_value_type)
  numeric_constraints = __builtin__.property(_get_numeric_constraints, _set_numeric_constraints)
  text_constraints = __builtin__.property(_get_text_constraints, _set_text_constraints)
  value_integer = __builtin__.property(_get_value_integer, _set_value_integer)
  value_decimal = __builtin__.property(_get_value_decimal, _set_value_decimal)
  value_string = __builtin__.property(_get_value_string, _set_value_string)

  __choices__ = {u'monitoring-type': {u'vdu-monitoring-param': [u'vdu_monitoring_param'], u'vnf-metric': [u'vnf_metric'], u'vdu-metric': [u'vdu_metric']}}
  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('aggregation_type', aggregation_type), ('vdu_monitoring_param', vdu_monitoring_param), ('vnf_metric', vnf_metric), ('vdu_metric', vdu_metric), ('http_endpoint_ref', http_endpoint_ref), ('json_query_method', json_query_method), ('json_query_params', json_query_params), ('description', description), ('group_tag', group_tag), ('widget_type', widget_type), ('units', units), ('value_type', value_type), ('numeric_constraints', numeric_constraints), ('text_constraints', text_constraints), ('value_integer', value_integer), ('value_decimal', value_decimal), ('value_string', value_string), ])


class yc_member_vdus_vnfd__vnfd_catalog_vnfd_placement_groups_member_vdus(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/placement-groups/member-vdus. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VDUs that are part of this placement group
  """
  __slots__ = ('_path_helper', '_extmethods', '__member_vdu_ref',)

  _yang_name = 'member-vdus'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__member_vdu_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vdu-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'placement-groups', u'member-vdus']

  def _get_member_vdu_ref(self):
    """
    Getter method for member_vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/member_vdus/member_vdu_ref (leafref)
    """
    return self.__member_vdu_ref
      
  def _set_member_vdu_ref(self, v, load=False):
    """
    Setter method for member_vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/member_vdus/member_vdu_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vdu_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vdu_ref() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="member-vdu-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vdu_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vdu-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""",
        })

    self.__member_vdu_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vdu_ref(self):
    self.__member_vdu_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="member-vdu-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)

  member_vdu_ref = __builtin__.property(_get_member_vdu_ref, _set_member_vdu_ref)


  _pyangbind_elements = OrderedDict([('member_vdu_ref', member_vdu_ref), ])


class yc_placement_groups_vnfd__vnfd_catalog_vnfd_placement_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/placement-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of placement groups at VNF level
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__requirement','__strategy','__member_vdus',)

  _yang_name = 'placement-groups'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__member_vdus = YANGDynClass(base=YANGListType("member_vdu_ref",yc_member_vdus_vnfd__vnfd_catalog_vnfd_placement_groups_member_vdus, yang_name="member-vdus", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vdu-ref', extensions=None), is_container='list', yang_name="member-vdus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__requirement = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__strategy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COLOCATION': {}, u'ISOLATION': {}},), default=six.text_type("COLOCATION"), is_leaf=True, yang_name="strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd', u'placement-groups']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/name (string)

    YANG Description: Place group construct to define the compute resource placement strategy
in cloud environment
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Place group construct to define the compute resource placement strategy
in cloud environment
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_requirement(self):
    """
    Getter method for requirement, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/requirement (string)

    YANG Description: This is free text space used to describe the intent/rationale
behind this placement group. This is for human consumption only
    """
    return self.__requirement
      
  def _set_requirement(self, v, load=False):
    """
    Setter method for requirement, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/requirement (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requirement() directly.

    YANG Description: This is free text space used to describe the intent/rationale
behind this placement group. This is for human consumption only
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """requirement must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__requirement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_requirement(self):
    self.__requirement = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_strategy(self):
    """
    Getter method for strategy, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/strategy (enumeration)

    YANG Description: Strategy associated with this placement group
  Following values are possible
    - COLOCATION: Colocation strategy imply intent to share the physical
                  infrastructure (hypervisor/network) among all members
                  of this group.
    - ISOLATION: Isolation strategy imply intent to not share the physical
                 infrastructure (hypervisor/network) among the members
                 of this group.
  
    """
    return self.__strategy
      
  def _set_strategy(self, v, load=False):
    """
    Setter method for strategy, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/strategy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_strategy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_strategy() directly.

    YANG Description: Strategy associated with this placement group
  Following values are possible
    - COLOCATION: Colocation strategy imply intent to share the physical
                  infrastructure (hypervisor/network) among all members
                  of this group.
    - ISOLATION: Isolation strategy imply intent to not share the physical
                 infrastructure (hypervisor/network) among the members
                 of this group.
  
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COLOCATION': {}, u'ISOLATION': {}},), default=six.text_type("COLOCATION"), is_leaf=True, yang_name="strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """strategy must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COLOCATION': {}, u'ISOLATION': {}},), default=six.text_type("COLOCATION"), is_leaf=True, yang_name="strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__strategy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_strategy(self):
    self.__strategy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'COLOCATION': {}, u'ISOLATION': {}},), default=six.text_type("COLOCATION"), is_leaf=True, yang_name="strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_member_vdus(self):
    """
    Getter method for member_vdus, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/member_vdus (list)

    YANG Description: List of VDUs that are part of this placement group
    """
    return self.__member_vdus
      
  def _set_member_vdus(self, v, load=False):
    """
    Setter method for member_vdus, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/member_vdus (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vdus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vdus() directly.

    YANG Description: List of VDUs that are part of this placement group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("member_vdu_ref",yc_member_vdus_vnfd__vnfd_catalog_vnfd_placement_groups_member_vdus, yang_name="member-vdus", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vdu-ref', extensions=None), is_container='list', yang_name="member-vdus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_vdus must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("member_vdu_ref",yc_member_vdus_vnfd__vnfd_catalog_vnfd_placement_groups_member_vdus, yang_name="member-vdus", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vdu-ref', extensions=None), is_container='list', yang_name="member-vdus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__member_vdus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_vdus(self):
    self.__member_vdus = YANGDynClass(base=YANGListType("member_vdu_ref",yc_member_vdus_vnfd__vnfd_catalog_vnfd_placement_groups_member_vdus, yang_name="member-vdus", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vdu-ref', extensions=None), is_container='list', yang_name="member-vdus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  requirement = __builtin__.property(_get_requirement, _set_requirement)
  strategy = __builtin__.property(_get_strategy, _set_strategy)
  member_vdus = __builtin__.property(_get_member_vdus, _set_member_vdus)


  _pyangbind_elements = OrderedDict([('name', name), ('requirement', requirement), ('strategy', strategy), ('member_vdus', member_vdus), ])


class yc_vnfd_vnfd__vnfd_catalog_vnfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__short_name','__vendor','__logo','__description','__version','__vnf_configuration','__operational_status','__mgmt_interface','__internal_vld','__ip_profiles','__connection_point','__vdu','__kdu','__paas','__k8s_cluster','__vdu_dependency','__service_function_chain','__service_function_type','__http_endpoint','__scaling_group_descriptor','__monitoring_param','__placement_groups',)

  _yang_name = 'vnfd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__service_function_chain = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'SFF': {}, u'CLASSIFIER': {}, u'UNAWARE': {}, u'SF': {}},), default=six.text_type("UNAWARE"), is_leaf=True, yang_name="service-function-chain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    self.__vdu_dependency = YANGDynClass(base=YANGListType("vdu_source_ref",yc_vdu_dependency_vnfd__vnfd_catalog_vnfd_vdu_dependency, yang_name="vdu-dependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-source-ref', extensions=None), is_container='list', yang_name="vdu-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__kdu = YANGDynClass(base=YANGListType("name",yc_kdu_vnfd__vnfd_catalog_vnfd_kdu, yang_name="kdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="kdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__internal_vld = YANGDynClass(base=YANGListType("id",yc_internal_vld_vnfd__vnfd_catalog_vnfd_internal_vld, yang_name="internal-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__operational_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'terminated': {}, u'upgrading': {}, u'terminate': {}, u'running': {}, u'failed': {}, u'init': {}},), is_leaf=True, yang_name="operational-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='vnf-operational-status', is_config=True)
    self.__placement_groups = YANGDynClass(base=YANGListType("name",yc_placement_groups_vnfd__vnfd_catalog_vnfd_placement_groups, yang_name="placement-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="placement-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__http_endpoint = YANGDynClass(base=YANGListType("path",yc_http_endpoint_vnfd__vnfd_catalog_vnfd_http_endpoint, yang_name="http-endpoint", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path', extensions=None), is_container='list', yang_name="http-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__connection_point = YANGDynClass(base=YANGListType("name",yc_connection_point_vnfd__vnfd_catalog_vnfd_connection_point, yang_name="connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__service_function_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="service-function-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__k8s_cluster = YANGDynClass(base=yc_k8s_cluster_vnfd__vnfd_catalog_vnfd_k8s_cluster, is_container='container', yang_name="k8s-cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__ip_profiles = YANGDynClass(base=YANGListType("name",yc_ip_profiles_vnfd__vnfd_catalog_vnfd_ip_profiles, yang_name="ip-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ip-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__vnf_configuration = YANGDynClass(base=yc_vnf_configuration_vnfd__vnfd_catalog_vnfd_vnf_configuration, is_container='container', yang_name="vnf-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    self.__paas = YANGDynClass(base=YANGListType("id",yc_paas_vnfd__vnfd_catalog_vnfd_paas, yang_name="paas", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="paas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__vdu = YANGDynClass(base=YANGListType("id",yc_vdu_vnfd__vnfd_catalog_vnfd_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__scaling_group_descriptor = YANGDynClass(base=YANGListType("name",yc_scaling_group_descriptor_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor, yang_name="scaling-group-descriptor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-group-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__logo = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    self.__monitoring_param = YANGDynClass(base=YANGListType("id",yc_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__mgmt_interface = YANGDynClass(base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_mgmt_interface, is_container='container', yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog', u'vnfd']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/id (string)

    YANG Description: Identifier for the VNFD.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the VNFD.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/name (string)

    YANG Description: VNFD name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: VNFD name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_vendor(self):
    """
    Getter method for vendor, mapped from YANG variable /vnfd_catalog/vnfd/vendor (string)

    YANG Description: Vendor of the VNFD.
    """
    return self.__vendor
      
  def _set_vendor(self, v, load=False):
    """
    Setter method for vendor, mapped from YANG variable /vnfd_catalog/vnfd/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Vendor of the VNFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor(self):
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_logo(self):
    """
    Getter method for logo, mapped from YANG variable /vnfd_catalog/vnfd/logo (string)

    YANG Description: Vendor logo for the Virtual Network Function
    """
    return self.__logo
      
  def _set_logo(self, v, load=False):
    """
    Setter method for logo, mapped from YANG variable /vnfd_catalog/vnfd/logo (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logo() directly.

    YANG Description: Vendor logo for the Virtual Network Function
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="logo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logo must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__logo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logo(self):
    self.__logo = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/description (string)

    YANG Description: Description of the VNFD.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the VNFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /vnfd_catalog/vnfd/version (string)

    YANG Description: Version of the VNFD
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /vnfd_catalog/vnfd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the VNFD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_vnf_configuration(self):
    """
    Getter method for vnf_configuration, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration (container)
    """
    return self.__vnf_configuration
      
  def _set_vnf_configuration(self, v, load=False):
    """
    Setter method for vnf_configuration, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_configuration() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vnf_configuration_vnfd__vnfd_catalog_vnfd_vnf_configuration, is_container='container', yang_name="vnf-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vnf_configuration_vnfd__vnfd_catalog_vnfd_vnf_configuration, is_container='container', yang_name="vnf-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__vnf_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_configuration(self):
    self.__vnf_configuration = YANGDynClass(base=yc_vnf_configuration_vnfd__vnfd_catalog_vnfd_vnf_configuration, is_container='container', yang_name="vnf-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_operational_status(self):
    """
    Getter method for operational_status, mapped from YANG variable /vnfd_catalog/vnfd/operational_status (vnf-operational-status)

    YANG Description: The operational status of the VNF
 init                : The VNF has just started.
 running             : The VNF is active in VM
 upgrading           : The VNF is being upgraded (EXPERIMENTAL)
 terminate           : The VNF is being terminated
 terminated          : The VNF is in the terminated state.
 failed              : The VNF  instantiation failed.

    """
    return self.__operational_status
      
  def _set_operational_status(self, v, load=False):
    """
    Setter method for operational_status, mapped from YANG variable /vnfd_catalog/vnfd/operational_status (vnf-operational-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_status() directly.

    YANG Description: The operational status of the VNF
 init                : The VNF has just started.
 running             : The VNF is active in VM
 upgrading           : The VNF is being upgraded (EXPERIMENTAL)
 terminate           : The VNF is being terminated
 terminated          : The VNF is in the terminated state.
 failed              : The VNF  instantiation failed.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'terminated': {}, u'upgrading': {}, u'terminate': {}, u'running': {}, u'failed': {}, u'init': {}},), is_leaf=True, yang_name="operational-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='vnf-operational-status', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_status must be of a type compatible with vnf-operational-status""",
          'defined-type': "vnfd:vnf-operational-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'terminated': {}, u'upgrading': {}, u'terminate': {}, u'running': {}, u'failed': {}, u'init': {}},), is_leaf=True, yang_name="operational-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='vnf-operational-status', is_config=True)""",
        })

    self.__operational_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_status(self):
    self.__operational_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'terminated': {}, u'upgrading': {}, u'terminate': {}, u'running': {}, u'failed': {}, u'init': {}},), is_leaf=True, yang_name="operational-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='vnf-operational-status', is_config=True)


  def _get_mgmt_interface(self):
    """
    Getter method for mgmt_interface, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface (container)

    YANG Description: Interface over which the VNF is managed.
    """
    return self.__mgmt_interface
      
  def _set_mgmt_interface(self, v, load=False):
    """
    Setter method for mgmt_interface, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_interface() directly.

    YANG Description: Interface over which the VNF is managed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_mgmt_interface, is_container='container', yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_mgmt_interface, is_container='container', yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__mgmt_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_interface(self):
    self.__mgmt_interface = YANGDynClass(base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_mgmt_interface, is_container='container', yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_internal_vld(self):
    """
    Getter method for internal_vld, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld (list)

    YANG Description: List of Internal Virtual Link Descriptors (VLD).
The internal VLD describes the basic topology of
the connectivity such as E-LAN, E-Line, E-Tree.
between internal VNF components of the system.
    """
    return self.__internal_vld
      
  def _set_internal_vld(self, v, load=False):
    """
    Setter method for internal_vld, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_vld is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_vld() directly.

    YANG Description: List of Internal Virtual Link Descriptors (VLD).
The internal VLD describes the basic topology of
the connectivity such as E-LAN, E-Line, E-Tree.
between internal VNF components of the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_internal_vld_vnfd__vnfd_catalog_vnfd_internal_vld, yang_name="internal-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """internal_vld must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_internal_vld_vnfd__vnfd_catalog_vnfd_internal_vld, yang_name="internal-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__internal_vld = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_internal_vld(self):
    self.__internal_vld = YANGDynClass(base=YANGListType("id",yc_internal_vld_vnfd__vnfd_catalog_vnfd_internal_vld, yang_name="internal-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_ip_profiles(self):
    """
    Getter method for ip_profiles, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles (list)

    YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
    """
    return self.__ip_profiles
      
  def _set_ip_profiles(self, v, load=False):
    """
    Setter method for ip_profiles, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profiles() directly.

    YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_ip_profiles_vnfd__vnfd_catalog_vnfd_ip_profiles, yang_name="ip-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ip-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_profiles must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_ip_profiles_vnfd__vnfd_catalog_vnfd_ip_profiles, yang_name="ip-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ip-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__ip_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_profiles(self):
    self.__ip_profiles = YANGDynClass(base=YANGListType("name",yc_ip_profiles_vnfd__vnfd_catalog_vnfd_ip_profiles, yang_name="ip-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ip-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_connection_point(self):
    """
    Getter method for connection_point, mapped from YANG variable /vnfd_catalog/vnfd/connection_point (list)

    YANG Description: List for external connection points. Each VNF has one
or more external connection points that connect the VNF
to other VNFs or to external networks. Each VNF exposes
connection points to the orchestrator, which can construct
network services by connecting the connection points
between different VNFs. The NFVO will use VLDs and VNFFGs
at the network service level to construct network services.
    """
    return self.__connection_point
      
  def _set_connection_point(self, v, load=False):
    """
    Setter method for connection_point, mapped from YANG variable /vnfd_catalog/vnfd/connection_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_point() directly.

    YANG Description: List for external connection points. Each VNF has one
or more external connection points that connect the VNF
to other VNFs or to external networks. Each VNF exposes
connection points to the orchestrator, which can construct
network services by connecting the connection points
between different VNFs. The NFVO will use VLDs and VNFFGs
at the network service level to construct network services.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_connection_point_vnfd__vnfd_catalog_vnfd_connection_point, yang_name="connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_connection_point_vnfd__vnfd_catalog_vnfd_connection_point, yang_name="connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__connection_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_point(self):
    self.__connection_point = YANGDynClass(base=YANGListType("name",yc_connection_point_vnfd__vnfd_catalog_vnfd_connection_point, yang_name="connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_vdu(self):
    """
    Getter method for vdu, mapped from YANG variable /vnfd_catalog/vnfd/vdu (list)

    YANG Description: List of Virtual Deployment Units
    """
    return self.__vdu
      
  def _set_vdu(self, v, load=False):
    """
    Setter method for vdu, mapped from YANG variable /vnfd_catalog/vnfd/vdu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu() directly.

    YANG Description: List of Virtual Deployment Units
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_vdu_vnfd__vnfd_catalog_vnfd_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_vdu_vnfd__vnfd_catalog_vnfd_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__vdu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu(self):
    self.__vdu = YANGDynClass(base=YANGListType("id",yc_vdu_vnfd__vnfd_catalog_vnfd_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_kdu(self):
    """
    Getter method for kdu, mapped from YANG variable /vnfd_catalog/vnfd/kdu (list)

    YANG Description: List of K8s Deployment Units
    """
    return self.__kdu
      
  def _set_kdu(self, v, load=False):
    """
    Setter method for kdu, mapped from YANG variable /vnfd_catalog/vnfd/kdu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_kdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_kdu() directly.

    YANG Description: List of K8s Deployment Units
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_kdu_vnfd__vnfd_catalog_vnfd_kdu, yang_name="kdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="kdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """kdu must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_kdu_vnfd__vnfd_catalog_vnfd_kdu, yang_name="kdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="kdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__kdu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_kdu(self):
    self.__kdu = YANGDynClass(base=YANGListType("name",yc_kdu_vnfd__vnfd_catalog_vnfd_kdu, yang_name="kdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="kdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_paas(self):
    """
    Getter method for paas, mapped from YANG variable /vnfd_catalog/vnfd/paas (list)

    YANG Description: List of PaaS Deployment Units
    """
    return self.__paas
      
  def _set_paas(self, v, load=False):
    """
    Setter method for paas, mapped from YANG variable /vnfd_catalog/vnfd/paas (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paas() directly.

    YANG Description: List of PaaS Deployment Units
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_paas_vnfd__vnfd_catalog_vnfd_paas, yang_name="paas", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="paas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """paas must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_paas_vnfd__vnfd_catalog_vnfd_paas, yang_name="paas", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="paas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__paas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_paas(self):
    self.__paas = YANGDynClass(base=YANGListType("id",yc_paas_vnfd__vnfd_catalog_vnfd_paas, yang_name="paas", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="paas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_k8s_cluster(self):
    """
    Getter method for k8s_cluster, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster (container)
    """
    return self.__k8s_cluster
      
  def _set_k8s_cluster(self, v, load=False):
    """
    Setter method for k8s_cluster, mapped from YANG variable /vnfd_catalog/vnfd/k8s_cluster (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_k8s_cluster is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_k8s_cluster() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_k8s_cluster_vnfd__vnfd_catalog_vnfd_k8s_cluster, is_container='container', yang_name="k8s-cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """k8s_cluster must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_k8s_cluster_vnfd__vnfd_catalog_vnfd_k8s_cluster, is_container='container', yang_name="k8s-cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__k8s_cluster = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_k8s_cluster(self):
    self.__k8s_cluster = YANGDynClass(base=yc_k8s_cluster_vnfd__vnfd_catalog_vnfd_k8s_cluster, is_container='container', yang_name="k8s-cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)


  def _get_vdu_dependency(self):
    """
    Getter method for vdu_dependency, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency (list)

    YANG Description: List of VDU dependencies.
    """
    return self.__vdu_dependency
      
  def _set_vdu_dependency(self, v, load=False):
    """
    Setter method for vdu_dependency, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_dependency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_dependency() directly.

    YANG Description: List of VDU dependencies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vdu_source_ref",yc_vdu_dependency_vnfd__vnfd_catalog_vnfd_vdu_dependency, yang_name="vdu-dependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-source-ref', extensions=None), is_container='list', yang_name="vdu-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_dependency must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vdu_source_ref",yc_vdu_dependency_vnfd__vnfd_catalog_vnfd_vdu_dependency, yang_name="vdu-dependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-source-ref', extensions=None), is_container='list', yang_name="vdu-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__vdu_dependency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_dependency(self):
    self.__vdu_dependency = YANGDynClass(base=YANGListType("vdu_source_ref",yc_vdu_dependency_vnfd__vnfd_catalog_vnfd_vdu_dependency, yang_name="vdu-dependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-source-ref', extensions=None), is_container='list', yang_name="vdu-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_service_function_chain(self):
    """
    Getter method for service_function_chain, mapped from YANG variable /vnfd_catalog/vnfd/service_function_chain (enumeration)

    YANG Description: Type of node in Service Function Chaining Architecture
    """
    return self.__service_function_chain
      
  def _set_service_function_chain(self, v, load=False):
    """
    Setter method for service_function_chain, mapped from YANG variable /vnfd_catalog/vnfd/service_function_chain (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_function_chain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_function_chain() directly.

    YANG Description: Type of node in Service Function Chaining Architecture
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'SFF': {}, u'CLASSIFIER': {}, u'UNAWARE': {}, u'SF': {}},), default=six.text_type("UNAWARE"), is_leaf=True, yang_name="service-function-chain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_function_chain must be of a type compatible with enumeration""",
          'defined-type': "vnfd:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'SFF': {}, u'CLASSIFIER': {}, u'UNAWARE': {}, u'SF': {}},), default=six.text_type("UNAWARE"), is_leaf=True, yang_name="service-function-chain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""",
        })

    self.__service_function_chain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_function_chain(self):
    self.__service_function_chain = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'SFF': {}, u'CLASSIFIER': {}, u'UNAWARE': {}, u'SF': {}},), default=six.text_type("UNAWARE"), is_leaf=True, yang_name="service-function-chain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)


  def _get_service_function_type(self):
    """
    Getter method for service_function_type, mapped from YANG variable /vnfd_catalog/vnfd/service_function_type (string)

    YANG Description: Type of Service Function.
NOTE: This needs to map with Service Function Type in ODL to
support VNFFG. Service Function Type is mandatory param in ODL
SFC. This is temporarily set to string for ease of use
    """
    return self.__service_function_type
      
  def _set_service_function_type(self, v, load=False):
    """
    Setter method for service_function_type, mapped from YANG variable /vnfd_catalog/vnfd/service_function_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_function_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_function_type() directly.

    YANG Description: Type of Service Function.
NOTE: This needs to map with Service Function Type in ODL to
support VNFFG. Service Function Type is mandatory param in ODL
SFC. This is temporarily set to string for ease of use
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="service-function-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_function_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="service-function-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__service_function_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_function_type(self):
    self.__service_function_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="service-function-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_http_endpoint(self):
    """
    Getter method for http_endpoint, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint (list)

    YANG Description: List of http endpoints to be used by monitoring params
    """
    return self.__http_endpoint
      
  def _set_http_endpoint(self, v, load=False):
    """
    Setter method for http_endpoint, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_http_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_http_endpoint() directly.

    YANG Description: List of http endpoints to be used by monitoring params
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("path",yc_http_endpoint_vnfd__vnfd_catalog_vnfd_http_endpoint, yang_name="http-endpoint", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path', extensions=None), is_container='list', yang_name="http-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """http_endpoint must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("path",yc_http_endpoint_vnfd__vnfd_catalog_vnfd_http_endpoint, yang_name="http-endpoint", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path', extensions=None), is_container='list', yang_name="http-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__http_endpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_http_endpoint(self):
    self.__http_endpoint = YANGDynClass(base=YANGListType("path",yc_http_endpoint_vnfd__vnfd_catalog_vnfd_http_endpoint, yang_name="http-endpoint", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path', extensions=None), is_container='list', yang_name="http-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_scaling_group_descriptor(self):
    """
    Getter method for scaling_group_descriptor, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor (list)

    YANG Description: scaling group descriptor within the VNF.
The scaling group defines a group of VDUs,
and the ratio of VDUs in the VNF
that is used as target for scaling action
    """
    return self.__scaling_group_descriptor
      
  def _set_scaling_group_descriptor(self, v, load=False):
    """
    Setter method for scaling_group_descriptor, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_group_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_group_descriptor() directly.

    YANG Description: scaling group descriptor within the VNF.
The scaling group defines a group of VDUs,
and the ratio of VDUs in the VNF
that is used as target for scaling action
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_scaling_group_descriptor_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor, yang_name="scaling-group-descriptor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-group-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scaling_group_descriptor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_group_descriptor_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor, yang_name="scaling-group-descriptor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-group-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__scaling_group_descriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scaling_group_descriptor(self):
    self.__scaling_group_descriptor = YANGDynClass(base=YANGListType("name",yc_scaling_group_descriptor_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor, yang_name="scaling-group-descriptor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-group-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_monitoring_param(self):
    """
    Getter method for monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param (list)

    YANG Description: List of monitoring parameters at the network service level
    """
    return self.__monitoring_param
      
  def _set_monitoring_param(self, v, load=False):
    """
    Setter method for monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_param is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_param() directly.

    YANG Description: List of monitoring parameters at the network service level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitoring_param must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__monitoring_param = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitoring_param(self):
    self.__monitoring_param = YANGDynClass(base=YANGListType("id",yc_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)


  def _get_placement_groups(self):
    """
    Getter method for placement_groups, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups (list)

    YANG Description: List of placement groups at VNF level
    """
    return self.__placement_groups
      
  def _set_placement_groups(self, v, load=False):
    """
    Setter method for placement_groups, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_placement_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_placement_groups() directly.

    YANG Description: List of placement groups at VNF level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_placement_groups_vnfd__vnfd_catalog_vnfd_placement_groups, yang_name="placement-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="placement-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """placement_groups must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_placement_groups_vnfd__vnfd_catalog_vnfd_placement_groups, yang_name="placement-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="placement-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__placement_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_placement_groups(self):
    self.__placement_groups = YANGDynClass(base=YANGListType("name",yc_placement_groups_vnfd__vnfd_catalog_vnfd_placement_groups, yang_name="placement-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="placement-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  vendor = __builtin__.property(_get_vendor, _set_vendor)
  logo = __builtin__.property(_get_logo, _set_logo)
  description = __builtin__.property(_get_description, _set_description)
  version = __builtin__.property(_get_version, _set_version)
  vnf_configuration = __builtin__.property(_get_vnf_configuration, _set_vnf_configuration)
  operational_status = __builtin__.property(_get_operational_status, _set_operational_status)
  mgmt_interface = __builtin__.property(_get_mgmt_interface, _set_mgmt_interface)
  internal_vld = __builtin__.property(_get_internal_vld, _set_internal_vld)
  ip_profiles = __builtin__.property(_get_ip_profiles, _set_ip_profiles)
  connection_point = __builtin__.property(_get_connection_point, _set_connection_point)
  vdu = __builtin__.property(_get_vdu, _set_vdu)
  kdu = __builtin__.property(_get_kdu, _set_kdu)
  paas = __builtin__.property(_get_paas, _set_paas)
  k8s_cluster = __builtin__.property(_get_k8s_cluster, _set_k8s_cluster)
  vdu_dependency = __builtin__.property(_get_vdu_dependency, _set_vdu_dependency)
  service_function_chain = __builtin__.property(_get_service_function_chain, _set_service_function_chain)
  service_function_type = __builtin__.property(_get_service_function_type, _set_service_function_type)
  http_endpoint = __builtin__.property(_get_http_endpoint, _set_http_endpoint)
  scaling_group_descriptor = __builtin__.property(_get_scaling_group_descriptor, _set_scaling_group_descriptor)
  monitoring_param = __builtin__.property(_get_monitoring_param, _set_monitoring_param)
  placement_groups = __builtin__.property(_get_placement_groups, _set_placement_groups)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('short_name', short_name), ('vendor', vendor), ('logo', logo), ('description', description), ('version', version), ('vnf_configuration', vnf_configuration), ('operational_status', operational_status), ('mgmt_interface', mgmt_interface), ('internal_vld', internal_vld), ('ip_profiles', ip_profiles), ('connection_point', connection_point), ('vdu', vdu), ('kdu', kdu), ('paas', paas), ('k8s_cluster', k8s_cluster), ('vdu_dependency', vdu_dependency), ('service_function_chain', service_function_chain), ('service_function_type', service_function_type), ('http_endpoint', http_endpoint), ('scaling_group_descriptor', scaling_group_descriptor), ('monitoring_param', monitoring_param), ('placement_groups', placement_groups), ])


class yc_vnfd_catalog_vnfd__vnfd_catalog(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Virtual Network Function Descriptor (VNFD).
  """
  __slots__ = ('_path_helper', '_extmethods', '__schema_version','__vnfd',)

  _yang_name = 'vnfd-catalog'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnfd = YANGDynClass(base=YANGListType("id",yc_vnfd_vnfd__vnfd_catalog_vnfd, yang_name="vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    self.__schema_version = YANGDynClass(base=six.text_type, default=six.text_type("v3.0"), is_leaf=True, yang_name="schema-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'vnfd-catalog']

  def _get_schema_version(self):
    """
    Getter method for schema_version, mapped from YANG variable /vnfd_catalog/schema_version (string)

    YANG Description: Schema version for the VNFD. If unspecified, it assumes v3.0
    """
    return self.__schema_version
      
  def _set_schema_version(self, v, load=False):
    """
    Setter method for schema_version, mapped from YANG variable /vnfd_catalog/schema_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema_version() directly.

    YANG Description: Schema version for the VNFD. If unspecified, it assumes v3.0
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("v3.0"), is_leaf=True, yang_name="schema-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """schema_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("v3.0"), is_leaf=True, yang_name="schema-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""",
        })

    self.__schema_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_schema_version(self):
    self.__schema_version = YANGDynClass(base=six.text_type, default=six.text_type("v3.0"), is_leaf=True, yang_name="schema-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='string', is_config=True)


  def _get_vnfd(self):
    """
    Getter method for vnfd, mapped from YANG variable /vnfd_catalog/vnfd (list)
    """
    return self.__vnfd
      
  def _set_vnfd(self, v, load=False):
    """
    Setter method for vnfd, mapped from YANG variable /vnfd_catalog/vnfd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_vnfd_vnfd__vnfd_catalog_vnfd, yang_name="vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_vnfd_vnfd__vnfd_catalog_vnfd, yang_name="vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""",
        })

    self.__vnfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd(self):
    self.__vnfd = YANGDynClass(base=YANGListType("id",yc_vnfd_vnfd__vnfd_catalog_vnfd, yang_name="vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='list', is_config=True)

  schema_version = __builtin__.property(_get_schema_version, _set_schema_version)
  vnfd = __builtin__.property(_get_vnfd, _set_vnfd)


  _pyangbind_elements = OrderedDict([('schema_version', schema_version), ('vnfd', vnfd), ])


class vnfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vnfd_catalog',)

  _yang_name = 'vnfd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vnfd_catalog = YANGDynClass(base=yc_vnfd_catalog_vnfd__vnfd_catalog, is_container='container', yang_name="vnfd-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_vnfd_catalog(self):
    """
    Getter method for vnfd_catalog, mapped from YANG variable /vnfd_catalog (container)

    YANG Description: Virtual Network Function Descriptor (VNFD).
    """
    return self.__vnfd_catalog
      
  def _set_vnfd_catalog(self, v, load=False):
    """
    Setter method for vnfd_catalog, mapped from YANG variable /vnfd_catalog (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_catalog is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_catalog() directly.

    YANG Description: Virtual Network Function Descriptor (VNFD).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vnfd_catalog_vnfd__vnfd_catalog, is_container='container', yang_name="vnfd-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfd_catalog must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vnfd_catalog_vnfd__vnfd_catalog, is_container='container', yang_name="vnfd-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""",
        })

    self.__vnfd_catalog = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfd_catalog(self):
    self.__vnfd_catalog = YANGDynClass(base=yc_vnfd_catalog_vnfd__vnfd_catalog, is_container='container', yang_name="vnfd-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:vnfd', defining_module='vnfd', yang_type='container', is_config=True)

  vnfd_catalog = __builtin__.property(_get_vnfd_catalog, _set_vnfd_catalog)


  _pyangbind_elements = OrderedDict([('vnfd_catalog', vnfd_catalog), ])


